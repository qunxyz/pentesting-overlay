diff -uNr php-5.3.29-ori/ext/openssl/CREDITS php-5.3.29/ext/openssl/CREDITS
--- php-5.3.29-ori/ext/openssl/CREDITS	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/CREDITS	2019-01-26 02:28:51.216128000 +0800
@@ -1,2 +1,2 @@
 OpenSSL
-Stig Venaas, Wez Furlong, Sascha Kettler
+Stig Venaas, Wez Furlong, Sascha Kettler, Scott MacVicar
diff -uNr php-5.3.29-ori/ext/openssl/config.w32 php-5.3.29/ext/openssl/config.w32
--- php-5.3.29-ori/ext/openssl/config.w32	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/config.w32	2019-01-26 02:28:51.216128000 +0800
@@ -6,6 +6,7 @@
 if (PHP_OPENSSL != "no") {
 	if (CHECK_LIB("ssleay32.lib", "openssl", PHP_OPENSSL) &&
 			CHECK_LIB("libeay32.lib", "openssl", PHP_OPENSSL) &&
+			CHECK_LIB("crypt32.lib", "openssl") &&
 			CHECK_HEADER_ADD_INCLUDE("openssl/ssl.h", "CFLAGS_OPENSSL")) {
 		EXTENSION("openssl", "openssl.c xp_ssl.c");
 
diff -uNr php-5.3.29-ori/ext/openssl/config0.m4 php-5.3.29/ext/openssl/config0.m4
--- php-5.3.29-ori/ext/openssl/config0.m4	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/config0.m4	2019-01-26 02:28:51.216128000 +0800
@@ -3,11 +3,14 @@
 dnl
 
 PHP_ARG_WITH(openssl, for OpenSSL support,
-[  --with-openssl[=DIR]    Include OpenSSL support (requires OpenSSL >= 0.9.6)])
+[  --with-openssl[=DIR]      Include OpenSSL support (requires OpenSSL >= 0.9.6)])
 
 PHP_ARG_WITH(kerberos, for Kerberos support,
 [  --with-kerberos[=DIR]     OPENSSL: Include Kerberos support], no, no)
 
+PHP_ARG_WITH(system-ciphers, whether to use system default cipher list instead of hardcoded value,
+[  --with-system-ciphers   OPENSSL: Use system default cipher list instead of hardcoded value], no, no)
+
 if test "$PHP_OPENSSL" != "no"; then
   PHP_NEW_EXTENSION(openssl, openssl.c xp_ssl.c, $ext_shared)
   PHP_SUBST(OPENSSL_SHARED_LIBADD)
@@ -18,6 +21,7 @@
 
   AC_CHECK_LIB(ssl, DSA_get_default_method, AC_DEFINE(HAVE_DSA_DEFAULT_METHOD, 1, [OpenSSL 0.9.7 or later]))
   AC_CHECK_LIB(crypto, X509_free, AC_DEFINE(HAVE_DSA_DEFAULT_METHOD, 1, [OpenSSL 0.9.7 or later]))
+  AC_CHECK_FUNCS([RAND_egd])
 
   PHP_SETUP_OPENSSL(OPENSSL_SHARED_LIBADD, 
   [
@@ -25,4 +29,7 @@
   ], [
     AC_MSG_ERROR([OpenSSL check failed. Please check config.log for more information.])
   ])
+  if test "$PHP_SYSTEM_CIPHERS" != "no"; then
+    AC_DEFINE(USE_OPENSSL_SYSTEM_CIPHERS,1,[ Use system default cipher list instead of hardcoded value ])
+  fi
 fi
diff -uNr php-5.3.29-ori/ext/openssl/openssl.c php-5.3.29/ext/openssl/openssl.c
--- php-5.3.29-ori/ext/openssl/openssl.c	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/openssl.c	2019-01-26 12:15:07.405030722 +0800
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | PHP Version 5                                                        |
    +----------------------------------------------------------------------+
-   | Copyright (c) 1997-2013 The PHP Group                                |
+   | Copyright (c) 1997-2016 The PHP Group                                |
    +----------------------------------------------------------------------+
    | This source file is subject to version 3.01 of the PHP license,      |
    | that is bundled with this package in the file LICENSE, and is        |
@@ -27,6 +27,7 @@
 #endif
 
 #include "php.h"
+#include "php_ini.h"
 #include "php_openssl.h"
 
 /* PHP Includes */
@@ -35,9 +36,18 @@
 #include "ext/standard/php_fopen_wrappers.h"
 #include "ext/standard/md5.h"
 #include "ext/standard/base64.h"
+#ifdef PHP_WIN32
+# include "win32/winutil.h"
+#endif
 
 /* OpenSSL includes */
 #include <openssl/evp.h>
+#if OPENSSL_VERSION_NUMBER >= 0x10002000L
+#include <openssl/bn.h>
+#include <openssl/rsa.h>
+#include <openssl/dsa.h>
+#include <openssl/dh.h>
+#endif
 #include <openssl/x509.h>
 #include <openssl/x509v3.h>
 #include <openssl/crypto.h>
@@ -65,9 +75,19 @@
 #define OPENSSL_ALGO_MD2	4
 #endif
 #define OPENSSL_ALGO_DSS1	5
-
+#if OPENSSL_VERSION_NUMBER >= 0x0090708fL
+#define OPENSSL_ALGO_SHA224 6
+#define OPENSSL_ALGO_SHA256 7
+#define OPENSSL_ALGO_SHA384 8
+#define OPENSSL_ALGO_SHA512 9
+#define OPENSSL_ALGO_RMD160 10
+#endif
 #define DEBUG_SMIME	0
 
+#if !defined(OPENSSL_NO_EC) && defined(EVP_PKEY_EC)
+#define HAVE_EVP_PKEY_EC 1
+#endif
+
 /* FIXME: Use the openssl constants instead of
  * enum. It is now impossible to match real values
  * against php constants. Also sorry to break the
@@ -78,7 +98,7 @@
 	OPENSSL_KEYTYPE_DSA,
 	OPENSSL_KEYTYPE_DH,
 	OPENSSL_KEYTYPE_DEFAULT = OPENSSL_KEYTYPE_RSA,
-#ifdef EVP_PKEY_EC
+#ifdef HAVE_EVP_PKEY_EC
 	OPENSSL_KEYTYPE_EC = OPENSSL_KEYTYPE_DH +1
 #endif
 };
@@ -89,6 +109,9 @@
 	PHP_OPENSSL_CIPHER_RC2_64,
 	PHP_OPENSSL_CIPHER_DES,
 	PHP_OPENSSL_CIPHER_3DES,
+	PHP_OPENSSL_CIPHER_AES_128_CBC,
+	PHP_OPENSSL_CIPHER_AES_192_CBC,
+	PHP_OPENSSL_CIPHER_AES_256_CBC,
 
 	PHP_OPENSSL_CIPHER_DEFAULT = PHP_OPENSSL_CIPHER_RC2_40
 };
@@ -106,277 +129,323 @@
 
 /* {{{ arginfo */
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_x509_export_to_file, 0, 0, 2)
-    ZEND_ARG_INFO(0, x509)
-    ZEND_ARG_INFO(0, outfilename)
-    ZEND_ARG_INFO(0, notext)
+	ZEND_ARG_INFO(0, x509)
+	ZEND_ARG_INFO(0, outfilename)
+	ZEND_ARG_INFO(0, notext)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_x509_export, 0, 0, 2)
-    ZEND_ARG_INFO(0, x509)
-    ZEND_ARG_INFO(1, out)
-    ZEND_ARG_INFO(0, notext)
+	ZEND_ARG_INFO(0, x509)
+	ZEND_ARG_INFO(1, out)
+	ZEND_ARG_INFO(0, notext)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_x509_fingerprint, 0, 0, 1)
+	ZEND_ARG_INFO(0, x509)
+	ZEND_ARG_INFO(0, method)
+	ZEND_ARG_INFO(0, raw_output)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO(arginfo_openssl_x509_check_private_key, 0)
-    ZEND_ARG_INFO(0, cert)
-    ZEND_ARG_INFO(0, key)
+	ZEND_ARG_INFO(0, cert)
+	ZEND_ARG_INFO(0, key)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO(arginfo_openssl_x509_parse, 0)
-    ZEND_ARG_INFO(0, x509)
-    ZEND_ARG_INFO(0, shortname)
+	ZEND_ARG_INFO(0, x509)
+	ZEND_ARG_INFO(0, shortname)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_x509_checkpurpose, 0, 0, 3)
-    ZEND_ARG_INFO(0, x509cert)
-    ZEND_ARG_INFO(0, purpose)
-    ZEND_ARG_INFO(0, cainfo) /* array */
-    ZEND_ARG_INFO(0, untrustedfile)
+	ZEND_ARG_INFO(0, x509cert)
+	ZEND_ARG_INFO(0, purpose)
+	ZEND_ARG_INFO(0, cainfo) /* array */
+	ZEND_ARG_INFO(0, untrustedfile)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO(arginfo_openssl_x509_read, 0)
-    ZEND_ARG_INFO(0, cert)
+	ZEND_ARG_INFO(0, cert)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO(arginfo_openssl_x509_free, 0)
-    ZEND_ARG_INFO(0, x509)
+	ZEND_ARG_INFO(0, x509)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_pkcs12_export_to_file, 0, 0, 4)
-    ZEND_ARG_INFO(0, x509)
-    ZEND_ARG_INFO(0, filename)
-    ZEND_ARG_INFO(0, priv_key)
-    ZEND_ARG_INFO(0, pass)
-    ZEND_ARG_INFO(0, args) /* array */
+	ZEND_ARG_INFO(0, x509)
+	ZEND_ARG_INFO(0, filename)
+	ZEND_ARG_INFO(0, priv_key)
+	ZEND_ARG_INFO(0, pass)
+	ZEND_ARG_INFO(0, args) /* array */
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO(arginfo_openssl_pkcs12_export, 0)
-    ZEND_ARG_INFO(0, x509)
-    ZEND_ARG_INFO(1, out)
-    ZEND_ARG_INFO(0, priv_key)
-    ZEND_ARG_INFO(0, pass)
-    ZEND_ARG_INFO(0, args) /* array */
+	ZEND_ARG_INFO(0, x509)
+	ZEND_ARG_INFO(1, out)
+	ZEND_ARG_INFO(0, priv_key)
+	ZEND_ARG_INFO(0, pass)
+	ZEND_ARG_INFO(0, args) /* array */
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO(arginfo_openssl_pkcs12_read, 0)
-    ZEND_ARG_INFO(0, PKCS12)
-    ZEND_ARG_INFO(1, certs) /* array */
-    ZEND_ARG_INFO(0, pass)
+	ZEND_ARG_INFO(0, PKCS12)
+	ZEND_ARG_INFO(1, certs) /* array */
+	ZEND_ARG_INFO(0, pass)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_csr_export_to_file, 0, 0, 2)
-    ZEND_ARG_INFO(0, csr)
-    ZEND_ARG_INFO(0, outfilename)
-    ZEND_ARG_INFO(0, notext)
+	ZEND_ARG_INFO(0, csr)
+	ZEND_ARG_INFO(0, outfilename)
+	ZEND_ARG_INFO(0, notext)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_csr_export, 0, 0, 2)
-    ZEND_ARG_INFO(0, csr)
-    ZEND_ARG_INFO(1, out)
-    ZEND_ARG_INFO(0, notext)
+	ZEND_ARG_INFO(0, csr)
+	ZEND_ARG_INFO(1, out)
+	ZEND_ARG_INFO(0, notext)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_csr_sign, 0, 0, 4)
-    ZEND_ARG_INFO(0, csr)
-    ZEND_ARG_INFO(0, x509)
-    ZEND_ARG_INFO(0, priv_key)
-    ZEND_ARG_INFO(0, days)
-    ZEND_ARG_INFO(0, config_args) /* array */
-    ZEND_ARG_INFO(0, serial)
+	ZEND_ARG_INFO(0, csr)
+	ZEND_ARG_INFO(0, x509)
+	ZEND_ARG_INFO(0, priv_key)
+	ZEND_ARG_INFO(0, days)
+	ZEND_ARG_INFO(0, config_args) /* array */
+	ZEND_ARG_INFO(0, serial)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_csr_new, 0, 0, 2)
-    ZEND_ARG_INFO(0, dn) /* array */
-    ZEND_ARG_INFO(1, privkey)
-    ZEND_ARG_INFO(0, configargs)
-    ZEND_ARG_INFO(0, extraattribs)
+	ZEND_ARG_INFO(0, dn) /* array */
+	ZEND_ARG_INFO(1, privkey)
+	ZEND_ARG_INFO(0, configargs)
+	ZEND_ARG_INFO(0, extraattribs)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO(arginfo_openssl_csr_get_subject, 0)
-    ZEND_ARG_INFO(0, csr)
+	ZEND_ARG_INFO(0, csr)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO(arginfo_openssl_csr_get_public_key, 0)
-    ZEND_ARG_INFO(0, csr)
+	ZEND_ARG_INFO(0, csr)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_pkey_new, 0, 0, 0)
-    ZEND_ARG_INFO(0, configargs) /* array */
+	ZEND_ARG_INFO(0, configargs) /* array */
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_pkey_export_to_file, 0, 0, 2)
-    ZEND_ARG_INFO(0, key)
-    ZEND_ARG_INFO(0, outfilename)
-    ZEND_ARG_INFO(0, passphrase)
-    ZEND_ARG_INFO(0, config_args) /* array */
+	ZEND_ARG_INFO(0, key)
+	ZEND_ARG_INFO(0, outfilename)
+	ZEND_ARG_INFO(0, passphrase)
+	ZEND_ARG_INFO(0, config_args) /* array */
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_pkey_export, 0, 0, 2)
-    ZEND_ARG_INFO(0, key)
-    ZEND_ARG_INFO(1, out)
-    ZEND_ARG_INFO(0, passphrase)
-    ZEND_ARG_INFO(0, config_args) /* array */
+	ZEND_ARG_INFO(0, key)
+	ZEND_ARG_INFO(1, out)
+	ZEND_ARG_INFO(0, passphrase)
+	ZEND_ARG_INFO(0, config_args) /* array */
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO(arginfo_openssl_pkey_get_public, 0)
-    ZEND_ARG_INFO(0, cert)
+	ZEND_ARG_INFO(0, cert)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO(arginfo_openssl_pkey_free, 0)
-    ZEND_ARG_INFO(0, key)
+	ZEND_ARG_INFO(0, key)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_pkey_get_private, 0, 0, 1)
-    ZEND_ARG_INFO(0, key)
-    ZEND_ARG_INFO(0, passphrase)
+	ZEND_ARG_INFO(0, key)
+	ZEND_ARG_INFO(0, passphrase)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO(arginfo_openssl_pkey_get_details, 0)
-    ZEND_ARG_INFO(0, key)
+	ZEND_ARG_INFO(0, key)
 ZEND_END_ARG_INFO()
 
+#if OPENSSL_VERSION_NUMBER >= 0x10000000L
+ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_pbkdf2, 0, 0, 4)
+	ZEND_ARG_INFO(0, password)
+	ZEND_ARG_INFO(0, salt)
+	ZEND_ARG_INFO(0, key_length)
+	ZEND_ARG_INFO(0, iterations)
+	ZEND_ARG_INFO(0, digest_algorithm)
+ZEND_END_ARG_INFO()
+#endif
+
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_pkcs7_verify, 0, 0, 2)
-    ZEND_ARG_INFO(0, filename)
-    ZEND_ARG_INFO(0, flags)
-    ZEND_ARG_INFO(0, signerscerts)
-    ZEND_ARG_INFO(0, cainfo) /* array */
-    ZEND_ARG_INFO(0, extracerts)
-    ZEND_ARG_INFO(0, content)
+	ZEND_ARG_INFO(0, filename)
+	ZEND_ARG_INFO(0, flags)
+	ZEND_ARG_INFO(0, signerscerts)
+	ZEND_ARG_INFO(0, cainfo) /* array */
+	ZEND_ARG_INFO(0, extracerts)
+	ZEND_ARG_INFO(0, content)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_pkcs7_encrypt, 0, 0, 4)
-    ZEND_ARG_INFO(0, infile)
-    ZEND_ARG_INFO(0, outfile)
-    ZEND_ARG_INFO(0, recipcerts)
-    ZEND_ARG_INFO(0, headers) /* array */
-    ZEND_ARG_INFO(0, flags)
-    ZEND_ARG_INFO(0, cipher)
+	ZEND_ARG_INFO(0, infile)
+	ZEND_ARG_INFO(0, outfile)
+	ZEND_ARG_INFO(0, recipcerts)
+	ZEND_ARG_INFO(0, headers) /* array */
+	ZEND_ARG_INFO(0, flags)
+	ZEND_ARG_INFO(0, cipher)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_pkcs7_sign, 0, 0, 5)
-    ZEND_ARG_INFO(0, infile)
-    ZEND_ARG_INFO(0, outfile)
-    ZEND_ARG_INFO(0, signcert)
-    ZEND_ARG_INFO(0, signkey)
-    ZEND_ARG_INFO(0, headers) /* array */
-    ZEND_ARG_INFO(0, flags)
-    ZEND_ARG_INFO(0, extracertsfilename)
+	ZEND_ARG_INFO(0, infile)
+	ZEND_ARG_INFO(0, outfile)
+	ZEND_ARG_INFO(0, signcert)
+	ZEND_ARG_INFO(0, signkey)
+	ZEND_ARG_INFO(0, headers) /* array */
+	ZEND_ARG_INFO(0, flags)
+	ZEND_ARG_INFO(0, extracertsfilename)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_pkcs7_decrypt, 0, 0, 3)
-    ZEND_ARG_INFO(0, infilename)
-    ZEND_ARG_INFO(0, outfilename)
-    ZEND_ARG_INFO(0, recipcert)
-    ZEND_ARG_INFO(0, recipkey)
+	ZEND_ARG_INFO(0, infilename)
+	ZEND_ARG_INFO(0, outfilename)
+	ZEND_ARG_INFO(0, recipcert)
+	ZEND_ARG_INFO(0, recipkey)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_private_encrypt, 0, 0, 3)
-    ZEND_ARG_INFO(0, data)
-    ZEND_ARG_INFO(1, crypted)
-    ZEND_ARG_INFO(0, key)
-    ZEND_ARG_INFO(0, padding)
+	ZEND_ARG_INFO(0, data)
+	ZEND_ARG_INFO(1, crypted)
+	ZEND_ARG_INFO(0, key)
+	ZEND_ARG_INFO(0, padding)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_private_decrypt, 0, 0, 3)
-    ZEND_ARG_INFO(0, data)
-    ZEND_ARG_INFO(1, crypted)
-    ZEND_ARG_INFO(0, key)
-    ZEND_ARG_INFO(0, padding)
+	ZEND_ARG_INFO(0, data)
+	ZEND_ARG_INFO(1, crypted)
+	ZEND_ARG_INFO(0, key)
+	ZEND_ARG_INFO(0, padding)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_public_encrypt, 0, 0, 3)
-    ZEND_ARG_INFO(0, data)
-    ZEND_ARG_INFO(1, crypted)
-    ZEND_ARG_INFO(0, key)
-    ZEND_ARG_INFO(0, padding)
+	ZEND_ARG_INFO(0, data)
+	ZEND_ARG_INFO(1, crypted)
+	ZEND_ARG_INFO(0, key)
+	ZEND_ARG_INFO(0, padding)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_public_decrypt, 0, 0, 3)
-    ZEND_ARG_INFO(0, data)
-    ZEND_ARG_INFO(1, crypted)
-    ZEND_ARG_INFO(0, key)
-    ZEND_ARG_INFO(0, padding)
+	ZEND_ARG_INFO(0, data)
+	ZEND_ARG_INFO(1, crypted)
+	ZEND_ARG_INFO(0, key)
+	ZEND_ARG_INFO(0, padding)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO(arginfo_openssl_error_string, 0)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_sign, 0, 0, 3)
-    ZEND_ARG_INFO(0, data)
-    ZEND_ARG_INFO(1, signature)
-    ZEND_ARG_INFO(0, key)
-    ZEND_ARG_INFO(0, method)
+	ZEND_ARG_INFO(0, data)
+	ZEND_ARG_INFO(1, signature)
+	ZEND_ARG_INFO(0, key)
+	ZEND_ARG_INFO(0, method)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_verify, 0, 0, 3)
-    ZEND_ARG_INFO(0, data)
-    ZEND_ARG_INFO(0, signature)
-    ZEND_ARG_INFO(0, key)
-    ZEND_ARG_INFO(0, method)
+	ZEND_ARG_INFO(0, data)
+	ZEND_ARG_INFO(0, signature)
+	ZEND_ARG_INFO(0, key)
+	ZEND_ARG_INFO(0, method)
 ZEND_END_ARG_INFO()
 
-ZEND_BEGIN_ARG_INFO(arginfo_openssl_seal, 0)
-    ZEND_ARG_INFO(0, data)
-    ZEND_ARG_INFO(1, sealdata)
-    ZEND_ARG_INFO(1, ekeys) /* arary */
-    ZEND_ARG_INFO(0, pubkeys) /* array */
+ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_seal, 0, 0, 4)
+	ZEND_ARG_INFO(0, data)
+	ZEND_ARG_INFO(1, sealdata)
+	ZEND_ARG_INFO(1, ekeys) /* arary */
+	ZEND_ARG_INFO(0, pubkeys) /* array */
+	ZEND_ARG_INFO(0, method)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO(arginfo_openssl_open, 0)
-    ZEND_ARG_INFO(0, data)
-    ZEND_ARG_INFO(1, opendata)
-    ZEND_ARG_INFO(0, ekey)
-    ZEND_ARG_INFO(0, privkey)
+	ZEND_ARG_INFO(0, data)
+	ZEND_ARG_INFO(1, opendata)
+	ZEND_ARG_INFO(0, ekey)
+	ZEND_ARG_INFO(0, privkey)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_get_md_methods, 0, 0, 0)
-    ZEND_ARG_INFO(0, aliases)
+	ZEND_ARG_INFO(0, aliases)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_get_cipher_methods, 0, 0, 0)
-    ZEND_ARG_INFO(0, aliases)
+	ZEND_ARG_INFO(0, aliases)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_digest, 0, 0, 2)
-    ZEND_ARG_INFO(0, data)
-    ZEND_ARG_INFO(0, method)
-    ZEND_ARG_INFO(0, raw_output)
+	ZEND_ARG_INFO(0, data)
+	ZEND_ARG_INFO(0, method)
+	ZEND_ARG_INFO(0, raw_output)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_encrypt, 0, 0, 3)
-    ZEND_ARG_INFO(0, data)
-    ZEND_ARG_INFO(0, method)
-    ZEND_ARG_INFO(0, password)
-    ZEND_ARG_INFO(0, raw_output)
-    ZEND_ARG_INFO(0, iv)
+	ZEND_ARG_INFO(0, data)
+	ZEND_ARG_INFO(0, method)
+	ZEND_ARG_INFO(0, password)
+	ZEND_ARG_INFO(0, options)
+	ZEND_ARG_INFO(0, iv)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_decrypt, 0, 0, 3)
-    ZEND_ARG_INFO(0, data)
-    ZEND_ARG_INFO(0, method)
-    ZEND_ARG_INFO(0, password)
-    ZEND_ARG_INFO(0, raw_input)
-    ZEND_ARG_INFO(0, iv)
+	ZEND_ARG_INFO(0, data)
+	ZEND_ARG_INFO(0, method)
+	ZEND_ARG_INFO(0, password)
+	ZEND_ARG_INFO(0, options)
+	ZEND_ARG_INFO(0, iv)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO(arginfo_openssl_cipher_iv_length, 0)
-    ZEND_ARG_INFO(0, method)
+	ZEND_ARG_INFO(0, method)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO(arginfo_openssl_dh_compute_key, 0)
-    ZEND_ARG_INFO(0, pub_key)
-    ZEND_ARG_INFO(0, dh_key)
+	ZEND_ARG_INFO(0, pub_key)
+	ZEND_ARG_INFO(0, dh_key)
 ZEND_END_ARG_INFO()
 
 ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_random_pseudo_bytes, 0, 0, 1)
-    ZEND_ARG_INFO(0, length)
-    ZEND_ARG_INFO(1, result_is_strong)
+	ZEND_ARG_INFO(0, length)
+	ZEND_ARG_INFO(1, result_is_strong)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO_EX(arginfo_openssl_spki_new, 0, 0, 2)
+	ZEND_ARG_INFO(0, privkey)
+	ZEND_ARG_INFO(0, challenge)
+	ZEND_ARG_INFO(0, algo)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO(arginfo_openssl_spki_verify, 0)
+	ZEND_ARG_INFO(0, spki)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO(arginfo_openssl_spki_export, 0)
+	ZEND_ARG_INFO(0, spki)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO(arginfo_openssl_spki_export_challenge, 0)
+	ZEND_ARG_INFO(0, spki)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO(arginfo_openssl_get_cert_locations, 0)
 ZEND_END_ARG_INFO()
 /* }}} */
 
 /* {{{ openssl_functions[]
  */
 const zend_function_entry openssl_functions[] = {
+	PHP_FE(openssl_get_cert_locations, arginfo_openssl_get_cert_locations)
+
+/* spki functions */
+	PHP_FE(openssl_spki_new, arginfo_openssl_spki_new)
+	PHP_FE(openssl_spki_verify, arginfo_openssl_spki_verify)
+	PHP_FE(openssl_spki_export, arginfo_openssl_spki_export)
+	PHP_FE(openssl_spki_export_challenge, arginfo_openssl_spki_export_challenge)
+
 /* public/private key functions */
 	PHP_FE(openssl_pkey_free,			arginfo_openssl_pkey_free)
 	PHP_FE(openssl_pkey_new,			arginfo_openssl_pkey_new)
@@ -397,6 +466,7 @@
 	PHP_FE(openssl_x509_checkpurpose,		arginfo_openssl_x509_checkpurpose)
 	PHP_FE(openssl_x509_check_private_key,	arginfo_openssl_x509_check_private_key)
 	PHP_FE(openssl_x509_export,				arginfo_openssl_x509_export)
+	PHP_FE(openssl_x509_fingerprint,			arginfo_openssl_x509_fingerprint)
 	PHP_FE(openssl_x509_export_to_file,		arginfo_openssl_x509_export_to_file)
 
 /* PKCS12 funcs */
@@ -421,6 +491,10 @@
 	PHP_FE(openssl_seal,				arginfo_openssl_seal)
 	PHP_FE(openssl_open,				arginfo_openssl_open)
 
+#if OPENSSL_VERSION_NUMBER >= 0x10000000L
+	PHP_FE(openssl_pbkdf2,	arginfo_openssl_pbkdf2)
+#endif
+
 /* for S/MIME handling */
 	PHP_FE(openssl_pkcs7_verify,		arginfo_openssl_pkcs7_verify)
 	PHP_FE(openssl_pkcs7_decrypt,		arginfo_openssl_pkcs7_decrypt)
@@ -463,6 +537,133 @@
 ZEND_GET_MODULE(openssl)
 #endif
 
+/* {{{ OpenSSL compatibility functions and macros */
+#if OPENSSL_VERSION_NUMBER < 0x10100000L || defined (LIBRESSL_VERSION_NUMBER)
+#define EVP_PKEY_get0_RSA(_pkey) _pkey->pkey.rsa
+#define EVP_PKEY_get0_DH(_pkey) _pkey->pkey.dh
+#define EVP_PKEY_get0_DSA(_pkey) _pkey->pkey.dsa
+#define EVP_PKEY_get0_EC_KEY(_pkey) _pkey->pkey.ec
+
+static int RSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d)
+{
+	r->n = n;
+	r->e = e;
+	r->d = d;
+
+	return 1;
+}
+
+static int RSA_set0_factors(RSA *r, BIGNUM *p, BIGNUM *q)
+{
+	r->p = p;
+	r->q = q;
+
+	return 1;
+}
+
+static int RSA_set0_crt_params(RSA *r, BIGNUM *dmp1, BIGNUM *dmq1, BIGNUM *iqmp)
+{
+	r->dmp1 = dmp1;
+	r->dmq1 = dmq1;
+	r->iqmp = iqmp;
+
+	return 1;
+}
+
+static void RSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)
+{
+	*n = r->n;
+	*e = r->e;
+	*d = r->d;
+}
+
+static void RSA_get0_factors(const RSA *r, const BIGNUM **p, const BIGNUM **q)
+{
+	*p = r->p;
+	*q = r->q;
+}
+
+static void RSA_get0_crt_params(const RSA *r, const BIGNUM **dmp1, const BIGNUM **dmq1, const BIGNUM **iqmp)
+{
+	*dmp1 = r->dmp1;
+	*dmq1 = r->dmq1;
+	*iqmp = r->iqmp;
+}
+
+static void DH_get0_pqg(const DH *dh, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)
+{
+	*p = dh->p;
+	*q = dh->q;
+	*g = dh->g;
+}
+
+static int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g)
+{
+	dh->p = p;
+	dh->q = q;
+	dh->g = g;
+
+	return 1;
+}
+
+static void DH_get0_key(const DH *dh, const BIGNUM **pub_key, const BIGNUM **priv_key)
+{
+	*pub_key = dh->pub_key;
+	*priv_key = dh->priv_key;
+}
+
+static int DH_set0_key(DH *dh, BIGNUM *pub_key, BIGNUM *priv_key)
+{
+	dh->pub_key = pub_key;
+	dh->priv_key = priv_key;
+
+	return 1;
+}
+
+static void DSA_get0_pqg(const DSA *d, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)
+{
+	*p = d->p;
+	*q = d->q;
+	*g = d->g;
+}
+
+int DSA_set0_pqg(DSA *d, BIGNUM *p, BIGNUM *q, BIGNUM *g)
+{
+	d->p = p;
+	d->q = q;
+	d->g = g;
+
+	return 1;
+}
+
+static void DSA_get0_key(const DSA *d, const BIGNUM **pub_key, const BIGNUM **priv_key)
+{
+	*pub_key = d->pub_key;
+	*priv_key = d->priv_key;
+}
+
+int DSA_set0_key(DSA *d, BIGNUM *pub_key, BIGNUM *priv_key)
+{
+	d->pub_key = pub_key;
+	d->priv_key = priv_key;
+
+	return 1;
+}
+
+#if OPENSSL_VERSION_NUMBER < 0x10002000L || defined (LIBRESSL_VERSION_NUMBER)
+#define EVP_PKEY_id(_pkey) _pkey->type
+#define EVP_PKEY_base_id(_key) EVP_PKEY_type(_key->type)
+
+static int X509_get_signature_nid(const X509 *x)
+{
+	return OBJ_obj2nid(x->sig_alg->algorithm);
+}
+
+#endif
+
+#endif
+/* }}} */
+
 static int le_key;
 static int le_x509;
 static int le_csr;
@@ -497,12 +698,9 @@
 }
 /* }}} */
 
-/* {{{ openssl safe_mode & open_basedir checks */
-inline static int php_openssl_safe_mode_chk(char *filename TSRMLS_DC)
+/* {{{ openssl open_basedir check */
+inline static int php_openssl_open_base_dir_chk(char *filename TSRMLS_DC)
 {
-	if (PG(safe_mode) && (!php_checkuid(filename, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {
-		return -1;
-	}
 	if (php_check_open_basedir(filename TSRMLS_CC)) {
 		return -1;
 	}
@@ -511,6 +709,16 @@
 }
 /* }}} */
 
+php_stream* php_openssl_get_stream_from_ssl_handle(const SSL *ssl)
+{
+	return (php_stream*)SSL_get_ex_data(ssl, ssl_stream_data_index);
+}
+
+int php_openssl_get_ssl_stream_data_index()
+{
+	return ssl_stream_data_index;
+}
+
 /* openssl -> PHP "bridging" */
 /* true global; readonly after module startup */
 static char default_ssl_conf_filename[MAXPATHLEN];
@@ -536,21 +744,24 @@
 	int priv_key_encrypt;
 
 	EVP_PKEY * priv_key;
+
+    const EVP_CIPHER * priv_key_encrypt_cipher;
 };
 /* }}} */
 
 static X509 * php_openssl_x509_from_zval(zval ** val, int makeresource, long * resourceval TSRMLS_DC);
 static EVP_PKEY * php_openssl_evp_from_zval(zval ** val, int public_key, char * passphrase, int makeresource, long * resourceval TSRMLS_DC);
 static int php_openssl_is_private_key(EVP_PKEY* pkey TSRMLS_DC);
-static X509_STORE     * setup_verify(zval * calist TSRMLS_DC);
+static X509_STORE * setup_verify(zval * calist TSRMLS_DC);
 static STACK_OF(X509) * load_all_certs_from_file(char *certfile);
 static X509_REQ * php_openssl_csr_from_zval(zval ** val, int makeresource, long * resourceval TSRMLS_DC);
 static EVP_PKEY * php_openssl_generate_private_key(struct php_x509_request * req TSRMLS_DC);
 
 static void add_assoc_name_entry(zval * val, char * key, X509_NAME * name, int shortname TSRMLS_DC) /* {{{ */
 {
+	zval **data;
 	zval *subitem, *subentries;
-	int i, j = -1, last = -1, obj_cnt = 0;
+	int i;
 	char *sname;
 	int nid;
 	X509_NAME_ENTRY * ne;
@@ -566,13 +777,12 @@
 	
 	for (i = 0; i < X509_NAME_entry_count(name); i++) {
 		unsigned char *to_add;
-		int to_add_len;
+		int to_add_len = 0;
 
 
 		ne  = X509_NAME_get_entry(name, i);
 		obj = X509_NAME_ENTRY_get_object(ne);
 		nid = OBJ_obj2nid(obj);
-		obj_cnt = 0;
 
 		if (shortname) {
 			sname = (char *) OBJ_nid2sn(nid);
@@ -580,39 +790,27 @@
 			sname = (char *) OBJ_nid2ln(nid);
 		}
 
-		MAKE_STD_ZVAL(subentries);
-		array_init(subentries);
+		str = X509_NAME_ENTRY_get_data(ne);
+		if (ASN1_STRING_type(str) != V_ASN1_UTF8STRING) {
+			to_add_len = ASN1_STRING_to_UTF8(&to_add, str);
+		} else {
+			to_add = ASN1_STRING_data(str);
+			to_add_len = ASN1_STRING_length(str);
+		}
 
-		last = -1;
-		for (;;) {
-			j = X509_NAME_get_index_by_OBJ(name, obj, last);
-			if (j < 0) {
-				if (last != -1) break;
-			} else {
-				obj_cnt++;
-				ne  = X509_NAME_get_entry(name, j);
-				str = X509_NAME_ENTRY_get_data(ne);
-				if (ASN1_STRING_type(str) != V_ASN1_UTF8STRING) {
-					to_add_len = ASN1_STRING_to_UTF8(&to_add, str);
-					if (to_add_len != -1) {
-						add_next_index_stringl(subentries, (char *)to_add, to_add_len, 1);
-					}
-				} else {
-					to_add = ASN1_STRING_data(str);
-					to_add_len = ASN1_STRING_length(str);
+		if (to_add_len != -1) {
+			if (zend_hash_find(Z_ARRVAL_P(subitem), sname, strlen(sname)+1, (void**)&data) == SUCCESS) {
+				if (Z_TYPE_PP(data) == IS_ARRAY) {
+					subentries = *data;
+					add_next_index_stringl(subentries, (char *)to_add, to_add_len, 1);
+				} else if (Z_TYPE_PP(data) == IS_STRING) {
+					MAKE_STD_ZVAL(subentries);
+					array_init(subentries);
+					add_next_index_stringl(subentries, Z_STRVAL_PP(data), Z_STRLEN_PP(data), 1);
 					add_next_index_stringl(subentries, (char *)to_add, to_add_len, 1);
+					zend_hash_update(Z_ARRVAL_P(subitem), sname, strlen(sname)+1, &subentries, sizeof(zval*), NULL);
 				}
-			}
-			last = j;
-		}
-		i = last;
-		
-		if (obj_cnt > 1) {
-			add_assoc_zval_ex(subitem, sname, strlen(sname) + 1, subentries);
-		} else {
-			zval_dtor(subentries);
-			FREE_ZVAL(subentries);
-			if (obj_cnt && str && to_add_len > -1) {
+			} else {
 				add_assoc_stringl(subitem, sname, (char *)to_add, to_add_len, 1);
 			}
 		}
@@ -644,12 +842,12 @@
 	char * thestr;
 	long gmadjust = 0;
 
-	if (ASN1_STRING_type(timestr) != V_ASN1_UTCTIME) {
+	if (ASN1_STRING_type(timestr) != V_ASN1_UTCTIME && ASN1_STRING_type(timestr) != V_ASN1_GENERALIZEDTIME) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "illegal ASN1 data type for timestamp");
 		return (time_t)-1;
 	}
 
-	if (ASN1_STRING_length(timestr) != strlen((char*)ASN1_STRING_data(timestr))) {
+	if (ASN1_STRING_length(timestr) != strlen((const char*)ASN1_STRING_data(timestr))) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "illegal length in timestamp");
 		return (time_t)-1;
 	}
@@ -659,6 +857,11 @@
 		return (time_t)-1;
 	}
 
+	if (ASN1_STRING_type(timestr) == V_ASN1_GENERALIZEDTIME && ASN1_STRING_length(timestr) < 15) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "unable to parse time string %s correctly", timestr->data);
+		return (time_t)-1;
+	}
+
 	strbuf = estrdup((char *)ASN1_STRING_data(timestr));
 
 	memset(&thetime, 0, sizeof(thetime));
@@ -680,14 +883,21 @@
 	*thestr = '\0';
 	thestr -= 2;
 	thetime.tm_mon = atoi(thestr)-1;
-	*thestr = '\0';
-	thestr -= 2;
-	thetime.tm_year = atoi(thestr);
 
-	if (thetime.tm_year < 68) {
-		thetime.tm_year += 100;
+	*thestr = '\0';
+	if( ASN1_STRING_type(timestr) == V_ASN1_UTCTIME ) {
+		thestr -= 2;
+		thetime.tm_year = atoi(thestr);
+
+		if (thetime.tm_year < 68) {
+			thetime.tm_year += 100;
+		}
+	} else if( ASN1_STRING_type(timestr) == V_ASN1_GENERALIZEDTIME ) {
+		thestr -= 4;
+		thetime.tm_year = atoi(thestr) - 1900;
 	}
 
+
 	thetime.tm_isdst = -1;
 	ret = mktime(&thetime);
 
@@ -748,7 +958,7 @@
 	}
 	for (i = 0; i < sk_CONF_VALUE_num(sktmp); i++) {
 		cnf = sk_CONF_VALUE_value(sktmp, i);
-		if (OBJ_create(cnf->value, cnf->name, cnf->name) == NID_undef) {
+		if (OBJ_sn2nid(cnf->name) == NID_undef && OBJ_ln2nid(cnf->name) == NID_undef && OBJ_create(cnf->value, cnf->name, cnf->name) == NID_undef) {
 			php_error_docref(NULL TSRMLS_CC, E_WARNING, "problem creating object %s=%s", cnf->name, cnf->value);
 			return FAILURE;
 		}
@@ -776,6 +986,10 @@
 	else \
 		varname = defval
 
+static const EVP_CIPHER * php_openssl_get_evp_cipher_from_algo(long algo);
+
+int openssl_spki_cleanup(const char *src, char *dest);
+
 static int php_openssl_parse_config(struct php_x509_request * req, zval * optional_args TSRMLS_DC) /* {{{ */
 {
 	char * str;
@@ -792,7 +1006,7 @@
 
 	/* read in the oids */
 	str = CONF_get_string(req->req_config, NULL, "oid_file");
-	if (str && !php_openssl_safe_mode_chk(str TSRMLS_CC)) {
+	if (str && !php_openssl_open_base_dir_chk(str TSRMLS_CC)) {
 		BIO *oid_bio = BIO_new_file(str, "r");
 		if (oid_bio) {
 			OBJ_create_objects(oid_bio);
@@ -813,7 +1027,7 @@
 
 	SET_OPTIONAL_LONG_ARG("private_key_type", req->priv_key_type, OPENSSL_KEYTYPE_DEFAULT);
 
-	if (optional_args && zend_hash_find(Z_ARRVAL_P(optional_args), "encrypt_key", sizeof("encrypt_key"), (void**)&item) == SUCCESS && Z_TYPE_PP(item) == IS_BOOL) {
+	if (optional_args && zend_hash_find(Z_ARRVAL_P(optional_args), "encrypt_key", sizeof("encrypt_key"), (void**)&item) == SUCCESS) {
 		req->priv_key_encrypt = Z_BVAL_PP(item);
 	} else {
 		str = CONF_get_string(req->req_config, req->section_name, "encrypt_rsa_key");
@@ -826,6 +1040,22 @@
 			req->priv_key_encrypt = 1;
 		}
 	}
+
+	if (req->priv_key_encrypt && optional_args && zend_hash_find(Z_ARRVAL_P(optional_args), "encrypt_key_cipher", sizeof("encrypt_key_cipher"), (void**)&item) == SUCCESS 
+		&& Z_TYPE_PP(item) == IS_LONG) {
+		long cipher_algo = Z_LVAL_PP(item);
+		const EVP_CIPHER* cipher = php_openssl_get_evp_cipher_from_algo(cipher_algo);
+		if (cipher == NULL) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unknown cipher algorithm for private key.");
+			return FAILURE;
+		} else  {
+			req->priv_key_encrypt_cipher = cipher;
+		}
+	} else {
+		req->priv_key_encrypt_cipher = NULL;
+	}
+
+
 	
 	/* digest alg */
 	if (req->digest_name == NULL) {
@@ -835,7 +1065,7 @@
 		req->digest = req->md_alg = EVP_get_digestbyname(req->digest_name);
 	}
 	if (req->md_alg == NULL) {
-		req->md_alg = req->digest = EVP_md5();
+		req->md_alg = req->digest = EVP_sha1();
 	}
 
 	PHP_SSL_CONFIG_SYNTAX_CHECK(extensions_section);
@@ -870,22 +1100,38 @@
 }
 /* }}} */
 
-static int php_openssl_load_rand_file(const char * file, int *egdsocket, int *seeded) /* {{{ */
+#if defined(PHP_WIN32) || (OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER))
+#define PHP_OPENSSL_RAND_ADD_TIME() ((void) 0)
+#else
+#define PHP_OPENSSL_RAND_ADD_TIME() php_openssl_rand_add_timeval()
+
+static inline void php_openssl_rand_add_timeval()  /* {{{ */
 {
-	char buffer[MAXPATHLEN];
+	struct timeval tv;
 
-	TSRMLS_FETCH();
+	gettimeofday(&tv, NULL);
+	RAND_add(&tv, sizeof(tv), 0.0);
+}
+/* }}} */
+
+#endif
+
+static int php_openssl_load_rand_file(const char * file, int *egdsocket, int *seeded TSRMLS_DC) /* {{{ */
+{
+	char buffer[MAXPATHLEN];
 
 	*egdsocket = 0;
 	*seeded = 0;
 
 	if (file == NULL) {
 		file = RAND_file_name(buffer, sizeof(buffer));
+#ifdef HAVE_RAND_EGD
 	} else if (RAND_egd(file) > 0) {
 		/* if the given filename is an EGD socket, don't
 		 * write anything back to it */
 		*egdsocket = 1;
 		return SUCCESS;
+#endif
 	}
 	if (file == NULL || !RAND_load_file(file, -1)) {
 		if (RAND_status() == 0) {
@@ -913,6 +1159,7 @@
 	if (file == NULL) {
 		file = RAND_file_name(buffer, sizeof(buffer));
 	}
+	PHP_OPENSSL_RAND_ADD_TIME();
 	if (file == NULL || !RAND_write_file(file)) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "unable to write random state");
 		return FAILURE;
@@ -939,9 +1186,28 @@
 			mdtype = (EVP_MD *) EVP_md2();
 			break;
 #endif
+#if OPENSSL_VERSION_NUMBER < 0x10100000L || defined (LIBRESSL_VERSION_NUMBER)
 		case OPENSSL_ALGO_DSS1:
 			mdtype = (EVP_MD *) EVP_dss1();
 			break;
+#endif
+#if OPENSSL_VERSION_NUMBER >= 0x0090708fL
+		case OPENSSL_ALGO_SHA224:
+			mdtype = (EVP_MD *) EVP_sha224();
+			break;
+		case OPENSSL_ALGO_SHA256:
+			mdtype = (EVP_MD *) EVP_sha256();
+			break;
+		case OPENSSL_ALGO_SHA384:
+			mdtype = (EVP_MD *) EVP_sha384();
+			break;
+		case OPENSSL_ALGO_SHA512:
+			mdtype = (EVP_MD *) EVP_sha512();
+			break;
+		case OPENSSL_ALGO_RMD160:
+			mdtype = (EVP_MD *) EVP_ripemd160();
+			break;
+#endif
 		default:
 			return NULL;
 			break;
@@ -972,6 +1238,20 @@
 			return EVP_des_ede3_cbc();
 			break;
 #endif
+
+#ifndef OPENSSL_NO_AES
+		case PHP_OPENSSL_CIPHER_AES_128_CBC:
+			return EVP_aes_128_cbc();
+			break;
+		case PHP_OPENSSL_CIPHER_AES_192_CBC:
+			return EVP_aes_192_cbc();
+			break;
+		case PHP_OPENSSL_CIPHER_AES_256_CBC:
+			return EVP_aes_256_cbc();
+			break;
+#endif
+
+
 		default:
 			return NULL;
 			break;
@@ -979,6 +1259,13 @@
 }
 /* }}} */
 
+/* {{{ INI Settings */
+PHP_INI_BEGIN()
+	PHP_INI_ENTRY("openssl.cafile", NULL, PHP_INI_PERDIR, NULL)
+	PHP_INI_ENTRY("openssl.capath", NULL, PHP_INI_PERDIR, NULL)
+PHP_INI_END()
+/* }}} */
+ 
 /* {{{ PHP_MINIT_FUNCTION
  */
 PHP_MINIT_FUNCTION(openssl)
@@ -994,9 +1281,13 @@
 	OpenSSL_add_all_digests();
 	OpenSSL_add_all_algorithms();
 
-	ERR_load_ERR_strings();
-	ERR_load_crypto_strings();
-	ERR_load_EVP_strings();
+#if !defined(OPENSSL_NO_AES) && defined(EVP_CIPH_CCM_MODE) && OPENSSL_VERSION_NUMBER < 0x100020000
+	EVP_add_cipher(EVP_aes_128_ccm());
+	EVP_add_cipher(EVP_aes_192_ccm());
+	EVP_add_cipher(EVP_aes_256_ccm());
+#endif
+
+	SSL_load_error_strings();
 
 	/* register a resource id number with OpenSSL so that we can map SSL -> stream structures in
 	 * OpenSSL callbacks */
@@ -1023,7 +1314,16 @@
 #ifdef HAVE_OPENSSL_MD2_H
 	REGISTER_LONG_CONSTANT("OPENSSL_ALGO_MD2", OPENSSL_ALGO_MD2, CONST_CS|CONST_PERSISTENT);
 #endif
+#if OPENSSL_VERSION_NUMBER < 0x10100000L || defined (LIBRESSL_VERSION_NUMBER)
 	REGISTER_LONG_CONSTANT("OPENSSL_ALGO_DSS1", OPENSSL_ALGO_DSS1, CONST_CS|CONST_PERSISTENT);
+#endif
+#if OPENSSL_VERSION_NUMBER >= 0x0090708fL
+	REGISTER_LONG_CONSTANT("OPENSSL_ALGO_SHA224", OPENSSL_ALGO_SHA224, CONST_CS|CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("OPENSSL_ALGO_SHA256", OPENSSL_ALGO_SHA256, CONST_CS|CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("OPENSSL_ALGO_SHA384", OPENSSL_ALGO_SHA384, CONST_CS|CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("OPENSSL_ALGO_SHA512", OPENSSL_ALGO_SHA512, CONST_CS|CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("OPENSSL_ALGO_RMD160", OPENSSL_ALGO_RMD160, CONST_CS|CONST_PERSISTENT);
+#endif
 
 	/* flags for S/MIME */
 	REGISTER_LONG_CONSTANT("PKCS7_DETACHED", PKCS7_DETACHED, CONST_CS|CONST_PERSISTENT);
@@ -1041,6 +1341,9 @@
 	REGISTER_LONG_CONSTANT("OPENSSL_NO_PADDING", RSA_NO_PADDING, CONST_CS|CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("OPENSSL_PKCS1_OAEP_PADDING", RSA_PKCS1_OAEP_PADDING, CONST_CS|CONST_PERSISTENT);
 
+	/* Informational stream wrapper constants */
+	REGISTER_STRING_CONSTANT("OPENSSL_DEFAULT_STREAM_CIPHERS", OPENSSL_DEFAULT_STREAM_CIPHERS, CONST_CS|CONST_PERSISTENT);
+
 	/* Ciphers */
 #ifndef OPENSSL_NO_RC2
 	REGISTER_LONG_CONSTANT("OPENSSL_CIPHER_RC2_40", PHP_OPENSSL_CIPHER_RC2_40, CONST_CS|CONST_PERSISTENT);
@@ -1051,17 +1354,25 @@
 	REGISTER_LONG_CONSTANT("OPENSSL_CIPHER_DES", PHP_OPENSSL_CIPHER_DES, CONST_CS|CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("OPENSSL_CIPHER_3DES", PHP_OPENSSL_CIPHER_3DES, CONST_CS|CONST_PERSISTENT);
 #endif
-
+#ifndef OPENSSL_NO_AES
+	REGISTER_LONG_CONSTANT("OPENSSL_CIPHER_AES_128_CBC", PHP_OPENSSL_CIPHER_AES_128_CBC, CONST_CS|CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("OPENSSL_CIPHER_AES_192_CBC", PHP_OPENSSL_CIPHER_AES_192_CBC, CONST_CS|CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("OPENSSL_CIPHER_AES_256_CBC", PHP_OPENSSL_CIPHER_AES_256_CBC, CONST_CS|CONST_PERSISTENT);
+#endif
+ 
 	/* Values for key types */
 	REGISTER_LONG_CONSTANT("OPENSSL_KEYTYPE_RSA", OPENSSL_KEYTYPE_RSA, CONST_CS|CONST_PERSISTENT);
 #ifndef NO_DSA
 	REGISTER_LONG_CONSTANT("OPENSSL_KEYTYPE_DSA", OPENSSL_KEYTYPE_DSA, CONST_CS|CONST_PERSISTENT);
 #endif
 	REGISTER_LONG_CONSTANT("OPENSSL_KEYTYPE_DH", OPENSSL_KEYTYPE_DH, CONST_CS|CONST_PERSISTENT);
-#ifdef EVP_PKEY_EC
+#ifdef HAVE_EVP_PKEY_EC
 	REGISTER_LONG_CONSTANT("OPENSSL_KEYTYPE_EC", OPENSSL_KEYTYPE_EC, CONST_CS|CONST_PERSISTENT);
 #endif
 
+	REGISTER_LONG_CONSTANT("OPENSSL_RAW_DATA", OPENSSL_RAW_DATA, CONST_CS|CONST_PERSISTENT);
+	REGISTER_LONG_CONSTANT("OPENSSL_ZERO_PADDING", OPENSSL_ZERO_PADDING, CONST_CS|CONST_PERSISTENT);
+
 #if OPENSSL_VERSION_NUMBER >= 0x0090806fL && !defined(OPENSSL_NO_TLSEXT)
 	/* SNI support included in OpenSSL >= 0.9.8j */
 	REGISTER_LONG_CONSTANT("OPENSSL_TLSEXT_SERVER_NAME", 1, CONST_CS|CONST_PERSISTENT);
@@ -1083,18 +1394,27 @@
 	}
 
 	php_stream_xport_register("ssl", php_openssl_ssl_socket_factory TSRMLS_CC);
+#ifndef OPENSSL_NO_SSL3
 	php_stream_xport_register("sslv3", php_openssl_ssl_socket_factory TSRMLS_CC);
+#endif
 #ifndef OPENSSL_NO_SSL2
 	php_stream_xport_register("sslv2", php_openssl_ssl_socket_factory TSRMLS_CC);
 #endif
 	php_stream_xport_register("tls", php_openssl_ssl_socket_factory TSRMLS_CC);
+	php_stream_xport_register("tlsv1.0", php_openssl_ssl_socket_factory TSRMLS_CC);
+#if OPENSSL_VERSION_NUMBER >= 0x10001001L
+	php_stream_xport_register("tlsv1.1", php_openssl_ssl_socket_factory TSRMLS_CC);
+	php_stream_xport_register("tlsv1.2", php_openssl_ssl_socket_factory TSRMLS_CC);
+#endif
 
 	/* override the default tcp socket provider */
 	php_stream_xport_register("tcp", php_openssl_ssl_socket_factory TSRMLS_CC);
 
 	php_register_url_stream_wrapper("https", &php_stream_http_wrapper TSRMLS_CC);
 	php_register_url_stream_wrapper("ftps", &php_stream_ftp_wrapper TSRMLS_CC);
-	
+
+	REGISTER_INI_ENTRIES();
+
 	return SUCCESS;
 }
 /* }}} */
@@ -1107,7 +1427,9 @@
 	php_info_print_table_row(2, "OpenSSL support", "enabled");
 	php_info_print_table_row(2, "OpenSSL Library Version", SSLeay_version(SSLEAY_VERSION));
 	php_info_print_table_row(2, "OpenSSL Header Version", OPENSSL_VERSION_TEXT);
+	php_info_print_table_row(2, "Openssl default config", default_ssl_conf_filename);
 	php_info_print_table_end();
+	DISPLAY_INI_ENTRIES();
 }
 /* }}} */
 
@@ -1117,6 +1439,13 @@
 {
 	EVP_cleanup();
 
+#if OPENSSL_VERSION_NUMBER >= 0x00090805f
+	/* prevent accessing locking callback from unloaded extension */
+	CRYPTO_set_locking_callback(NULL);
+	/* free allocated error strings */
+	ERR_free_strings();
+#endif
+
 	php_unregister_url_stream_wrapper("https" TSRMLS_CC);
 	php_unregister_url_stream_wrapper("ftps" TSRMLS_CC);
 
@@ -1124,18 +1453,47 @@
 #ifndef OPENSSL_NO_SSL2
 	php_stream_xport_unregister("sslv2" TSRMLS_CC);
 #endif
+#ifndef OPENSSL_NO_SSL3
 	php_stream_xport_unregister("sslv3" TSRMLS_CC);
+#endif
 	php_stream_xport_unregister("tls" TSRMLS_CC);
+	php_stream_xport_unregister("tlsv1.0" TSRMLS_CC);
+#if OPENSSL_VERSION_NUMBER >= 0x10001001L
+	php_stream_xport_unregister("tlsv1.1" TSRMLS_CC);
+	php_stream_xport_unregister("tlsv1.2" TSRMLS_CC);
+#endif
 
 	/* reinstate the default tcp handler */
 	php_stream_xport_register("tcp", php_stream_generic_socket_factory TSRMLS_CC);
 
+	UNREGISTER_INI_ENTRIES();
+
 	return SUCCESS;
 }
 /* }}} */
 
 /* {{{ x509 cert functions */
 
+/* {{{ proto array openssl_get_cert_locations(void)
+   Retrieve an array mapping available certificate locations */
+PHP_FUNCTION(openssl_get_cert_locations)
+{
+	array_init(return_value);
+
+	add_assoc_string(return_value, "default_cert_file", (char *) X509_get_default_cert_file(), 1);
+	add_assoc_string(return_value, "default_cert_file_env", (char *) X509_get_default_cert_file_env(), 1);
+	add_assoc_string(return_value, "default_cert_dir", (char *) X509_get_default_cert_dir(), 1);
+	add_assoc_string(return_value, "default_cert_dir_env", (char *) X509_get_default_cert_dir_env(), 1);
+	add_assoc_string(return_value, "default_private_dir", (char *) X509_get_default_private_dir(), 1);
+	add_assoc_string(return_value, "default_default_cert_area", (char *) X509_get_default_cert_area(), 1);
+	add_assoc_string(return_value, "ini_cafile",
+		zend_ini_string("openssl.cafile", sizeof("openssl.cafile"), 0), 1);
+	add_assoc_string(return_value, "ini_capath",
+		zend_ini_string("openssl.capath", sizeof("openssl.capath"), 0), 1);
+}
+/* }}} */
+
+
 /* {{{ php_openssl_x509_from_zval
 	Given a zval, coerce it into an X509 object.
 	The zval can be:
@@ -1184,7 +1542,7 @@
 		/* read cert from the named file */
 		BIO *in;
 
-		if (php_openssl_safe_mode_chk(Z_STRVAL_PP(val) + (sizeof("file://") - 1) TSRMLS_CC)) {
+		if (php_openssl_open_base_dir_chk(Z_STRVAL_PP(val) + (sizeof("file://") - 1) TSRMLS_CC)) {
 			return NULL;
 		}
 
@@ -1210,7 +1568,7 @@
 	}
 
 	if (cert && makeresource && resourceval) {
-		*resourceval = zend_list_insert(cert, le_x509);
+		*resourceval = zend_list_insert(cert, le_x509 TSRMLS_CC);
 	}
 	return cert;
 }
@@ -1229,7 +1587,7 @@
 	char * filename;
 	int filename_len;
 
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "Zs|b", &zcert, &filename, &filename_len, &notext) == FAILURE) {
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "Zp|b", &zcert, &filename, &filename_len, &notext) == FAILURE) {
 		return;
 	}
 	RETVAL_FALSE;
@@ -1240,7 +1598,7 @@
 		return;
 	}
 
-	if (php_openssl_safe_mode_chk(filename TSRMLS_CC)) {
+	if (php_openssl_open_base_dir_chk(filename TSRMLS_CC)) {
 		return;
 	}
 
@@ -1262,6 +1620,284 @@
 }
 /* }}} */
 
+/* {{{ proto string openssl_spki_new(mixed zpkey, string challenge [, mixed method])
+   Creates new private key (or uses existing) and creates a new spki cert
+   outputting results to var */
+PHP_FUNCTION(openssl_spki_new)
+{
+	int challenge_len;
+	char * challenge = NULL, * spkstr = NULL, * s = NULL;
+	long keyresource = -1;
+	const char *spkac = "SPKAC=";
+	long algo = OPENSSL_ALGO_MD5;
+
+	zval *method = NULL;
+	zval * zpkey = NULL;
+	EVP_PKEY * pkey = NULL;
+	NETSCAPE_SPKI *spki=NULL;
+	const EVP_MD *mdtype;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rs|z", &zpkey, &challenge, &challenge_len, &method) == FAILURE) {
+		return;
+	}
+	RETVAL_FALSE;
+
+	pkey = php_openssl_evp_from_zval(&zpkey, 0, challenge, 1, &keyresource TSRMLS_CC);
+
+	if (pkey == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to use supplied private key");
+		goto cleanup;
+	}
+
+	if (method != NULL) {
+		if (Z_TYPE_P(method) == IS_LONG) {
+			algo = Z_LVAL_P(method);
+		} else {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Algorithm must be of supported type");
+			goto cleanup;
+		}
+	}
+	mdtype = php_openssl_get_evp_md_from_algo(algo);
+
+	if (!mdtype) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unknown signature algorithm");
+		goto cleanup;
+	}
+
+	if ((spki = NETSCAPE_SPKI_new()) == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to create new SPKAC");
+		goto cleanup;
+	}
+
+	if (challenge) {
+		ASN1_STRING_set(spki->spkac->challenge, challenge, challenge_len);
+	}
+
+	if (!NETSCAPE_SPKI_set_pubkey(spki, pkey)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to embed public key");
+		goto cleanup;
+	}
+
+	if (!NETSCAPE_SPKI_sign(spki, pkey, mdtype)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to sign with specified algorithm");
+		goto cleanup;
+	}
+
+	spkstr = NETSCAPE_SPKI_b64_encode(spki);
+	if (!spkstr){
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to encode SPKAC");
+		goto cleanup;
+	}
+
+	s = emalloc(strlen(spkac) + strlen(spkstr) + 1);
+	sprintf(s, "%s%s", spkac, spkstr);
+
+	RETVAL_STRINGL(s, strlen(s), 0);
+	goto cleanup;
+
+cleanup:
+
+	if (keyresource == -1 && spki != NULL) {
+		NETSCAPE_SPKI_free(spki);
+	}
+	if (keyresource == -1 && pkey != NULL) {
+		EVP_PKEY_free(pkey);
+	}
+	if (keyresource == -1 && spkstr != NULL) {
+		efree(spkstr);
+	}
+
+	if (s && strlen(s) <= 0) {
+		RETVAL_FALSE;
+	}
+
+	if (keyresource == -1 && s != NULL) {
+		efree(s);
+	}
+}
+/* }}} */
+
+/* {{{ proto bool openssl_spki_verify(string spki)
+   Verifies spki returns boolean */
+PHP_FUNCTION(openssl_spki_verify)
+{
+	int spkstr_len, i = 0;
+	char *spkstr = NULL, * spkstr_cleaned = NULL;
+
+	EVP_PKEY *pkey = NULL;
+	NETSCAPE_SPKI *spki = NULL;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &spkstr, &spkstr_len) == FAILURE) {
+		return;
+	}
+	RETVAL_FALSE;
+
+	if (spkstr == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to use supplied SPKAC");
+		goto cleanup;
+	}
+
+	spkstr_cleaned = emalloc(spkstr_len + 1);
+	openssl_spki_cleanup(spkstr, spkstr_cleaned);
+
+	if (strlen(spkstr_cleaned)<=0) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid SPKAC");
+		goto cleanup;
+	}
+
+	spki = NETSCAPE_SPKI_b64_decode(spkstr_cleaned, strlen(spkstr_cleaned));
+	if (spki == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to decode supplied SPKAC");
+		goto cleanup;
+	}
+
+	pkey = X509_PUBKEY_get(spki->spkac->pubkey);
+	if (pkey == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to acquire signed public key");
+		goto cleanup;
+	}
+
+	i = NETSCAPE_SPKI_verify(spki, pkey);
+	goto cleanup;
+
+cleanup:
+	if (spki != NULL) {
+		NETSCAPE_SPKI_free(spki);
+	}
+	if (pkey != NULL) {
+		EVP_PKEY_free(pkey);
+	}
+	if (spkstr_cleaned != NULL) {
+		efree(spkstr_cleaned);
+	}
+
+	if (i > 0) {
+		RETVAL_TRUE;
+	}
+}
+/* }}} */
+
+/* {{{ proto string openssl_spki_export(string spki)
+   Exports public key from existing spki to var */
+PHP_FUNCTION(openssl_spki_export)
+{
+	int spkstr_len;
+	char *spkstr = NULL, * spkstr_cleaned = NULL, * s = NULL;
+
+	EVP_PKEY *pkey = NULL;
+	NETSCAPE_SPKI *spki = NULL;
+	BIO *out = NULL;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &spkstr, &spkstr_len) == FAILURE) {
+		return;
+	}
+	RETVAL_FALSE;
+
+	if (spkstr == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to use supplied SPKAC");
+		goto cleanup;
+	}
+
+	spkstr_cleaned = emalloc(spkstr_len + 1);
+	openssl_spki_cleanup(spkstr, spkstr_cleaned);
+
+	spki = NETSCAPE_SPKI_b64_decode(spkstr_cleaned, strlen(spkstr_cleaned));
+	if (spki == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to decode supplied SPKAC");
+		goto cleanup;
+	}
+
+	pkey = X509_PUBKEY_get(spki->spkac->pubkey);
+	if (pkey == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to acquire signed public key");
+		goto cleanup;
+	}
+
+	out = BIO_new(BIO_s_mem());
+	if (out && PEM_write_bio_PUBKEY(out, pkey))  {
+		BUF_MEM *bio_buf;
+
+		BIO_get_mem_ptr(out, &bio_buf);
+		RETVAL_STRINGL((char *)bio_buf->data, bio_buf->length, 1);
+	}
+	goto cleanup;
+
+cleanup:
+
+	if (spki != NULL) {
+		NETSCAPE_SPKI_free(spki);
+	}
+	if (out != NULL) {
+		BIO_free_all(out);
+	}
+	if (pkey != NULL) {
+		EVP_PKEY_free(pkey);
+	}
+	if (spkstr_cleaned != NULL) {
+		efree(spkstr_cleaned);
+	}
+	if (s != NULL) {
+		efree(s);
+	}
+}
+/* }}} */
+
+/* {{{ proto string openssl_spki_export_challenge(string spki)
+   Exports spkac challenge from existing spki to var */
+PHP_FUNCTION(openssl_spki_export_challenge)
+{
+	int spkstr_len;
+	char *spkstr = NULL, * spkstr_cleaned = NULL;
+
+	NETSCAPE_SPKI *spki = NULL;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &spkstr, &spkstr_len) == FAILURE) {
+		return;
+	}
+	RETVAL_FALSE;
+
+	if (spkstr == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to use supplied SPKAC");
+		goto cleanup;
+	}
+
+	spkstr_cleaned = emalloc(spkstr_len + 1);
+	openssl_spki_cleanup(spkstr, spkstr_cleaned);
+
+	spki = NETSCAPE_SPKI_b64_decode(spkstr_cleaned, strlen(spkstr_cleaned));
+	if (spki == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to decode SPKAC");
+		goto cleanup;
+	}
+
+	RETVAL_STRING((char *) ASN1_STRING_data(spki->spkac->challenge), 1);
+	goto cleanup;
+
+cleanup:
+	if (spkstr_cleaned != NULL) {
+		efree(spkstr_cleaned);
+	}
+}
+/* }}} */
+
+/* {{{ strip line endings from spkac */
+int openssl_spki_cleanup(const char *src, char *dest)
+{
+    int removed=0;
+
+    while (*src) {
+        if (*src!='\n'&&*src!='\r') {
+            *dest++=*src;
+        } else {
+            ++removed;
+        }
+        ++src;
+    }
+    *dest=0;
+    return removed;
+}
+/* }}} */
+
 /* {{{ proto bool openssl_x509_export(mixed x509, string &out [, bool notext = true])
    Exports a CERT to file or a var */
 PHP_FUNCTION(openssl_x509_export)
@@ -1304,6 +1940,66 @@
 }
 /* }}} */
 
+int php_openssl_x509_fingerprint(X509 *peer, const char *method, zend_bool raw, char **out, int *out_len TSRMLS_DC)
+{
+	unsigned char md[EVP_MAX_MD_SIZE];
+	const EVP_MD *mdtype;
+	unsigned int n;
+
+	if (!(mdtype = EVP_get_digestbyname(method))) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unknown signature algorithm");
+		return FAILURE;
+	} else if (!X509_digest(peer, mdtype, md, &n)) {
+		php_error_docref(NULL TSRMLS_CC, E_ERROR, "Could not generate signature");
+		return FAILURE;
+	}
+
+	if (raw) {
+		*out_len = n;
+		*out = estrndup((char *) md, n);
+	} else {
+		*out_len = n * 2;
+		*out = emalloc(*out_len + 1);
+
+		make_digest_ex(*out, md, n);
+	}
+
+	return SUCCESS;
+}
+
+PHP_FUNCTION(openssl_x509_fingerprint)
+{
+	X509 *cert;
+	zval **zcert;
+	long certresource;
+	zend_bool raw_output = 0;
+	char *method = "sha1";
+	int method_len;
+
+	char *fingerprint;
+	int fingerprint_len;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "Z|sb", &zcert, &method, &method_len, &raw_output) == FAILURE) {
+		return;
+	}
+
+	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
+	if (cert == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "cannot get cert from parameter 1");
+		RETURN_FALSE;
+	}
+
+	if (php_openssl_x509_fingerprint(cert, method, raw_output, &fingerprint, &fingerprint_len TSRMLS_CC) == SUCCESS) {
+		RETVAL_STRINGL(fingerprint, fingerprint_len, 0);
+	} else {
+		RETVAL_FALSE;
+	}
+
+	if (certresource == -1 && cert) {
+		X509_free(cert);
+	}
+}
+
 /* {{{ proto bool openssl_x509_check_private_key(mixed cert, mixed key)
    Checks if a private key corresponds to a CERT */
 PHP_FUNCTION(openssl_x509_check_private_key)
@@ -1344,6 +2040,7 @@
 {
 	GENERAL_NAMES *names;
 	const X509V3_EXT_METHOD *method = NULL;
+	ASN1_OCTET_STRING *extension_data;
 	long i, length, num;
 	const unsigned char *p;
 
@@ -1352,8 +2049,9 @@
 		return -1;
 	}
 
-	p = extension->value->data;
-	length = extension->value->length;
+	extension_data = X509_EXTENSION_get_data(extension);
+	p = extension_data->data;
+	length = extension_data->length;
 	if (method->it) {
 		names = (GENERAL_NAMES*)(ASN1_item_d2i(NULL, &p, length,
 						       ASN1_ITEM_ptr(method->it)));
@@ -1411,11 +2109,13 @@
 	zval ** zcert;
 	X509 * cert = NULL;
 	long certresource = -1;
-	int i;
+	int i, sig_nid;
 	zend_bool useshortnames = 1;
 	char * tmpstr;
 	zval * subitem;
 	X509_EXTENSION *extension;
+	X509_NAME *subject_name;
+	char *cert_name;
 	char *extname;
 	BIO  *bio_out;
 	BUF_MEM *bio_buf;
@@ -1430,10 +2130,10 @@
 	}
 	array_init(return_value);
 
-	if (cert->name) {
-		add_assoc_string(return_value, "name", cert->name, 1);
-	}
-/*	add_assoc_bool(return_value, "valid", cert->valid); */
+	subject_name = X509_get_subject_name(cert);
+	cert_name = X509_NAME_oneline(subject_name, NULL, 0);
+	add_assoc_string(return_value, "name", cert_name, 1);
+	OPENSSL_free(cert_name);
 
 	add_assoc_name_entry(return_value, "subject", 		X509_get_subject_name(cert), useshortnames TSRMLS_CC);
 	/* hash as used in CA directories to lookup cert by subject name */
@@ -1458,11 +2158,12 @@
 	if (tmpstr) {
 		add_assoc_string(return_value, "alias", tmpstr, 1);
 	}
-/*
-	add_assoc_long(return_value, "signaturetypeLONG", X509_get_signature_type(cert));
-	add_assoc_string(return_value, "signaturetype", OBJ_nid2sn(X509_get_signature_type(cert)), 1);
-	add_assoc_string(return_value, "signaturetypeLN", OBJ_nid2ln(X509_get_signature_type(cert)), 1);
-*/
+
+	sig_nid = X509_get_signature_nid(cert);
+	add_assoc_string(return_value, "signatureTypeSN", (char*)OBJ_nid2sn(sig_nid), 1);
+	add_assoc_string(return_value, "signatureTypeLN", (char*)OBJ_nid2ln(sig_nid), 1);
+	add_assoc_long(return_value, "signatureTypeNID", sig_nid);
+
 	MAKE_STD_ZVAL(subitem);
 	array_init(subitem);
 
@@ -1553,7 +2254,7 @@
 		goto end;
 	}
 
-	if (php_openssl_safe_mode_chk(certfile TSRMLS_CC)) {
+	if (php_openssl_open_base_dir_chk(certfile TSRMLS_CC)) {
 		sk_X509_free(stack);
 		goto end;
 	}
@@ -1861,14 +2562,10 @@
 	zval ** item;
 	STACK_OF(X509) *ca = NULL;
 
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "Zszs|a", &zcert, &filename, &filename_len, &zpkey, &pass, &pass_len, &args) == FAILURE)
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "Zpzs|a", &zcert, &filename, &filename_len, &zpkey, &pass, &pass_len, &args) == FAILURE)
 		return;
 
 	RETVAL_FALSE;
-
-	if (strlen(filename) != filename_len) {
-		return;
-	}
 	
 	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
 	if (cert == NULL) {
@@ -1884,7 +2581,7 @@
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "private key does not correspond to cert");
 		goto cleanup;
 	}
-	if (php_openssl_safe_mode_chk(filename TSRMLS_CC)) {
+	if (php_openssl_open_base_dir_chk(filename TSRMLS_CC)) {
 		goto cleanup;
 	}
 
@@ -2060,7 +2757,15 @@
 				zval * zextracert;
 				X509* aCA = sk_X509_pop(ca);
 				if (!aCA) break;
-				
+
+				/* fix for bug 69882 */
+				{
+					int err = ERR_peek_error();
+					if (err == OPENSSL_ERROR_X509_PRIVATE_KEY_VALUES_MISMATCH) {
+						ERR_get_error();
+					}
+				}
+
 				bio_out = BIO_new(BIO_s_mem());
 				if (PEM_write_bio_X509(bio_out, aCA)) {
 					BUF_MEM *bio_buf;
@@ -2151,10 +2856,14 @@
 
 				nid = OBJ_txt2nid(strindex);
 				if (nid != NID_undef) {
-					if (!X509_NAME_add_entry_by_NID(subj, nid, MBSTRING_ASC, 
+					if (!X509_NAME_add_entry_by_NID(subj, nid, MBSTRING_UTF8, 
 								(unsigned char*)Z_STRVAL_PP(item), -1, -1, 0))
 					{
-						php_error_docref(NULL TSRMLS_CC, E_WARNING, "dn: add_entry_by_NID %d -> %s (failed)", nid, Z_STRVAL_PP(item));
+						php_error_docref(NULL TSRMLS_CC, E_WARNING,
+							"dn: add_entry_by_NID %d -> %s (failed; check error"
+							" queue and value of string_mask OpenSSL option "
+							"if illegal characters are reported)",
+							nid, Z_STRVAL_PP(item));
 						return FAILURE;
 					}
 				} else {
@@ -2203,7 +2912,7 @@
 			if (X509_NAME_get_index_by_NID(subj, nid, -1) >= 0) {
 				continue;
 			}
-			if (!X509_NAME_add_entry_by_txt(subj, type, MBSTRING_ASC, (unsigned char*)v->value, -1, -1, 0)) {
+			if (!X509_NAME_add_entry_by_txt(subj, type, MBSTRING_UTF8, (unsigned char*)v->value, -1, -1, 0)) {
 				php_error_docref(NULL TSRMLS_CC, E_WARNING, "add_entry_by_txt %s -> %s (failed)", type, v->value);
 				return FAILURE;
 			}
@@ -2227,7 +2936,7 @@
 
 					nid = OBJ_txt2nid(strindex);
 					if (nid != NID_undef) {
-						if (!X509_NAME_add_entry_by_NID(subj, nid, MBSTRING_ASC, (unsigned char*)Z_STRVAL_PP(item), -1, -1, 0)) {
+						if (!X509_NAME_add_entry_by_NID(subj, nid, MBSTRING_UTF8, (unsigned char*)Z_STRVAL_PP(item), -1, -1, 0)) {
 							php_error_docref(NULL TSRMLS_CC, E_WARNING, "attribs: add_entry_by_NID %d -> %s (failed)", nid, Z_STRVAL_PP(item));
 							return FAILURE;
 						}
@@ -2244,8 +2953,12 @@
 				if (X509_REQ_get_attr_by_NID(csr, nid, -1) >= 0) {
 					continue;
 				}
-				if (!X509_REQ_add1_attr_by_txt(csr, v->name, MBSTRING_ASC, (unsigned char*)v->value, -1)) {
-					php_error_docref(NULL TSRMLS_CC, E_WARNING, "add1_attr_by_txt %s -> %s (failed)", v->name, v->value);
+				if (!X509_REQ_add1_attr_by_txt(csr, v->name, MBSTRING_UTF8, (unsigned char*)v->value, -1)) {
+					php_error_docref(NULL TSRMLS_CC, E_WARNING,
+						"add1_attr_by_txt %s -> %s (failed; check error queue "
+						"and value of string_mask OpenSSL option if illegal "
+						"characters are reported)",
+						v->name, v->value);
 					return FAILURE;
 				}
 			}
@@ -2287,7 +3000,7 @@
 		filename = Z_STRVAL_PP(val) + (sizeof("file://") - 1);
 	}
 	if (filename) {
-		if (php_openssl_safe_mode_chk(filename TSRMLS_CC)) {
+		if (php_openssl_open_base_dir_chk(filename TSRMLS_CC)) {
 			return NULL;
 		}
 		in = BIO_new_file(filename, "r");
@@ -2312,22 +3025,18 @@
 	BIO * bio_out;
 	long csr_resource;
 
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rs|b", &zcsr, &filename, &filename_len, &notext) == FAILURE) {
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "rp|b", &zcsr, &filename, &filename_len, &notext) == FAILURE) {
 		return;
 	}
 	RETVAL_FALSE;
 
-	if (strlen(filename) != filename_len) {
-		return;
-	}
-
 	csr = php_openssl_csr_from_zval(&zcsr, 0, &csr_resource TSRMLS_CC);
 	if (csr == NULL) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "cannot get CSR from parameter 1");
 		return;
 	}
 
-	if (php_openssl_safe_mode_chk(filename TSRMLS_CC)) {
+	if (php_openssl_open_base_dir_chk(filename TSRMLS_CC)) {
 		return;
 	}
 
@@ -2501,7 +3210,7 @@
 	}
 	
 	/* Succeeded; lets return the cert */
-	RETVAL_RESOURCE(zend_list_insert(new_cert, le_x509));
+	RETVAL_RESOURCE(zend_list_insert(new_cert, le_x509 TSRMLS_CC));
 	new_cert = NULL;
 	
 cleanup:
@@ -2578,7 +3287,7 @@
 						RETVAL_TRUE;
 						
 						if (X509_REQ_sign(csr, req.priv_key, req.digest)) {
-							RETVAL_RESOURCE(zend_list_insert(csr, le_csr));
+							RETVAL_RESOURCE(zend_list_insert(csr, le_csr TSRMLS_CC));
 							csr = NULL;			
 						} else {
 							php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error signing request");
@@ -2587,7 +3296,7 @@
 						if (we_made_the_key) {
 							/* and a resource for the private key */
 							zval_dtor(out_pkey);
-							ZVAL_RESOURCE(out_pkey, zend_list_insert(req.priv_key, le_key));
+							ZVAL_RESOURCE(out_pkey, zend_list_insert(req.priv_key, le_key TSRMLS_CC));
 							req.priv_key = NULL; /* make sure the cleanup code doesn't zap it! */
 						} else if (key_resource != -1) {
 							req.priv_key = NULL; /* make sure the cleanup code doesn't zap it! */
@@ -2659,8 +3368,22 @@
 		RETURN_FALSE;
 	}
 
-	tpubkey=X509_REQ_get_pubkey(csr);
-	RETVAL_RESOURCE(zend_list_insert(tpubkey, le_key));
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER)
+	/* Due to changes in OpenSSL 1.1 related to locking when decoding CSR,
+	 * the pub key is not changed after assigning. It means if we pass
+	 * a private key, it will be returned including the private part.
+	 * If we duplicate it, then we get just the public part which is
+	 * the same behavior as for OpenSSL 1.0 */
+	csr = X509_REQ_dup(csr);
+#endif
+	/* Retrieve the public key from the CSR */
+	tpubkey = X509_REQ_get_pubkey(csr);
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER)
+	/* We need to free the CSR as it was duplicated */
+	X509_REQ_free(csr);
+#endif
+	RETVAL_RESOURCE(zend_list_insert(tpubkey, le_key TSRMLS_CC));
 	return;
 }
 /* }}} */
@@ -2805,7 +3528,7 @@
 			BIO *in;
 
 			if (filename) {
-				if (php_openssl_safe_mode_chk(filename TSRMLS_CC)) {
+				if (php_openssl_open_base_dir_chk(filename TSRMLS_CC)) {
 					TMP_CLEAN;
 				}
 				in = BIO_new_file(filename, "r");
@@ -2853,17 +3576,19 @@
 	}
 
 	randfile = CONF_get_string(req->req_config, req->section_name, "RANDFILE");
-	php_openssl_load_rand_file(randfile, &egdsocket, &seeded);
+	php_openssl_load_rand_file(randfile, &egdsocket, &seeded TSRMLS_CC);
 	
 	if ((req->priv_key = EVP_PKEY_new()) != NULL) {
 		switch(req->priv_key_type) {
 			case OPENSSL_KEYTYPE_RSA:
+				PHP_OPENSSL_RAND_ADD_TIME();
 				if (EVP_PKEY_assign_RSA(req->priv_key, RSA_generate_key(req->priv_key_bits, 0x10001, NULL, NULL))) {
 					return_val = req->priv_key;
 				}
 				break;
 #if !defined(NO_DSA) && defined(HAVE_DSA_DEFAULT_METHOD)
 			case OPENSSL_KEYTYPE_DSA:
+				PHP_OPENSSL_RAND_ADD_TIME();
 				{
 					DSA *dsapar = DSA_generate_parameters(req->priv_key_bits, NULL, 0, NULL, NULL, NULL, NULL);
 					if (dsapar) {
@@ -2881,6 +3606,7 @@
 #endif
 #if !defined(NO_DH)
 			case OPENSSL_KEYTYPE_DH:
+				PHP_OPENSSL_RAND_ADD_TIME();
 				{
 					DH *dhpar = DH_generate_parameters(req->priv_key_bits, 2, NULL, NULL);
 					int codes = 0;
@@ -2921,13 +3647,20 @@
 {
 	assert(pkey != NULL);
 
-	switch (pkey->type) {
+	switch (EVP_PKEY_id(pkey)) {
 #ifndef NO_RSA
 		case EVP_PKEY_RSA:
 		case EVP_PKEY_RSA2:
-			assert(pkey->pkey.rsa != NULL);
-			if (pkey->pkey.rsa != NULL && (NULL == pkey->pkey.rsa->p || NULL == pkey->pkey.rsa->q)) {
-				return 0;
+			{
+				RSA *rsa = EVP_PKEY_get0_RSA(pkey);
+				if (rsa != NULL) {
+					const BIGNUM *p, *q;
+
+					RSA_get0_factors(rsa, &p, &q);
+					 if (p == NULL || q == NULL) {
+						return 0;
+					 }
+				}
 			}
 			break;
 #endif
@@ -2937,19 +3670,51 @@
 		case EVP_PKEY_DSA2:
 		case EVP_PKEY_DSA3:
 		case EVP_PKEY_DSA4:
-			assert(pkey->pkey.dsa != NULL);
-
-			if (NULL == pkey->pkey.dsa->p || NULL == pkey->pkey.dsa->q || NULL == pkey->pkey.dsa->priv_key){ 
-				return 0;
+			{
+				DSA *dsa = EVP_PKEY_get0_DSA(pkey);
+				if (dsa != NULL) {
+					const BIGNUM *p, *q, *g, *pub_key, *priv_key;
+
+					DSA_get0_pqg(dsa, &p, &q, &g);
+					if (p == NULL || q == NULL) {
+						return 0;
+					}
+ 
+					DSA_get0_key(dsa, &pub_key, &priv_key);
+					if (priv_key == NULL) {
+						return 0;
+					}
+				}
 			}
 			break;
 #endif
 #ifndef NO_DH
 		case EVP_PKEY_DH:
-			assert(pkey->pkey.dh != NULL);
-
-			if (NULL == pkey->pkey.dh->p || NULL == pkey->pkey.dh->priv_key) {
-				return 0;
+			{
+				DH *dh = EVP_PKEY_get0_DH(pkey);
+				if (dh != NULL) {
+					const BIGNUM *p, *q, *g, *pub_key, *priv_key;
+
+					DH_get0_pqg(dh, &p, &q, &g);
+					if (p == NULL) {
+						return 0;
+					}
+ 
+					DH_get0_key(dh, &pub_key, &priv_key);
+					if (priv_key == NULL) {
+						return 0;
+					}
+				}
+			}
+			break;
+#endif
+#ifdef HAVE_EVP_PKEY_EC
+		case EVP_PKEY_EC:
+			{
+				EC_KEY *ec = EVP_PKEY_get0_EC_KEY(pkey);
+				if (ec != NULL && NULL == EC_KEY_get0_private_key(ec)) {
+					return 0;
+				}
 			}
 			break;
 #endif
@@ -2961,26 +3726,165 @@
 }
 /* }}} */
 
-#define OPENSSL_PKEY_GET_BN(_type, _name) do {							\
-		if (pkey->pkey._type->_name != NULL) {							\
-			int len = BN_num_bytes(pkey->pkey._type->_name);			\
-			char *str = emalloc(len + 1);								\
-			BN_bn2bin(pkey->pkey._type->_name, (unsigned char*)str);	\
-			str[len] = 0;                                           	\
-			add_assoc_stringl(_type, #_name, str, len, 0);				\
-		}																\
-	} while (0)
-
-#define OPENSSL_PKEY_SET_BN(_ht, _type, _name) do {						\
-		zval **bn;														\
-		if (zend_hash_find(_ht, #_name, sizeof(#_name),	(void**)&bn) == SUCCESS && \
-				Z_TYPE_PP(bn) == IS_STRING) {							\
-			_type->_name = BN_bin2bn(									\
-				(unsigned char*)Z_STRVAL_PP(bn),						\
-	 			Z_STRLEN_PP(bn), NULL);									\
-	    }                                                               \
+#define OPENSSL_GET_BN(_array, _bn, _name) do { \
+		if (_bn != NULL) { \
+			int len = BN_num_bytes(_bn); \
+			char *str = emalloc(len + 1); \
+			BN_bn2bin(_bn, (unsigned char*)str); \
+			str[len] = 0; \
+			add_assoc_stringl(_array, #_name, str, len, 0); \
+		} \
 	} while (0);
 
+#define OPENSSL_PKEY_GET_BN(_type, _name) OPENSSL_GET_BN(_type, _name, _name)
+
+#define OPENSSL_PKEY_SET_BN(_data, _name) do { \
+		zval **bn; \
+		if (zend_hash_find(Z_ARRVAL_P(_data), #_name, sizeof(#_name),(void**)&bn) == SUCCESS && \
+				Z_TYPE_PP(bn) == IS_STRING) { \
+			_name = BN_bin2bn( \
+				(unsigned char*)Z_STRVAL_PP(bn), \
+				Z_STRLEN_PP(bn), NULL); \
+		} else { \
+			_name = NULL; \
+		} \
+ 	} while (0);
+
+/* {{{ php_openssl_pkey_init_rsa */
+zend_bool php_openssl_pkey_init_and_assign_rsa(EVP_PKEY *pkey, RSA *rsa, zval *data)
+{
+	BIGNUM *n, *e, *d, *p, *q, *dmp1, *dmq1, *iqmp;
+
+	OPENSSL_PKEY_SET_BN(data, n);
+	OPENSSL_PKEY_SET_BN(data, e);
+	OPENSSL_PKEY_SET_BN(data, d);
+	if (!n || !d || !RSA_set0_key(rsa, n, e, d)) {
+		return 0;
+	}
+
+	OPENSSL_PKEY_SET_BN(data, p);
+	OPENSSL_PKEY_SET_BN(data, q);
+	if ((p || q) && !RSA_set0_factors(rsa, p, q)) {
+		return 0;
+	}
+
+	OPENSSL_PKEY_SET_BN(data, dmp1);
+	OPENSSL_PKEY_SET_BN(data, dmq1);
+	OPENSSL_PKEY_SET_BN(data, iqmp);
+	if ((dmp1 || dmq1 || iqmp) && !RSA_set0_crt_params(rsa, dmp1, dmq1, iqmp)) {
+		return 0;
+	}
+
+	if (!EVP_PKEY_assign_RSA(pkey, rsa)) {
+		return 0;
+	}
+
+	return 1;
+}
+/* }}} */
+
+/* {{{ php_openssl_pkey_init_dsa */
+zend_bool php_openssl_pkey_init_dsa(DSA *dsa, zval *data)
+{
+	BIGNUM *p, *q, *g, *priv_key, *pub_key;
+	const BIGNUM *priv_key_const, *pub_key_const;
+
+	OPENSSL_PKEY_SET_BN(data, p);
+	OPENSSL_PKEY_SET_BN(data, q);
+	OPENSSL_PKEY_SET_BN(data, g);
+	if (!p || !q || !g || !DSA_set0_pqg(dsa, p, q, g)) {
+		return 0;
+	}
+
+	OPENSSL_PKEY_SET_BN(data, pub_key);
+	OPENSSL_PKEY_SET_BN(data, priv_key);
+	if (pub_key) {
+		return DSA_set0_key(dsa, pub_key, priv_key);
+	}
+	PHP_OPENSSL_RAND_ADD_TIME();
+	if (!DSA_generate_key(dsa)) {
+		return 0;
+	}
+	/* if BN_mod_exp return -1, then DSA_generate_key succeed for failed key
+	 * so we need to double check that public key is created */
+	DSA_get0_key(dsa, &pub_key_const, &priv_key_const);
+	if (!pub_key_const || BN_is_zero(pub_key_const)) {
+		return 0;
+	}
+	/* all good */
+	return 1;
+}
+/* }}} */
+
+/* {{{ php_openssl_dh_pub_from_priv */
+static BIGNUM *php_openssl_dh_pub_from_priv(BIGNUM *priv_key, BIGNUM *g, BIGNUM *p)
+{
+	BIGNUM *pub_key, *priv_key_const_time;
+	BN_CTX *ctx;
+
+	pub_key = BN_new();
+	if (pub_key == NULL) {
+		return NULL;
+	}
+
+	priv_key_const_time = BN_new();
+	if (priv_key_const_time == NULL) {
+		BN_free(pub_key);
+		return NULL;
+	}
+	ctx = BN_CTX_new();
+	if (ctx == NULL) {
+		BN_free(pub_key);
+		BN_free(priv_key_const_time);
+		return NULL;
+	}
+
+	BN_with_flags(priv_key_const_time, priv_key, BN_FLG_CONSTTIME);
+
+	if (!BN_mod_exp_mont(pub_key, g, priv_key_const_time, p, ctx, NULL)) {
+		BN_free(pub_key);
+		pub_key = NULL;
+	}
+
+	BN_free(priv_key_const_time);
+	BN_CTX_free(ctx);
+
+	return pub_key;
+}
+/* }}} */
+
+/* {{{ php_openssl_pkey_init_dh */
+zend_bool php_openssl_pkey_init_dh(DH *dh, zval *data)
+{
+	BIGNUM *p, *q, *g, *priv_key, *pub_key;
+
+	OPENSSL_PKEY_SET_BN(data, p);
+	OPENSSL_PKEY_SET_BN(data, q);
+	OPENSSL_PKEY_SET_BN(data, g);
+	if (!p || !g || !DH_set0_pqg(dh, p, q, g)) {
+		return 0;
+	}
+
+	OPENSSL_PKEY_SET_BN(data, priv_key);
+	OPENSSL_PKEY_SET_BN(data, pub_key);
+	if (pub_key) {
+		return DH_set0_key(dh, pub_key, priv_key);
+	}
+	if (priv_key) {
+		pub_key = php_openssl_dh_pub_from_priv(priv_key, g, p);
+		if (pub_key == NULL) {
+			return 0;
+		}
+		return DH_set0_key(dh, pub_key, priv_key);
+	}
+	PHP_OPENSSL_RAND_ADD_TIME();
+	if (!DH_generate_key(dh)) {
+		return 0;
+	}
+	/* all good */
+	return 1;
+}
+/* }}} */
 
 /* {{{ proto resource openssl_pkey_new([array configargs])
    Generates a new private key */
@@ -3004,18 +3908,8 @@
 		    if (pkey) {
 				RSA *rsa = RSA_new();
 				if (rsa) {
-					OPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), rsa, n);
-					OPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), rsa, e);
-					OPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), rsa, d);
-					OPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), rsa, p);
-					OPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), rsa, q);
-					OPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), rsa, dmp1);
-					OPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), rsa, dmq1);
-					OPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), rsa, iqmp);
-					if (rsa->n && rsa->d) {
-						if (EVP_PKEY_assign_RSA(pkey, rsa)) {
-							RETURN_RESOURCE(zend_list_insert(pkey, le_key));
-						}
+					if (php_openssl_pkey_init_and_assign_rsa(pkey, rsa, *data)) {
+						RETURN_RESOURCE(zend_list_insert(pkey, le_key TSRMLS_CC));
 					}
 					RSA_free(rsa);
 				}
@@ -3028,17 +3922,9 @@
 		    if (pkey) {
 				DSA *dsa = DSA_new();
 				if (dsa) {
-					OPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), dsa, p);
-					OPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), dsa, q);
-					OPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), dsa, g);
-					OPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), dsa, priv_key);
-					OPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), dsa, pub_key);
-					if (dsa->p && dsa->q && dsa->g) {
-						if (!dsa->priv_key && !dsa->pub_key) {
-							DSA_generate_key(dsa);
-						}
+					if (php_openssl_pkey_init_dsa(dsa, *data)) {
 						if (EVP_PKEY_assign_DSA(pkey, dsa)) {
-							RETURN_RESOURCE(zend_list_insert(pkey, le_key));
+							RETURN_RESOURCE(zend_list_insert(pkey, le_key TSRMLS_CC));
 						}
 					}
 					DSA_free(dsa);
@@ -3052,16 +3938,9 @@
 		    if (pkey) {
 				DH *dh = DH_new();
 				if (dh) {
-					OPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), dh, p);
-					OPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), dh, g);
-					OPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), dh, priv_key);
-					OPENSSL_PKEY_SET_BN(Z_ARRVAL_PP(data), dh, pub_key);
-					if (dh->p && dh->g) {
-						if (!dh->pub_key) {
-							DH_generate_key(dh);
-						}
+					if (php_openssl_pkey_init_dh(dh, *data)) {
 						if (EVP_PKEY_assign_DH(pkey, dh)) {
-							RETURN_RESOURCE(zend_list_insert(pkey, le_key));
+							RETURN_RESOURCE(zend_list_insert(pkey, le_key TSRMLS_CC));
 						}
 					}
 					DH_free(dh);
@@ -3078,7 +3957,7 @@
 	{
 		if (php_openssl_generate_private_key(&req TSRMLS_CC)) {
 			/* pass back a key resource */
-			RETVAL_RESOURCE(zend_list_insert(req.priv_key, le_key));
+			RETVAL_RESOURCE(zend_list_insert(req.priv_key, le_key TSRMLS_CC));
 			/* make sure the cleanup code doesn't zap it! */
 			req.priv_key = NULL;
 		}
@@ -3093,22 +3972,21 @@
 {
 	struct php_x509_request req;
 	zval ** zpkey, * args = NULL;
-	char * passphrase = NULL; int passphrase_len = 0;
-	char * filename = NULL; int filename_len = 0;
+	char * passphrase = NULL; 
+	int passphrase_len = 0;
+	char * filename = NULL; 
+	int filename_len = 0;
 	long key_resource = -1;
+	int pem_write = 0;
 	EVP_PKEY * key;
 	BIO * bio_out = NULL;
 	const EVP_CIPHER * cipher;
 	
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "Zs|s!a!", &zpkey, &filename, &filename_len, &passphrase, &passphrase_len, &args) == FAILURE) {
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "Zp|s!a!", &zpkey, &filename, &filename_len, &passphrase, &passphrase_len, &args) == FAILURE) {
 		return;
 	}
 	RETVAL_FALSE;
 
-	if (strlen(filename) != filename_len) {
-		return;
-	}
-
 	key = php_openssl_evp_from_zval(zpkey, 0, passphrase, 0, &key_resource TSRMLS_CC);
 
 	if (key == NULL) {
@@ -3116,7 +3994,7 @@
 		RETURN_FALSE;
 	}
 	
-	if (php_openssl_safe_mode_chk(filename TSRMLS_CC)) {
+	if (php_openssl_open_base_dir_chk(filename TSRMLS_CC)) {
 		RETURN_FALSE;
 	}
 	
@@ -3126,11 +4004,27 @@
 		bio_out = BIO_new_file(filename, "w");
 
 		if (passphrase && req.priv_key_encrypt) {
-			cipher = (EVP_CIPHER *) EVP_des_ede3_cbc();
+			if (req.priv_key_encrypt_cipher) {
+				cipher = req.priv_key_encrypt_cipher;
+			} else {
+				cipher = (EVP_CIPHER *) EVP_des_ede3_cbc();
+			}
 		} else {
 			cipher = NULL;
 		}
-		if (PEM_write_bio_PrivateKey(bio_out, key, cipher, (unsigned char *)passphrase, passphrase_len, NULL, NULL)) {
+
+		switch (EVP_PKEY_base_id(key)) {
+#ifdef HAVE_EVP_PKEY_EC
+			case EVP_PKEY_EC:
+				pem_write = PEM_write_bio_ECPrivateKey(bio_out, EVP_PKEY_get0_EC_KEY(key), cipher, (unsigned char *)passphrase, passphrase_len, NULL, NULL);
+				break;
+#endif
+			default:
+				pem_write = PEM_write_bio_PrivateKey(bio_out, key, cipher, (unsigned char *)passphrase, passphrase_len, NULL, NULL);
+				break;
+		}
+
+		if (pem_write) {
 			/* Success!
 			 * If returning the output as a string, do so now */
 			RETVAL_TRUE;
@@ -3153,8 +4047,10 @@
 {
 	struct php_x509_request req;
 	zval ** zpkey, * args = NULL, *out;
-	char * passphrase = NULL; int passphrase_len = 0;
+	char * passphrase = NULL; 
+	int passphrase_len = 0;
 	long key_resource = -1;
+	int pem_write = 0;
 	EVP_PKEY * key;
 	BIO * bio_out = NULL;
 	const EVP_CIPHER * cipher;
@@ -3177,11 +4073,27 @@
 		bio_out = BIO_new(BIO_s_mem());
 
 		if (passphrase && req.priv_key_encrypt) {
-			cipher = (EVP_CIPHER *) EVP_des_ede3_cbc();
+			if (req.priv_key_encrypt_cipher) {
+				cipher = req.priv_key_encrypt_cipher;
+			} else {
+				cipher = (EVP_CIPHER *) EVP_des_ede3_cbc();
+			}
 		} else {
 			cipher = NULL;
 		}
-		if (PEM_write_bio_PrivateKey(bio_out, key, cipher, (unsigned char *)passphrase, passphrase_len, NULL, NULL)) {
+
+		switch (EVP_PKEY_base_id(key)) {
+#ifdef HAVE_EVP_PKEY_EC
+			case EVP_PKEY_EC:
+				pem_write = PEM_write_bio_ECPrivateKey(bio_out, EVP_PKEY_get1_EC_KEY(key), cipher, (unsigned char *)passphrase, passphrase_len, NULL, NULL);
+				break;
+#endif
+			default:
+				pem_write = PEM_write_bio_PrivateKey(bio_out, key, cipher, (unsigned char *)passphrase, passphrase_len, NULL, NULL);
+				break;
+		}
+
+		if (pem_write) {
 			/* Success!
 			 * If returning the output as a string, do so now */
 
@@ -3221,6 +4133,7 @@
 	if (pkey == NULL) {
 		RETURN_FALSE;
 	}
+	zend_list_addref(Z_LVAL_P(return_value));
 }
 /* }}} */
 
@@ -3257,6 +4170,7 @@
 	if (pkey == NULL) {
 		RETURN_FALSE;
 	}
+	zend_list_addref(Z_LVAL_P(return_value));
 }
 
 /* }}} */
@@ -3289,25 +4203,33 @@
 	/*TODO: Use the real values once the openssl constants are used 
 	 * See the enum at the top of this file
 	 */
-	switch (EVP_PKEY_type(pkey->type)) {
+	switch (EVP_PKEY_base_id(pkey)) {
 		case EVP_PKEY_RSA:
 		case EVP_PKEY_RSA2:
-			ktype = OPENSSL_KEYTYPE_RSA;
-
-			if (pkey->pkey.rsa != NULL) {
-				zval *rsa;
-
-				ALLOC_INIT_ZVAL(rsa);
-				array_init(rsa);
-				OPENSSL_PKEY_GET_BN(rsa, n);
-				OPENSSL_PKEY_GET_BN(rsa, e);
-				OPENSSL_PKEY_GET_BN(rsa, d);
-				OPENSSL_PKEY_GET_BN(rsa, p);
-				OPENSSL_PKEY_GET_BN(rsa, q);
-				OPENSSL_PKEY_GET_BN(rsa, dmp1);
-				OPENSSL_PKEY_GET_BN(rsa, dmq1);
-				OPENSSL_PKEY_GET_BN(rsa, iqmp);
-				add_assoc_zval(return_value, "rsa", rsa);
+			{
+				RSA *rsa = EVP_PKEY_get0_RSA(pkey);
+				ktype = OPENSSL_KEYTYPE_RSA;
+
+				if (rsa != NULL) {
+					zval *z_rsa;
+					const BIGNUM *n, *e, *d, *p, *q, *dmp1, *dmq1, *iqmp;
+
+					RSA_get0_key(rsa, &n, &e, &d);
+					RSA_get0_factors(rsa, &p, &q);
+					RSA_get0_crt_params(rsa, &dmp1, &dmq1, &iqmp);
+
+					ALLOC_INIT_ZVAL(z_rsa);
+					array_init(z_rsa);
+					OPENSSL_PKEY_GET_BN(z_rsa, n);
+					OPENSSL_PKEY_GET_BN(z_rsa, e);
+					OPENSSL_PKEY_GET_BN(z_rsa, d);
+					OPENSSL_PKEY_GET_BN(z_rsa, p);
+					OPENSSL_PKEY_GET_BN(z_rsa, q);
+					OPENSSL_PKEY_GET_BN(z_rsa, dmp1);
+					OPENSSL_PKEY_GET_BN(z_rsa, dmq1);
+					OPENSSL_PKEY_GET_BN(z_rsa, iqmp);
+					add_assoc_zval(return_value, "rsa", z_rsa);
+				}
 			}
 
 			break;	
@@ -3315,41 +4237,88 @@
 		case EVP_PKEY_DSA2:
 		case EVP_PKEY_DSA3:
 		case EVP_PKEY_DSA4:
-			ktype = OPENSSL_KEYTYPE_DSA;
-
-			if (pkey->pkey.dsa != NULL) {
-				zval *dsa;
-
-				ALLOC_INIT_ZVAL(dsa);
-				array_init(dsa);
-				OPENSSL_PKEY_GET_BN(dsa, p);
-				OPENSSL_PKEY_GET_BN(dsa, q);
-				OPENSSL_PKEY_GET_BN(dsa, g);
-				OPENSSL_PKEY_GET_BN(dsa, priv_key);
-				OPENSSL_PKEY_GET_BN(dsa, pub_key);
-				add_assoc_zval(return_value, "dsa", dsa);
+			{
+				DSA *dsa = EVP_PKEY_get0_DSA(pkey);
+				ktype = OPENSSL_KEYTYPE_DSA;
+
+				if (dsa != NULL) {
+					zval *z_dsa;
+					const BIGNUM *p, *q, *g, *priv_key, *pub_key;
+
+					DSA_get0_pqg(dsa, &p, &q, &g);
+					DSA_get0_key(dsa, &pub_key, &priv_key);
+
+					ALLOC_INIT_ZVAL(z_dsa);
+					array_init(z_dsa);
+					OPENSSL_PKEY_GET_BN(z_dsa, p);
+					OPENSSL_PKEY_GET_BN(z_dsa, q);
+					OPENSSL_PKEY_GET_BN(z_dsa, g);
+					OPENSSL_PKEY_GET_BN(z_dsa, priv_key);
+					OPENSSL_PKEY_GET_BN(z_dsa, pub_key);
+					add_assoc_zval(return_value, "dsa", z_dsa);
+				}
 			}
 			break;
 		case EVP_PKEY_DH:
-			
-			ktype = OPENSSL_KEYTYPE_DH;
-
-			if (pkey->pkey.dh != NULL) {
-				zval *dh;
-
-				ALLOC_INIT_ZVAL(dh);
-				array_init(dh);
-				OPENSSL_PKEY_GET_BN(dh, p);
-				OPENSSL_PKEY_GET_BN(dh, g);
-				OPENSSL_PKEY_GET_BN(dh, priv_key);
-				OPENSSL_PKEY_GET_BN(dh, pub_key);
-				add_assoc_zval(return_value, "dh", dh);
+			{
+				DH *dh = EVP_PKEY_get0_DH(pkey);
+				ktype = OPENSSL_KEYTYPE_DH;
+
+				if (dh != NULL) {
+					zval *z_dh;
+					const BIGNUM *p, *q, *g, *priv_key, *pub_key;
+
+					DH_get0_pqg(dh, &p, &q, &g);
+					DH_get0_key(dh, &pub_key, &priv_key);
+
+					ALLOC_INIT_ZVAL(z_dh);
+					array_init(z_dh);
+					OPENSSL_PKEY_GET_BN(z_dh, p);
+					OPENSSL_PKEY_GET_BN(z_dh, g);
+					OPENSSL_PKEY_GET_BN(z_dh, priv_key);
+					OPENSSL_PKEY_GET_BN(z_dh, pub_key);
+					add_assoc_zval(return_value, "dh", z_dh);
+				}
 			}
 
 			break;
-#ifdef EVP_PKEY_EC 
+#ifdef HAVE_EVP_PKEY_EC
 		case EVP_PKEY_EC:
 			ktype = OPENSSL_KEYTYPE_EC;
+			if (EVP_PKEY_get0_EC_KEY(pkey) != NULL) {
+				zval *ec;
+				const EC_GROUP *ec_group;
+				int nid;
+				char *crv_sn;
+				ASN1_OBJECT *obj;
+				// openssl recommends a buffer length of 80
+				char oir_buf[80];
+
+				ec_group = EC_KEY_get0_group(EVP_PKEY_get1_EC_KEY(pkey));
+
+				// Curve nid (numerical identifier) used for ASN1 mapping
+				nid = EC_GROUP_get_curve_name(ec_group);
+				if (nid == NID_undef) {
+					break;
+				}
+				ALLOC_INIT_ZVAL(ec);
+				array_init(ec);
+
+				// Short object name
+				crv_sn = (char*) OBJ_nid2sn(nid);
+				if (crv_sn != NULL) {
+					add_assoc_string(ec, "curve_name", crv_sn, 1);
+				}
+
+				obj = OBJ_nid2obj(nid);
+				if (obj != NULL) {
+					int oir_len = OBJ_obj2txt(oir_buf, sizeof(oir_buf), obj, 1);
+					add_assoc_stringl(ec, "curve_oid", (char*)oir_buf, oir_len, 1);
+					ASN1_OBJECT_free(obj);
+				}
+
+				add_assoc_zval(return_value, "ec", ec);
+			}
 			break;
 #endif
 		default:
@@ -3364,6 +4333,57 @@
 
 /* }}} */
 
+#if OPENSSL_VERSION_NUMBER >= 0x10000000L
+
+/* {{{ proto string openssl_pbkdf2(string password, string salt, long key_length, long iterations [, string digest_method = "sha1"])
+   Generates a PKCS5 v2 PBKDF2 string, defaults to sha1 */
+PHP_FUNCTION(openssl_pbkdf2)
+{
+	long key_length = 0, iterations = 0;
+	char *password; int password_len;
+	char *salt; int salt_len;
+	char *method; int method_len = 0;
+	unsigned char *out_buffer;
+
+	const EVP_MD *digest;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ssll|s",
+				&password, &password_len,
+				&salt, &salt_len,
+				&key_length, &iterations,
+				&method, &method_len) == FAILURE) {
+		return;
+	}
+
+	if (key_length <= 0 || key_length > INT_MAX) {
+		RETURN_FALSE;
+	}
+
+	if (method_len) {
+		digest = EVP_get_digestbyname(method);
+	} else {
+		digest = EVP_sha1();
+	}
+
+	if (!digest) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unknown signature algorithm");
+		RETURN_FALSE;
+	}
+
+	out_buffer = emalloc(key_length + 1);
+	out_buffer[key_length] = '\0';
+
+	if (PKCS5_PBKDF2_HMAC(password, password_len, (unsigned char *)salt, salt_len, iterations, digest, key_length, out_buffer) == 1) {
+		RETVAL_STRINGL((char *)out_buffer, key_length, 0);
+	} else {
+		efree(out_buffer);
+		RETURN_FALSE;
+	}
+}
+/* }}} */
+
+#endif
+
 /* {{{ PKCS7 S/MIME functions */
 
 /* {{{ proto bool openssl_pkcs7_verify(string filename, long flags [, string signerscerts [, array cainfo [, string extracerts [, string content]]]])
@@ -3384,7 +4404,7 @@
 	
 	RETVAL_LONG(-1);
 
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sl|sass", &filename, &filename_len,
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "pl|papp", &filename, &filename_len,
 				&flags, &signersfilename, &signersfilename_len, &cainfo,
 				&extracerts, &extracerts_len, &datafilename, &datafilename_len) == FAILURE) {
 		return;
@@ -3404,7 +4424,7 @@
 	if (!store) {
 		goto clean_exit;
 	}
-	if (php_openssl_safe_mode_chk(filename TSRMLS_CC)) {
+	if (php_openssl_open_base_dir_chk(filename TSRMLS_CC)) {
 		goto clean_exit;
 	}
 
@@ -3422,7 +4442,7 @@
 
 	if (datafilename) {
 
-		if (php_openssl_safe_mode_chk(datafilename TSRMLS_CC)) {
+		if (php_openssl_open_base_dir_chk(datafilename TSRMLS_CC)) {
 			goto clean_exit;
 		}
 
@@ -3442,7 +4462,7 @@
 		if (signersfilename) {
 			BIO *certout;
 		
-			if (php_openssl_safe_mode_chk(signersfilename TSRMLS_CC)) {
+			if (php_openssl_open_base_dir_chk(signersfilename TSRMLS_CC)) {
 				goto clean_exit;
 			}
 		
@@ -3497,19 +4517,12 @@
 	
 	RETVAL_FALSE;
 
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ssZa!|ll", &infilename, &infilename_len,
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ppZa!|ll", &infilename, &infilename_len,
 				&outfilename, &outfilename_len, &zrecipcerts, &zheaders, &flags, &cipherid) == FAILURE)
 		return;
 
-	if (strlen(infilename) != infilename_len) {
-		return;
-	}
-
-	if (strlen(outfilename) != outfilename_len) {
-		return;
-	}
-
-	if (php_openssl_safe_mode_chk(infilename TSRMLS_CC) || php_openssl_safe_mode_chk(outfilename TSRMLS_CC)) {
+	
+	if (php_openssl_open_base_dir_chk(infilename TSRMLS_CC) || php_openssl_open_base_dir_chk(outfilename TSRMLS_CC)) {
 		return;
 	}
 
@@ -3640,22 +4653,15 @@
 	char * outfilename;	int outfilename_len;
 	char * extracertsfilename = NULL; int extracertsfilename_len;
 
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ssZZa!|ls",
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ppZZa!|lp!",
 				&infilename, &infilename_len, &outfilename, &outfilename_len,
 				&zcert, &zprivkey, &zheaders, &flags, &extracertsfilename,
 				&extracertsfilename_len) == FAILURE) {
 		return;
 	}
+	
 	RETVAL_FALSE;
 
-	if (strlen(infilename) != infilename_len) {
-		return;
-	}
-
-	if (strlen(outfilename) != outfilename_len) {
-		return;
-	}
-
 	if (extracertsfilename) {
 		others = load_all_certs_from_file(extracertsfilename);
 		if (others == NULL) { 
@@ -3675,7 +4681,7 @@
 		goto clean_exit;
 	}
 
-	if (php_openssl_safe_mode_chk(infilename TSRMLS_CC) || php_openssl_safe_mode_chk(outfilename TSRMLS_CC)) {
+	if (php_openssl_open_base_dir_chk(infilename TSRMLS_CC) || php_openssl_open_base_dir_chk(outfilename TSRMLS_CC)) {
 		goto clean_exit;
 	}
 
@@ -3751,20 +4757,12 @@
 	char * infilename;	int infilename_len;
 	char * outfilename;	int outfilename_len;
 
-	RETVAL_FALSE;
-
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ssZ|Z", &infilename, &infilename_len,
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ppZ|Z", &infilename, &infilename_len,
 				&outfilename, &outfilename_len, &recipcert, &recipkey) == FAILURE) {
 		return;
 	}
 
-	if (strlen(infilename) != infilename_len) {
-		return;
-	}
-
-	if (strlen(outfilename) != outfilename_len) {
-		return;
-	}
+	RETVAL_FALSE;
 
 	cert = php_openssl_x509_from_zval(recipcert, 0, &certresval TSRMLS_CC);
 	if (cert == NULL) {
@@ -3778,7 +4776,7 @@
 		goto clean_exit;
 	}
 	
-	if (php_openssl_safe_mode_chk(infilename TSRMLS_CC) || php_openssl_safe_mode_chk(outfilename TSRMLS_CC)) {
+	if (php_openssl_open_base_dir_chk(infilename TSRMLS_CC) || php_openssl_open_base_dir_chk(outfilename TSRMLS_CC)) {
 		goto clean_exit;
 	}
 
@@ -3844,13 +4842,13 @@
 	cryptedlen = EVP_PKEY_size(pkey);
 	cryptedbuf = emalloc(cryptedlen + 1);
 
-	switch (pkey->type) {
+	switch (EVP_PKEY_id(pkey)) {
 		case EVP_PKEY_RSA:
 		case EVP_PKEY_RSA2:
 			successful =  (RSA_private_encrypt(data_len, 
 						(unsigned char *)data, 
 						cryptedbuf, 
-						pkey->pkey.rsa, 
+						EVP_PKEY_get0_RSA(pkey), 
 						padding) == cryptedlen);
 			break;
 		default:
@@ -3902,13 +4900,13 @@
 	cryptedlen = EVP_PKEY_size(pkey);
 	crypttemp = emalloc(cryptedlen + 1);
 
-	switch (pkey->type) {
+	switch (EVP_PKEY_id(pkey)) {
 		case EVP_PKEY_RSA:
 		case EVP_PKEY_RSA2:
 			cryptedlen = RSA_private_decrypt(data_len, 
 					(unsigned char *)data, 
 					crypttemp, 
-					pkey->pkey.rsa, 
+					EVP_PKEY_get0_RSA(pkey), 
 					padding);
 			if (cryptedlen != -1) {
 				cryptedbuf = emalloc(cryptedlen + 1);
@@ -3967,13 +4965,13 @@
 	cryptedlen = EVP_PKEY_size(pkey);
 	cryptedbuf = emalloc(cryptedlen + 1);
 
-	switch (pkey->type) {
+	switch (EVP_PKEY_id(pkey)) {
 		case EVP_PKEY_RSA:
 		case EVP_PKEY_RSA2:
 			successful = (RSA_public_encrypt(data_len, 
 						(unsigned char *)data, 
 						cryptedbuf, 
-						pkey->pkey.rsa, 
+						EVP_PKEY_get0_RSA(pkey), 
 						padding) == cryptedlen);
 			break;
 		default:
@@ -4026,13 +5024,13 @@
 	cryptedlen = EVP_PKEY_size(pkey);
 	crypttemp = emalloc(cryptedlen + 1);
 
-	switch (pkey->type) {
+	switch (EVP_PKEY_id(pkey)) {
 		case EVP_PKEY_RSA:
 		case EVP_PKEY_RSA2:
 			cryptedlen = RSA_public_decrypt(data_len, 
 					(unsigned char *)data, 
 					crypttemp, 
-					pkey->pkey.rsa, 
+					EVP_PKEY_get0_RSA(pkey), 
 					padding);
 			if (cryptedlen != -1) {
 				cryptedbuf = emalloc(cryptedlen + 1);
@@ -4096,7 +5094,7 @@
 	long keyresource = -1;
 	char * data;
 	int data_len;
-	EVP_MD_CTX md_ctx;
+	EVP_MD_CTX *md_ctx;
 	zval *method = NULL;
 	long signature_algo = OPENSSL_ALGO_SHA1;
 	const EVP_MD *mdtype;
@@ -4129,9 +5127,10 @@
 	siglen = EVP_PKEY_size(pkey);
 	sigbuf = emalloc(siglen + 1);
 
-	EVP_SignInit(&md_ctx, mdtype);
-	EVP_SignUpdate(&md_ctx, data, data_len);
-	if (EVP_SignFinal (&md_ctx, sigbuf,(unsigned int *)&siglen, pkey)) {
+	md_ctx = EVP_MD_CTX_create();
+	EVP_SignInit(md_ctx, mdtype);
+	EVP_SignUpdate(md_ctx, data, data_len);
+	if (EVP_SignFinal (md_ctx, sigbuf,(unsigned int *)&siglen, pkey)) {
 		zval_dtor(signature);
 		sigbuf[siglen] = '\0';
 		ZVAL_STRINGL(signature, (char *)sigbuf, siglen, 0);
@@ -4140,7 +5139,7 @@
 		efree(sigbuf);
 		RETVAL_FALSE;
 	}
-	EVP_MD_CTX_cleanup(&md_ctx);
+	EVP_MD_CTX_destroy(md_ctx);
 	if (keyresource == -1) {
 		EVP_PKEY_free(pkey);
 	}
@@ -4154,7 +5153,7 @@
 	zval **key;
 	EVP_PKEY *pkey;
 	int err;
-	EVP_MD_CTX     md_ctx;
+	EVP_MD_CTX     *md_ctx;
 	const EVP_MD *mdtype;
 	long keyresource = -1;
 	char * data;	int data_len;
@@ -4188,10 +5187,11 @@
 		RETURN_FALSE;
 	}
 
-	EVP_VerifyInit   (&md_ctx, mdtype);
-	EVP_VerifyUpdate (&md_ctx, data, data_len);
-	err = EVP_VerifyFinal (&md_ctx, (unsigned char *)signature, signature_len, pkey);
-	EVP_MD_CTX_cleanup(&md_ctx);
+	md_ctx = EVP_MD_CTX_create();
+	EVP_VerifyInit   (md_ctx, mdtype);
+	EVP_VerifyUpdate (md_ctx, data, data_len);
+	err = EVP_VerifyFinal (md_ctx, (unsigned char *)signature, signature_len, pkey);
+	EVP_MD_CTX_destroy(md_ctx);
 
 	if (keyresource == -1) {
 		EVP_PKEY_free(pkey);
@@ -4215,7 +5215,7 @@
 	char *method =NULL;
 	int method_len = 0;
 	const EVP_CIPHER *cipher;
-	EVP_CIPHER_CTX ctx;
+	EVP_CIPHER_CTX *ctx;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "szza/|s", &data, &data_len, &sealdata, &ekeys, &pubkeys, &method, &method_len) == FAILURE) {
 		return;
@@ -4234,6 +5234,10 @@
 			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unknown signature algorithm.");
 			RETURN_FALSE;
 		}
+		if (EVP_CIPHER_iv_length(cipher) > 0) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Ciphers with modes requiring IV are not supported");
+			RETURN_FALSE;
+		}
 	} else {
 		cipher = EVP_rc4();
 	}
@@ -4244,6 +5248,7 @@
 	memset(eks, 0, sizeof(*eks) * nkeys);
 	key_resources = safe_emalloc(nkeys, sizeof(long), 0);
 	memset(key_resources, 0, sizeof(*key_resources) * nkeys);
+	memset(pkeys, 0, sizeof(*pkeys) * nkeys);
 
 	/* get the public keys we are using to seal this data */
 	zend_hash_internal_pointer_reset_ex(pubkeysht, &pos);
@@ -4261,27 +5266,31 @@
 		i++;
 	}
 
-	if (!EVP_EncryptInit(&ctx,cipher,NULL,NULL)) {
+	ctx = EVP_CIPHER_CTX_new();
+	if (ctx == NULL || !EVP_EncryptInit(ctx,cipher,NULL,NULL)) {
 		RETVAL_FALSE;
+		EVP_CIPHER_CTX_free(ctx);
 		goto clean_exit;
 	}
 
 #if 0
 	/* Need this if allow ciphers that require initialization vector */
-	ivlen = EVP_CIPHER_CTX_iv_length(&ctx);
+	ivlen = EVP_CIPHER_CTX_iv_length(ctx);
 	iv = ivlen ? emalloc(ivlen + 1) : NULL;
 #endif
 	/* allocate one byte extra to make room for \0 */
-	buf = emalloc(data_len + EVP_CIPHER_CTX_block_size(&ctx));
+	buf = emalloc(data_len + EVP_CIPHER_CTX_block_size(ctx));
+	EVP_CIPHER_CTX_cleanup(ctx);
 
-	if (!EVP_SealInit(&ctx, cipher, eks, eksl, NULL, pkeys, nkeys) || !EVP_SealUpdate(&ctx, buf, &len1, (unsigned char *)data, data_len)) {
+	if (EVP_SealInit(ctx, cipher, eks, eksl, NULL, pkeys, nkeys) <= 0 ||
+			!EVP_SealUpdate(ctx, buf, &len1, (unsigned char *)data, data_len) ||
+			!EVP_SealFinal(ctx, buf + len1, &len2)) {
 		RETVAL_FALSE;
 		efree(buf);
+		EVP_CIPHER_CTX_free(ctx);
 		goto clean_exit;
 	}
 
-	EVP_SealFinal(&ctx, buf + len1, &len2);
-
 	if (len1 + len2 > 0) {
 		zval_dtor(sealdata);
 		buf[len1 + len2] = '\0';
@@ -4309,6 +5318,7 @@
 		efree(buf);
 	}
 	RETVAL_LONG(len1 + len2);
+	EVP_CIPHER_CTX_free(ctx);
 
 clean_exit:
 	for (i=0; i<nkeys; i++) {
@@ -4335,7 +5345,7 @@
 	int len1, len2;
 	unsigned char *buf;
 	long keyresource = -1;
-	EVP_CIPHER_CTX ctx;
+	EVP_CIPHER_CTX *ctx;
 	char * data;	int data_len;
 	char * ekey;	int ekey_len;
 	char *method =NULL;
@@ -4364,277 +5374,29 @@
 	
 	buf = emalloc(data_len + 1);
 
-	if (EVP_OpenInit(&ctx, cipher, (unsigned char *)ekey, ekey_len, NULL, pkey) && EVP_OpenUpdate(&ctx, buf, &len1, (unsigned char *)data, data_len)) {
-		if (!EVP_OpenFinal(&ctx, buf + len1, &len2) || (len1 + len2 == 0)) {
+	ctx = EVP_CIPHER_CTX_new();
+	if (EVP_OpenInit(ctx, cipher, (unsigned char *)ekey, ekey_len, NULL, pkey) && EVP_OpenUpdate(ctx, buf, &len1, (unsigned char *)data, data_len)) {
+		if (!EVP_OpenFinal(ctx, buf + len1, &len2) || (len1 + len2 == 0)) {
 			efree(buf);
-			if (keyresource == -1) { 
-				EVP_PKEY_free(pkey);
-			}
-			RETURN_FALSE;
+			RETVAL_FALSE;
+		} else {
+			zval_dtor(opendata);
+			buf[len1 + len2] = '\0';
+			ZVAL_STRINGL(opendata, erealloc(buf, len1 + len2 + 1), len1 + len2, 0);
+			RETVAL_TRUE;
 		}
 	} else {
 		efree(buf);
-		if (keyresource == -1) {
-			EVP_PKEY_free(pkey);
-		}
-		RETURN_FALSE;
+		RETVAL_FALSE;
 	}
 	if (keyresource == -1) {
 		EVP_PKEY_free(pkey);
 	}
-	zval_dtor(opendata);
-	buf[len1 + len2] = '\0';
-	ZVAL_STRINGL(opendata, erealloc(buf, len1 + len2 + 1), len1 + len2, 0);
-	RETURN_TRUE;
+	EVP_CIPHER_CTX_free(ctx);
 }
 /* }}} */
 
-/* SSL verification functions */
-
-#define GET_VER_OPT(name)               (stream->context && SUCCESS == php_stream_context_get_option(stream->context, "ssl", name, &val))
-#define GET_VER_OPT_STRING(name, str)   if (GET_VER_OPT(name)) { convert_to_string_ex(val); str = Z_STRVAL_PP(val); }
-
-static int verify_callback(int preverify_ok, X509_STORE_CTX *ctx) /* {{{ */
-{
-	php_stream *stream;
-	SSL *ssl;
-	X509 *err_cert;
-	int err, depth, ret;
-	zval **val;
-
-	ret = preverify_ok;
-
-	/* determine the status for the current cert */
-	err_cert = X509_STORE_CTX_get_current_cert(ctx);
-	err = X509_STORE_CTX_get_error(ctx);
-	depth = X509_STORE_CTX_get_error_depth(ctx);
-
-	/* conjure the stream & context to use */
-	ssl = X509_STORE_CTX_get_ex_data(ctx, SSL_get_ex_data_X509_STORE_CTX_idx());
-	stream = (php_stream*)SSL_get_ex_data(ssl, ssl_stream_data_index);
-
-	/* if allow_self_signed is set, make sure that verification succeeds */
-	if (err == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT && GET_VER_OPT("allow_self_signed") && zval_is_true(*val)) {
-		ret = 1;
-	}
-
-	/* check the depth */
-	if (GET_VER_OPT("verify_depth")) {
-		convert_to_long_ex(val);
-
-		if (depth > Z_LVAL_PP(val)) {
-			ret = 0;
-			X509_STORE_CTX_set_error(ctx, X509_V_ERR_CERT_CHAIN_TOO_LONG);
-		}
-	}
-
-	return ret;
 
-}
-/* }}} */
-
-int php_openssl_apply_verification_policy(SSL *ssl, X509 *peer, php_stream *stream TSRMLS_DC) /* {{{ */
-{
-	zval **val = NULL;
-	char *cnmatch = NULL;
-	X509_NAME *name;
-	char buf[1024];
-	int err;
-
-	/* verification is turned off */
-	if (!(GET_VER_OPT("verify_peer") && zval_is_true(*val))) {
-		return SUCCESS;
-	}
-
-	if (peer == NULL) {
-		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not get peer certificate");
-		return FAILURE;
-	}
-
-	err = SSL_get_verify_result(ssl);
-	switch (err) {
-		case X509_V_OK:
-			/* fine */
-			break;
-		case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
-			if (GET_VER_OPT("allow_self_signed") && zval_is_true(*val)) {
-				/* allowed */
-				break;
-			}
-			/* not allowed, so fall through */
-		default:
-			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not verify peer: code:%d %s", err, X509_verify_cert_error_string(err));
-			return FAILURE;
-	}
-
-	/* if the cert passed the usual checks, apply our own local policies now */
-
-	name = X509_get_subject_name(peer);
-
-	/* Does the common name match ? (used primarily for https://) */
-	GET_VER_OPT_STRING("CN_match", cnmatch);
-	if (cnmatch) {
-		int match = 0;
-		int name_len = X509_NAME_get_text_by_NID(name, NID_commonName, buf, sizeof(buf));
-
-		if (name_len == -1) {
-			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to locate peer certificate CN");
-			return FAILURE;
-		} else if (name_len != strlen(buf)) {
-			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Peer certificate CN=`%.*s' is malformed", name_len, buf);
-			return FAILURE;
-		}
-
-		match = strcmp(cnmatch, buf) == 0;
-		if (!match && strlen(buf) > 3 && buf[0] == '*' && buf[1] == '.') {
-			/* Try wildcard */
-
-			if (strchr(buf+2, '.')) {
-				char *tmp = strstr(cnmatch, buf+1);
-
-				match = tmp && strcmp(tmp, buf+2) && tmp == strchr(cnmatch, '.');
-			}
-		}
-
-		if (!match) {
-			/* didn't match */
-			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Peer certificate CN=`%.*s' did not match expected CN=`%s'", name_len, buf, cnmatch);
-			return FAILURE;
-		}
-	}
-
-	return SUCCESS;
-}
-/* }}} */
-
-static int passwd_callback(char *buf, int num, int verify, void *data) /* {{{ */
-{
-    php_stream *stream = (php_stream *)data;
-    zval **val = NULL;
-    char *passphrase = NULL;
-    /* TODO: could expand this to make a callback into PHP user-space */
-
-    GET_VER_OPT_STRING("passphrase", passphrase);
-
-    if (passphrase) {
-        if (Z_STRLEN_PP(val) < num - 1) {
-            memcpy(buf, Z_STRVAL_PP(val), Z_STRLEN_PP(val)+1);
-            return Z_STRLEN_PP(val);
-        }
-    }
-    return 0;
-}
-/* }}} */
-
-SSL *php_SSL_new_from_context(SSL_CTX *ctx, php_stream *stream TSRMLS_DC) /* {{{ */
-{
-	zval **val = NULL;
-	char *cafile = NULL;
-	char *capath = NULL;
-	char *certfile = NULL;
-	char *cipherlist = NULL;
-	int ok = 1;
-
-	ERR_clear_error();
-
-	/* look at context options in the stream and set appropriate verification flags */
-	if (GET_VER_OPT("verify_peer") && zval_is_true(*val)) {
-
-		/* turn on verification callback */
-		SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, verify_callback);
-
-		/* CA stuff */
-		GET_VER_OPT_STRING("cafile", cafile);
-		GET_VER_OPT_STRING("capath", capath);
-
-		if (cafile || capath) {
-			if (!SSL_CTX_load_verify_locations(ctx, cafile, capath)) {
-				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to set verify locations `%s' `%s'", cafile, capath);
-				return NULL;
-			}
-		}
-
-		if (GET_VER_OPT("verify_depth")) {
-			convert_to_long_ex(val);
-			SSL_CTX_set_verify_depth(ctx, Z_LVAL_PP(val));
-		}
-	} else {
-		SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);
-	}
-
-	/* callback for the passphrase (for localcert) */
-	if (GET_VER_OPT("passphrase")) {
-		SSL_CTX_set_default_passwd_cb_userdata(ctx, stream);
-		SSL_CTX_set_default_passwd_cb(ctx, passwd_callback);
-	}
-
-	GET_VER_OPT_STRING("ciphers", cipherlist);
-	if (!cipherlist) {
-		cipherlist = "DEFAULT";
-	}
-	if (SSL_CTX_set_cipher_list(ctx, cipherlist) != 1) {
-		return NULL;
-	}
-
-	GET_VER_OPT_STRING("local_cert", certfile);
-	if (certfile) {
-		X509 *cert = NULL;
-		EVP_PKEY *key = NULL;
-		SSL *tmpssl;
-		char resolved_path_buff[MAXPATHLEN];
-		const char * private_key = NULL;
-
-		if (VCWD_REALPATH(certfile, resolved_path_buff)) {
-			/* a certificate to use for authentication */
-			if (SSL_CTX_use_certificate_chain_file(ctx, resolved_path_buff) != 1) {
-				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to set local cert chain file `%s'; Check that your cafile/capath settings include details of your certificate and its issuer", certfile);
-				return NULL;
-			}
-			GET_VER_OPT_STRING("local_pk", private_key);
-
-			if (private_key) {
-				char resolved_path_buff_pk[MAXPATHLEN];
-				if (VCWD_REALPATH(private_key, resolved_path_buff_pk)) {
-					if (SSL_CTX_use_PrivateKey_file(ctx, resolved_path_buff_pk, SSL_FILETYPE_PEM) != 1) {
-						php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to set private key file `%s'", resolved_path_buff_pk);
-						return NULL;
-					}
-				}
-			} else {
-				if (SSL_CTX_use_PrivateKey_file(ctx, resolved_path_buff, SSL_FILETYPE_PEM) != 1) {
-					php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to set private key file `%s'", resolved_path_buff);
-					return NULL;
-				}		
-			}
-
-			tmpssl = SSL_new(ctx);
-			cert = SSL_get_certificate(tmpssl);
-
-			if (cert) {
-				key = X509_get_pubkey(cert);
-				EVP_PKEY_copy_parameters(key, SSL_get_privatekey(tmpssl));
-				EVP_PKEY_free(key);
-			}
-			SSL_free(tmpssl);
-
-			if (!SSL_CTX_check_private_key(ctx)) {
-				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Private key does not match certificate!");
-			}
-		}
-	}
-	if (ok) {
-		SSL *ssl = SSL_new(ctx);
-
-		if (ssl) {
-			/* map SSL => stream */
-			SSL_set_ex_data(ssl, ssl_stream_data_index, stream);
-		}
-		return ssl;
-	}
-
-	return NULL;
-}
-/* }}} */
 
 static void openssl_add_method_or_alias(const OBJ_NAME *name, void *arg) /* {{{ */
 {
@@ -4690,7 +5452,7 @@
 	char *data, *method;
 	int data_len, method_len;
 	const EVP_MD *mdtype;
-	EVP_MD_CTX md_ctx;
+	EVP_MD_CTX *md_ctx;
 	int siglen;
 	unsigned char *sigbuf;
 
@@ -4706,9 +5468,10 @@
 	siglen = EVP_MD_size(mdtype);
 	sigbuf = emalloc(siglen + 1);
 
-	EVP_DigestInit(&md_ctx, mdtype);
-	EVP_DigestUpdate(&md_ctx, (unsigned char *)data, data_len);
-	if (EVP_DigestFinal (&md_ctx, (unsigned char *)sigbuf, (unsigned int *)&siglen)) {
+	md_ctx = EVP_MD_CTX_create();
+	EVP_DigestInit(md_ctx, mdtype);
+	EVP_DigestUpdate(md_ctx, (unsigned char *)data, data_len);
+	if (EVP_DigestFinal (md_ctx, (unsigned char *)sigbuf, (unsigned int *)&siglen)) {
 		if (raw_output) {
 			sigbuf[siglen] = '\0';
 			RETVAL_STRINGL((char *)sigbuf, siglen, 0);
@@ -4724,6 +5487,8 @@
 		efree(sigbuf);
 		RETVAL_FALSE;
 	}
+
+	EVP_MD_CTX_destroy(md_ctx);
 }
 /* }}} */
 
@@ -4761,20 +5526,20 @@
 
 }
 
-/* {{{ proto string openssl_encrypt(string data, string method, string password [, bool raw_output=false [, string $iv='']])
+/* {{{ proto string openssl_encrypt(string data, string method, string password [, long options=0 [, string $iv='']])
    Encrypts given data with given method and key, returns raw or base64 encoded string */
 PHP_FUNCTION(openssl_encrypt)
 {
-	zend_bool raw_output = 0;
+	long options = 0;
 	char *data, *method, *password, *iv = "";
 	int data_len, method_len, password_len, iv_len = 0, max_iv_len;
 	const EVP_CIPHER *cipher_type;
-	EVP_CIPHER_CTX cipher_ctx;
-	int i = 0, outlen, keylen;
+	EVP_CIPHER_CTX *cipher_ctx;
+	int i=0, outlen, keylen;
 	unsigned char *outbuf, *key;
 	zend_bool free_iv;
 
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sss|bs", &data, &data_len, &method, &method_len, &password, &password_len, &raw_output, &iv, &iv_len) == FAILURE) {
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sss|ls", &data, &data_len, &method, &method_len, &password, &password_len, &options, &iv, &iv_len) == FAILURE) {
 		return;
 	}
 	cipher_type = EVP_get_cipherbyname(method);
@@ -4799,20 +5564,28 @@
 	free_iv = php_openssl_validate_iv(&iv, &iv_len, max_iv_len TSRMLS_CC);
 
 	outlen = data_len + EVP_CIPHER_block_size(cipher_type);
-	outbuf = emalloc(outlen + 1);
+	outbuf = safe_emalloc(outlen, 1, 1);
 
-	EVP_EncryptInit(&cipher_ctx, cipher_type, NULL, NULL);
+	cipher_ctx = EVP_CIPHER_CTX_new();
+	if (!cipher_ctx) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Failed to create cipher context");
+		RETURN_FALSE;
+	}
+	EVP_EncryptInit(cipher_ctx, cipher_type, NULL, NULL);
 	if (password_len > keylen) {
-		EVP_CIPHER_CTX_set_key_length(&cipher_ctx, password_len);
+		EVP_CIPHER_CTX_set_key_length(cipher_ctx, password_len);
+	}
+	EVP_EncryptInit_ex(cipher_ctx, NULL, NULL, key, (unsigned char *)iv);
+	if (options & OPENSSL_ZERO_PADDING) {
+		EVP_CIPHER_CTX_set_padding(cipher_ctx, 0);
 	}
-	EVP_EncryptInit_ex(&cipher_ctx, NULL, NULL, key, (unsigned char *)iv);
 	if (data_len > 0) {
-		EVP_EncryptUpdate(&cipher_ctx, outbuf, &i, (unsigned char *)data, data_len);
+		EVP_EncryptUpdate(cipher_ctx, outbuf, &i, (unsigned char *)data, data_len);
 	}
 	outlen = i;
-	if (EVP_EncryptFinal(&cipher_ctx, (unsigned char *)outbuf + i, &i)) {
+	if (EVP_EncryptFinal(cipher_ctx, (unsigned char *)outbuf + i, &i)) {
 		outlen += i;
-		if (raw_output) {
+		if (options & OPENSSL_RAW_DATA) {
 			outbuf[outlen] = '\0';
 			RETVAL_STRINGL((char *)outbuf, outlen, 0);
 		} else {
@@ -4821,7 +5594,11 @@
 
 			base64_str = (char*)php_base64_encode(outbuf, outlen, &base64_str_len);
 			efree(outbuf);
-			RETVAL_STRINGL(base64_str, base64_str_len, 0);
+			if (!base64_str) {
+				RETVAL_FALSE;
+			} else {
+				RETVAL_STRINGL(base64_str, base64_str_len, 0);
+			}
 		}
 	} else {
 		efree(outbuf);
@@ -4833,26 +5610,27 @@
 	if (free_iv) {
 		efree(iv);
 	}
-	EVP_CIPHER_CTX_cleanup(&cipher_ctx);
+	EVP_CIPHER_CTX_cleanup(cipher_ctx);
+	EVP_CIPHER_CTX_free(cipher_ctx);
 }
 /* }}} */
 
-/* {{{ proto string openssl_decrypt(string data, string method, string password [, bool raw_input=false [, string $iv = '']])
+/* {{{ proto string openssl_decrypt(string data, string method, string password [, long options=0 [, string $iv = '']])
    Takes raw or base64 encoded string and dectupt it using given method and key */
 PHP_FUNCTION(openssl_decrypt)
 {
-	zend_bool raw_input = 0;
+	long options = 0;
 	char *data, *method, *password, *iv = "";
 	int data_len, method_len, password_len, iv_len = 0;
 	const EVP_CIPHER *cipher_type;
-	EVP_CIPHER_CTX cipher_ctx;
+	EVP_CIPHER_CTX *cipher_ctx;
 	int i, outlen, keylen;
 	unsigned char *outbuf, *key;
 	int base64_str_len;
 	char *base64_str = NULL;
 	zend_bool free_iv;
 
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sss|bs", &data, &data_len, &method, &method_len, &password, &password_len, &raw_input, &iv, &iv_len) == FAILURE) {
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sss|ls", &data, &data_len, &method, &method_len, &password, &password_len, &options, &iv, &iv_len) == FAILURE) {
 		return;
 	}
 
@@ -4867,7 +5645,7 @@
 		RETURN_FALSE;
 	}
 
-	if (!raw_input) {
+	if (!(options & OPENSSL_RAW_DATA)) {
 		base64_str = (char*)php_base64_decode((unsigned char*)data, data_len, &base64_str_len);
 		if (!base64_str) {
 			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Failed to base64 decode the input");
@@ -4891,14 +5669,23 @@
 	outlen = data_len + EVP_CIPHER_block_size(cipher_type);
 	outbuf = emalloc(outlen + 1);
 
-	EVP_DecryptInit(&cipher_ctx, cipher_type, NULL, NULL);
+	cipher_ctx = EVP_CIPHER_CTX_new();
+	if (!cipher_ctx) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Failed to create cipher context");
+		RETURN_FALSE;
+	}
+
+	EVP_DecryptInit(cipher_ctx, cipher_type, NULL, NULL);
 	if (password_len > keylen) {
-		EVP_CIPHER_CTX_set_key_length(&cipher_ctx, password_len);
+		EVP_CIPHER_CTX_set_key_length(cipher_ctx, password_len);
+	}
+	EVP_DecryptInit_ex(cipher_ctx, NULL, NULL, key, (unsigned char *)iv);
+	if (options & OPENSSL_ZERO_PADDING) {
+		EVP_CIPHER_CTX_set_padding(cipher_ctx, 0);
 	}
-	EVP_DecryptInit_ex(&cipher_ctx, NULL, NULL, key, (unsigned char *)iv);
-	EVP_DecryptUpdate(&cipher_ctx, outbuf, &i, (unsigned char *)data, data_len);
+	EVP_DecryptUpdate(cipher_ctx, outbuf, &i, (unsigned char *)data, data_len);
 	outlen = i;
-	if (EVP_DecryptFinal(&cipher_ctx, (unsigned char *)outbuf + i, &i)) {
+	if (EVP_DecryptFinal(cipher_ctx, (unsigned char *)outbuf + i, &i)) {
 		outlen += i;
 		outbuf[outlen] = '\0';
 		RETVAL_STRINGL((char *)outbuf, outlen, 0);
@@ -4915,7 +5702,8 @@
 	if (base64_str) {
 		efree(base64_str);
 	}
- 	EVP_CIPHER_CTX_cleanup(&cipher_ctx);
+ 	EVP_CIPHER_CTX_cleanup(cipher_ctx);
+ 	EVP_CIPHER_CTX_free(cipher_ctx);
 }
 /* }}} */
 
@@ -4947,12 +5735,13 @@
 
 
 /* {{{ proto string openssl_dh_compute_key(string pub_key, resource dh_key)
-   Computes shared sicret for public value of remote DH key and local DH key */
+   Computes shared secret for public value of remote DH key and local DH key */
 PHP_FUNCTION(openssl_dh_compute_key)
 {
 	zval *key;
 	char *pub_str;
 	int pub_len;
+	DH *dh;
 	EVP_PKEY *pkey;
 	BIGNUM *pub;
 	char *data;
@@ -4962,14 +5751,21 @@
 		return;
 	}
 	ZEND_FETCH_RESOURCE(pkey, EVP_PKEY *, &key, -1, "OpenSSL key", le_key);
-	if (!pkey || EVP_PKEY_type(pkey->type) != EVP_PKEY_DH || !pkey->pkey.dh) {
+	if (pkey == NULL) {
+		RETURN_FALSE;
+	}
+	if (EVP_PKEY_base_id(pkey) != EVP_PKEY_DH) {
+		RETURN_FALSE;
+	}
+	dh = EVP_PKEY_get0_DH(pkey);
+	if (dh == NULL) {
 		RETURN_FALSE;
 	}
 
 	pub = BN_bin2bn((unsigned char*)pub_str, pub_len, NULL);
 
-	data = emalloc(DH_size(pkey->pkey.dh) + 1);
-	len = DH_compute_key((unsigned char*)data, pub, pkey->pkey.dh);
+	data = emalloc(DH_size(dh) + 1);
+	len = DH_compute_key((unsigned char*)data, pub, dh);
 
 	if (len >= 0) {
 		data[len] = 0;
@@ -4990,33 +5786,47 @@
 	long buffer_length;
 	unsigned char *buffer = NULL;
 	zval *zstrong_result_returned = NULL;
-	int strong_result = 0;
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "l|z", &buffer_length, &zstrong_result_returned) == FAILURE) {
 		return;
 	}
 
-	if (buffer_length <= 0) {
-		RETURN_FALSE;
-	}
-
 	if (zstrong_result_returned) {
 		zval_dtor(zstrong_result_returned);
 		ZVAL_BOOL(zstrong_result_returned, 0);
 	}
 
-	buffer = emalloc(buffer_length + 1);
+	if (buffer_length <= 0 || buffer_length > INT_MAX) {
+		RETURN_FALSE;
+	}
+
+	buffer = safe_emalloc(buffer_length, 1, 1);
 
-	if ((strong_result = RAND_pseudo_bytes(buffer, buffer_length)) < 0) {
+#ifdef PHP_WIN32
+	/* random/urandom equivalent on Windows */
+	if (php_win32_get_random_bytes(buffer, (size_t) buffer_length) == FAILURE){
+		efree(buffer);
+		if (zstrong_result_returned) {
+			ZVAL_BOOL(zstrong_result_returned, 0);
+		}
+		RETURN_FALSE;
+	}
+#else
+	PHP_OPENSSL_RAND_ADD_TIME();
+	if (RAND_bytes(buffer, buffer_length) <= 0) {
 		efree(buffer);
+		if (zstrong_result_returned) {
+			ZVAL_BOOL(zstrong_result_returned, 0);
+		}
 		RETURN_FALSE;
 	}
+#endif
 
 	buffer[buffer_length] = 0;
 	RETVAL_STRINGL((char *)buffer, buffer_length, 0);
 
 	if (zstrong_result_returned) {
-		ZVAL_BOOL(zstrong_result_returned, strong_result);
+		ZVAL_BOOL(zstrong_result_returned, 1);
 	}
 }
 /* }}} */
@@ -5029,3 +5839,4 @@
  * vim600: sw=4 ts=4 fdm=marker
  * vim<600: sw=4 ts=4
  */
+
diff -uNr php-5.3.29-ori/ext/openssl/php_openssl.h php-5.3.29/ext/openssl/php_openssl.h
--- php-5.3.29-ori/ext/openssl/php_openssl.h	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/php_openssl.h	2019-01-26 02:28:51.216128000 +0800
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | PHP Version 5                                                        |
    +----------------------------------------------------------------------+
-   | Copyright (c) 1997-2013 The PHP Group                                |
+   | Copyright (c) 1997-2016 The PHP Group                                |
    +----------------------------------------------------------------------+
    | This source file is subject to version 3.01 of the PHP license,      |
    | that is bundled with this package in the file LICENSE, and is        |
@@ -26,6 +26,23 @@
 extern zend_module_entry openssl_module_entry;
 #define phpext_openssl_ptr &openssl_module_entry
 
+#define OPENSSL_RAW_DATA 1
+#define OPENSSL_ZERO_PADDING 2
+
+#define OPENSSL_ERROR_X509_PRIVATE_KEY_VALUES_MISMATCH 0x0B080074
+
+/* Used for client-initiated handshake renegotiation DoS protection*/
+#define OPENSSL_DEFAULT_RENEG_LIMIT 2
+#define OPENSSL_DEFAULT_RENEG_WINDOW 300
+#define OPENSSL_DEFAULT_STREAM_VERIFY_DEPTH 9
+#define OPENSSL_DEFAULT_STREAM_CIPHERS "ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:" \
+	"ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:" \
+	"DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:" \
+	"ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:" \
+	"ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:" \
+	"DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:" \
+	"AES256-GCM-SHA384:AES128:AES256:HIGH:!SSLv2:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!RC4:!ADH"
+
 php_stream_transport_factory_func php_openssl_ssl_socket_factory;
 
 PHP_MINIT_FUNCTION(openssl);
@@ -49,6 +66,8 @@
 PHP_FUNCTION(openssl_public_encrypt);
 PHP_FUNCTION(openssl_public_decrypt);
 
+PHP_FUNCTION(openssl_pbkdf2);
+
 PHP_FUNCTION(openssl_pkcs7_verify);
 PHP_FUNCTION(openssl_pkcs7_decrypt);
 PHP_FUNCTION(openssl_pkcs7_sign);
@@ -61,6 +80,7 @@
 PHP_FUNCTION(openssl_x509_parse);
 PHP_FUNCTION(openssl_x509_checkpurpose);
 PHP_FUNCTION(openssl_x509_export);
+PHP_FUNCTION(openssl_x509_fingerprint);
 PHP_FUNCTION(openssl_x509_export_to_file);
 PHP_FUNCTION(openssl_x509_check_private_key);
 
@@ -74,6 +94,13 @@
 PHP_FUNCTION(openssl_csr_sign);
 PHP_FUNCTION(openssl_csr_get_subject);
 PHP_FUNCTION(openssl_csr_get_public_key);
+
+PHP_FUNCTION(openssl_spki_new);
+PHP_FUNCTION(openssl_spki_verify);
+PHP_FUNCTION(openssl_spki_export);
+PHP_FUNCTION(openssl_spki_export_challenge);
+
+PHP_FUNCTION(openssl_get_cert_locations);
 #else
 
 #define phpext_openssl_ptr NULL
diff -uNr php-5.3.29-ori/ext/openssl/tests/002.phpt php-5.3.29/ext/openssl/tests/002.phpt
--- php-5.3.29-ori/ext/openssl/tests/002.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/002.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,32 +0,0 @@
---TEST--
-openssl_seal() tests
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-
-$a = 1;
-$b = array(1);
-$c = array(1);
-$d = array(1);
-
-var_dump(openssl_seal($a, $b, $c, $d));
-var_dump(openssl_seal($a, $a, $a, array()));
-var_dump(openssl_seal($c, $c, $c, 1));
-var_dump(openssl_seal($b, $b, $b, ""));
-
-echo "Done\n";
-?>
---EXPECTF--	
-Warning: openssl_seal(): not a public key (1th member of pubkeys) in %s on line %d
-bool(false)
-
-Warning: openssl_seal(): Fourth argument to openssl_seal() must be a non-empty array in %s on line %d
-bool(false)
-
-Warning: openssl_seal() expects parameter 1 to be string, array given in %s on line %d
-NULL
-
-Warning: openssl_seal() expects parameter 1 to be string, array given in %s on line %d
-NULL
-Done
diff -uNr php-5.3.29-ori/ext/openssl/tests/003.phpt php-5.3.29/ext/openssl/tests/003.phpt
--- php-5.3.29-ori/ext/openssl/tests/003.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/003.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,43 +0,0 @@
---TEST--
-openssl_pkcs7_decrypt() and invalid parameters
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-
-function myErrorHandler($errno, $errstr, $errfile, $errline) {
-var_dump($errstr);
-} 
-set_error_handler("myErrorHandler"); 
-
-$a = 1; 
-$b = 1; 
-$c = new stdclass; 
-$d = new stdclass; 
-
-var_dump(openssl_pkcs7_decrypt($a, $b, $c, $d));
-var_dump($c);
-
-var_dump(openssl_pkcs7_decrypt($b, $b, $b, $b));
-var_dump(openssl_pkcs7_decrypt($a, $b, "", ""));
-var_dump(openssl_pkcs7_decrypt($a, $b, true, false));
-var_dump(openssl_pkcs7_decrypt($a, $b, 0, 0));
-
-echo "Done\n";
-?>
---EXPECTF--	
-string(57) "Object of class stdClass could not be converted to string"
-string(45) "Object of class stdClass to string conversion"
-string(66) "openssl_pkcs7_decrypt(): unable to coerce parameter 3 to x509 cert"
-bool(false)
-object(stdClass)#1 (0) {
-}
-string(66) "openssl_pkcs7_decrypt(): unable to coerce parameter 3 to x509 cert"
-bool(false)
-string(66) "openssl_pkcs7_decrypt(): unable to coerce parameter 3 to x509 cert"
-bool(false)
-string(66) "openssl_pkcs7_decrypt(): unable to coerce parameter 3 to x509 cert"
-bool(false)
-string(66) "openssl_pkcs7_decrypt(): unable to coerce parameter 3 to x509 cert"
-bool(false)
-Done
diff -uNr php-5.3.29-ori/ext/openssl/tests/004.phpt php-5.3.29/ext/openssl/tests/004.phpt
--- php-5.3.29-ori/ext/openssl/tests/004.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/004.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,34 +0,0 @@
---TEST--
-openssl_csr_new() tests
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-
-$a = 1;
-var_dump(openssl_csr_new(1,$a));
-var_dump(openssl_csr_new(1,$a,1,1));
-$a = array();
-var_dump(openssl_csr_new(array(), $a, array('config' => __DIR__ . DIRECTORY_SEPARATOR . 'openssl.cnf'), array()));
-
-//this leaks
-$a = array(1,2);
-$b = array(1,2);
-var_dump(openssl_csr_new($a, $b, array('config' => __DIR__ . DIRECTORY_SEPARATOR . 'openssl.cnf')));
-
-
-echo "Done\n";
-?>
---EXPECTF--	
-Warning: openssl_csr_new() expects parameter 1 to be array, integer given in %s on line %d
-NULL
-
-Warning: openssl_csr_new() expects parameter 1 to be array, integer given in %s on line %d
-NULL
-
-Warning: openssl_csr_new(): key array must be of the form array(0 => key, 1 => phrase) in %s on line %d
-
-Warning: openssl_csr_new(): add1_attr_by_txt challengePassword_min -> 4 (failed) in %s on line %d
-bool(false)
-resource(%d) of type (OpenSSL X.509 CSR)
-Done
diff -uNr php-5.3.29-ori/ext/openssl/tests/005.phpt php-5.3.29/ext/openssl/tests/005.phpt
--- php-5.3.29-ori/ext/openssl/tests/005.phpt	2019-01-25 02:38:50.308556347 +0800
+++ php-5.3.29/ext/openssl/tests/005.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,34 +0,0 @@
---TEST--
-openssl_csr_get_subject() tests
---SKIPIF--
-<?php 
-if (!extension_loaded("openssl")) die("skip"); 
-if (!function_exists("utf8_decode")) die("skip");
-?>
---FILE--
-<?php
-
-$csr = file_get_contents(dirname(__FILE__) . '/005_crt.txt');
-if ($out = openssl_csr_get_subject($csr, 1)) {
-	var_dump($out);
-}
-echo "\n";
-$cn = utf8_decode($out['CN']);
-var_dump($cn);
---EXPECTF--	
-array(6) {
-  ["C"]=>
-  string(2) "NL"
-  ["ST"]=>
-  string(13) "Noord Brabant"
-  ["L"]=>
-  string(4) "Uden"
-  ["O"]=>
-  string(10) "Triconnect"
-  ["OU"]=>
-  string(10) "Triconnect"
-  ["CN"]=>
-  string(15) "*.triconnect.nl"
-}
-
-string(15) "*.triconnect.nl"
diff -uNr php-5.3.29-ori/ext/openssl/tests/005_crt.txt php-5.3.29/ext/openssl/tests/005_crt.txt
--- php-5.3.29-ori/ext/openssl/tests/005_crt.txt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/005_crt.txt	1970-01-01 08:00:00.000000000 +0800
@@ -1,22 +0,0 @@
------BEGIN NEW CERTIFICATE REQUEST-----
-MIIDYzCCAswCAQAwgYcxCzAJBgNVBAYTAk5MMRYwFAYDVQQIEw1Ob29yZCBCcmFi
-YW50MQ0wCwYDVQQHEwRVZGVuMRMwEQYDVQQKEwpUcmljb25uZWN0MRMwEQYDVQQL
-EwpUcmljb25uZWN0MScwJQYDVQQDHh4AKgAuAHQAcgBpAGMAbwBuAG4AZQBjAHQA
-LgBuAGwwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBANjE/qKAKgo93162HhtX
-OZdvunF5eG/PFK2yn6uAUDWgZciPoKBslgL6a6sK+RdcS7LjWdjWEOOANGzZY1Kk
-FelzxrIjIGSGJHC9eubebdu2LWFFM5cEMDiH0QSD9Rdiy7svSLWvngUDYj0wwd+m
-iV2duzUFHnusj9iVPpD9s47RAgMBAAGgggGZMBoGCisGAQQBgjcNAgMxDBYKNS4y
-LjM3OTAuMjB7BgorBgEEAYI3AgEOMW0wazAOBgNVHQ8BAf8EBAMCBPAwRAYJKoZI
-hvcNAQkPBDcwNTAOBggqhkiG9w0DAgICAIAwDgYIKoZIhvcNAwQCAgCAMAcGBSsO
-AwIHMAoGCCqGSIb3DQMHMBMGA1UdJQQMMAoGCCsGAQUFBwMBMIH9BgorBgEEAYI3
-DQICMYHuMIHrAgEBHloATQBpAGMAcgBvAHMAbwBmAHQAIABSAFMAQQAgAFMAQwBo
-AGEAbgBuAGUAbAAgAEMAcgB5AHAAdABvAGcAcgBhAHAAaABpAGMAIABQAHIAbwB2
-AGkAZABlAHIDgYkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
-AAAAADANBgkqhkiG9w0BAQUFAAOBgQA4agiUkIblhF+n0wth4vQY+PwMadyaBpA4
-epr4TKL0QEkA0bQBbIERw5dDE3WQi6aVFJe6y870QymBwmKIvfBBfOyyA0IlQq/n
-uybhzQNQbSMKF1T82hpfh1w2RwVGaGrw7f6qH+CLyP1ydvBPvmD88HwiibNBBB3c
-R23mEEGYUQ==
------END NEW CERTIFICATE REQUEST-----
-
diff -uNr php-5.3.29-ori/ext/openssl/tests/006.phpt php-5.3.29/ext/openssl/tests/006.phpt
--- php-5.3.29-ori/ext/openssl/tests/006.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/006.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,25 +0,0 @@
---TEST--
-openssl_pkey_new() with an empty sub-array arg generates a malformed resource
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-/* openssl_pkey_get_details() segfaults when getting the information
-	from openssl_pkey_new() with an empty sub-array arg 		*/
-
-$rsa = array("rsa" => array());
-$dsa = array("dsa" => array());
-$dh = array("dh" => array());
-
-openssl_pkey_get_details(openssl_pkey_new($rsa));
-openssl_pkey_get_details(openssl_pkey_new($dsa));
-openssl_pkey_get_details(openssl_pkey_new($dh));
-?>
---EXPECTF--
-
-Warning: openssl_pkey_get_details() expects parameter 1 to be resource, boolean given in %s on line %d
-
-Warning: openssl_pkey_get_details() expects parameter 1 to be resource, boolean given in %s on line %d
-
-Warning: openssl_pkey_get_details() expects parameter 1 to be resource, boolean given in %s on line %d
-
diff -uNr php-5.3.29-ori/ext/openssl/tests/007.phpt php-5.3.29/ext/openssl/tests/007.phpt
--- php-5.3.29-ori/ext/openssl/tests/007.phpt	2019-01-25 02:38:50.308556347 +0800
+++ php-5.3.29/ext/openssl/tests/007.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,60 +0,0 @@
---TEST--
-openssl_x509_read() and openssl_x509_free() tests
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-$fp = fopen(dirname(__FILE__) . "/cert.crt","r");
-$a = fread($fp,8192);
-fclose($fp); 
-
-$b = "file://" . dirname(__FILE__) . "/cert.crt";
-$c = "invalid cert";
-$d = openssl_x509_read($a);
-$e = array();
-$f = array($b);
-
-var_dump($res = openssl_x509_read($a));         // read cert as a string
-openssl_x509_free($res);
-var_dump($res);
-var_dump($res = openssl_x509_read($b));         // read cert as a filename string
-openssl_x509_free($res);
-var_dump($res);
-var_dump($res = openssl_x509_read($c));         // read an invalid cert, fails
-openssl_x509_free($res);
-var_dump($res);
-var_dump($res = openssl_x509_read($d));         // read cert from a resource
-openssl_x509_free($res);
-var_dump($res);
-var_dump($res = openssl_x509_read($e));         // read an array
-openssl_x509_free($res);
-var_dump($res);
-var_dump($res = openssl_x509_read($f));         // read an array with the filename
-openssl_x509_free($res);
-var_dump($res);
-?>
---EXPECTF--
-resource(%d) of type (OpenSSL X.509)
-resource(%d) of type (Unknown)
-resource(%d) of type (OpenSSL X.509)
-resource(%d) of type (Unknown)
-
-Warning: openssl_x509_read(): supplied parameter cannot be coerced into an X509 certificate! in %s on line %d
-bool(false)
-
-Warning: openssl_x509_free() expects parameter 1 to be resource, boolean given in %s on line %d
-bool(false)
-resource(%d) of type (OpenSSL X.509)
-resource(%d) of type (Unknown)
-
-Warning: openssl_x509_read(): supplied parameter cannot be coerced into an X509 certificate! in %s on line %d
-bool(false)
-
-Warning: openssl_x509_free() expects parameter 1 to be resource, boolean given in %s on line %d
-bool(false)
-
-Warning: openssl_x509_read(): supplied parameter cannot be coerced into an X509 certificate! in %s on line %d
-bool(false)
-
-Warning: openssl_x509_free() expects parameter 1 to be resource, boolean given in %s on line %d
-bool(false)
diff -uNr php-5.3.29-ori/ext/openssl/tests/008.phpt php-5.3.29/ext/openssl/tests/008.phpt
--- php-5.3.29-ori/ext/openssl/tests/008.phpt	2019-01-25 02:38:50.308556347 +0800
+++ php-5.3.29/ext/openssl/tests/008.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,74 +0,0 @@
---TEST--
-openssl_x509_export() and openssl_x509_export_to_file() tests
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-$fp = fopen(dirname(__FILE__) . "/cert.crt","r");
-$a = fread($fp,8192);
-fclose($fp); 
-
-$b = "file://" . dirname(__FILE__) . "/cert.crt";
-$c = "invalid cert";
-$d = openssl_x509_read($a);
-$e = array();
-
-var_dump(openssl_x509_export($a, $output));	// read cert as a binary string
-var_dump(openssl_x509_export($b, $output2));	// read cert from a filename string
-var_dump(openssl_x509_export($c, $output3));	// read an invalid cert, fails
-var_dump(openssl_x509_export($d, $output4));	// read cert from a resource
-var_dump(openssl_x509_export($e, $output5));	// read an array, fails
-
-$outfilename = tempnam("/tmp", "ssl");
-if ($outfilename === false)
-        die("failed to get a temporary filename!");
-
-echo "---\n";
-
-var_dump(openssl_x509_export_to_file($a, $outfilename));      // read cert as a binary string
-var_dump(openssl_x509_export_to_file($b, $outfilename));      // read cert from a filename string
-var_dump(openssl_x509_export_to_file($c, $outfilename));      // read an invalid cert, fails
-var_dump(openssl_x509_export_to_file($d, $outfilename));      // read cert from a resource
-var_dump(openssl_x509_export_to_file($e, $outfilename));      // read an array, fails
-echo "---\n";
-
-var_dump($exists = file_exists($outfilename));
-if ($exists) {
-        @unlink($outfilename);
-}
-echo "---\n";
-
-var_dump(strcmp($output, $a));
-var_dump(strcmp($output, $output2));
-var_dump(strcmp($output, $output3));
-var_dump(strcmp($output, $output4));	// different
-var_dump(strcmp($output, $output5));	// different
-?>
---EXPECTF--
-bool(true)
-bool(true)
-
-Warning: openssl_x509_export(): cannot get cert from parameter 1 in %s on line %d
-bool(false)
-bool(true)
-
-Warning: openssl_x509_export(): cannot get cert from parameter 1 in %s on line %d
-bool(false)
----
-bool(true)
-bool(true)
-
-Warning: openssl_x509_export_to_file(): cannot get cert from parameter 1 in %s on line %d
-bool(false)
-bool(true)
-
-Warning: openssl_x509_export_to_file(): cannot get cert from parameter 1 in %s on line %d
-bool(false)
----
-bool(true)
----
-int(0)
-int(0)
-int(%d)
-int(0)
-int(%d)
diff -uNr php-5.3.29-ori/ext/openssl/tests/009.phpt php-5.3.29/ext/openssl/tests/009.phpt
--- php-5.3.29-ori/ext/openssl/tests/009.phpt	2019-01-25 02:38:50.308556347 +0800
+++ php-5.3.29/ext/openssl/tests/009.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,29 +0,0 @@
---TEST--
-openssl_x509_check_private_key() tests
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-$fp = fopen(dirname(__FILE__) . "/cert.crt","r");
-$a = fread($fp,8192);
-fclose($fp);
-
-$fp = fopen(dirname(__FILE__) . "/private.key","r");
-$b = fread($fp,8192);
-fclose($fp);
-
-$cert = "file://" . dirname(__FILE__) . "/cert.crt";
-$key = "file://" . dirname(__FILE__) . "/private.key";
-
-var_dump(openssl_x509_check_private_key($cert, $key));
-var_dump(openssl_x509_check_private_key("", $key));
-var_dump(openssl_x509_check_private_key($cert, ""));
-var_dump(openssl_x509_check_private_key("", ""));
-var_dump(openssl_x509_check_private_key($a, $b));
-?>
---EXPECT--
-bool(true)
-bool(false)
-bool(false)
-bool(false)
-bool(true)
diff -uNr php-5.3.29-ori/ext/openssl/tests/011.phpt php-5.3.29/ext/openssl/tests/011.phpt
--- php-5.3.29-ori/ext/openssl/tests/011.phpt	2019-01-25 02:38:50.308556347 +0800
+++ php-5.3.29/ext/openssl/tests/011.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,26 +0,0 @@
---TEST--
-openssl_encrypt() and openssl_decrypt() tests
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-$data = "openssl_encrypt() and openssl_decrypt() tests";
-$method = "AES-128-CBC";
-$password = "openssl";
-
-$ivlen = openssl_cipher_iv_length($method);
-$iv    = '';
-srand(time() + ((microtime(true) * 1000000) % 1000000));
-while(strlen($iv) < $ivlen) $iv .= chr(rand(0,255));
-
-$encrypted = openssl_encrypt($data, $method, $password, false, $iv);
-$output = openssl_decrypt($encrypted, $method, $password, false, $iv);
-var_dump($output);
-$encrypted = openssl_encrypt($data, $method, $password, true, $iv);
-$output = openssl_decrypt($encrypted, $method, $password, true, $iv);
-var_dump($output);
-?>
---EXPECT--
-string(45) "openssl_encrypt() and openssl_decrypt() tests"
-string(45) "openssl_encrypt() and openssl_decrypt() tests"
-
diff -uNr php-5.3.29-ori/ext/openssl/tests/012.phpt php-5.3.29/ext/openssl/tests/012.phpt
--- php-5.3.29-ori/ext/openssl/tests/012.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/012.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,27 +0,0 @@
---TEST--
-openssl_seal() error tests
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-$data = "openssl_open() test";
-$pub_key = "file://" . dirname(__FILE__) . "/public.key";
-$wrong = "wrong";
-
-openssl_seal($data, $sealed, $ekeys, array($pub_key));                  // no output
-openssl_seal($data, $sealed, $ekeys, array($pub_key, $pub_key));        // no output
-openssl_seal($data, $sealed, $ekeys, array($pub_key, $wrong));
-openssl_seal($data, $sealed, $ekeys, $pub_key);
-openssl_seal($data, $sealed, $ekeys, array());
-openssl_seal($data, $sealed, $ekeys, array($wrong));
-?>
---EXPECTF--
-
-Warning: openssl_seal(): not a public key (2th member of pubkeys) in %s on line %d
-
-Warning: openssl_seal() expects parameter 4 to be array, string given in %s on line %d
-
-Warning: openssl_seal(): Fourth argument to openssl_seal() must be a non-empty array in %s on line %d
-
-Warning: openssl_seal(): not a public key (1th member of pubkeys) in %s on line %d
-
diff -uNr php-5.3.29-ori/ext/openssl/tests/013.phpt php-5.3.29/ext/openssl/tests/013.phpt
--- php-5.3.29-ori/ext/openssl/tests/013.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/013.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,28 +0,0 @@
---TEST--
-openssl_open() tests
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-$data = "openssl_open() test";
-$pub_key = "file://" . dirname(__FILE__) . "/public.key";
-$priv_key = "file://" . dirname(__FILE__) . "/private.key";
-$wrong = "wrong";
-
-openssl_seal($data, $sealed, $ekeys, array($pub_key, $pub_key, $pub_key));
-openssl_open($sealed, $output, $ekeys[0], $priv_key);
-var_dump($output);
-openssl_open($sealed, $output2, $ekeys[1], $wrong);
-var_dump($output2);
-openssl_open($sealed, $output3, $ekeys[2], $priv_key);
-var_dump($output3);
-openssl_open($sealed, $output4, $wrong, $priv_key);
-var_dump($output4);
-?>
---EXPECTF--
-string(19) "openssl_open() test"
-
-Warning: openssl_open(): unable to coerce parameter 4 into a private key in %s on line %d
-NULL
-string(19) "openssl_open() test"
-NULL
diff -uNr php-5.3.29-ori/ext/openssl/tests/014.phpt php-5.3.29/ext/openssl/tests/014.phpt
--- php-5.3.29-ori/ext/openssl/tests/014.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/014.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,38 +0,0 @@
---TEST--
-openssl_private_encrypt() tests
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-$data = "Testing openssl_private_encrypt()";
-$privkey = "file://" . dirname(__FILE__) . "/private.key";
-$pubkey = "file://" . dirname(__FILE__) . "/public.key";
-$wrong = "wrong";
-class test {
-        function __toString() {
-                return "test";
-        }
-}
-$obj = new test;
-
-var_dump(openssl_private_encrypt($data, $encrypted, $privkey));
-var_dump(openssl_private_encrypt($data, $encrypted, $pubkey));
-var_dump(openssl_private_encrypt($data, $encrypted, $wrong));
-var_dump(openssl_private_encrypt($data, $encrypted, $obj));
-var_dump(openssl_private_encrypt($obj, $encrypted, $privkey));
-openssl_public_decrypt($encrypted, $output, $pubkey);
-var_dump($output);
-?>
---EXPECTF--
-bool(true)
-
-Warning: openssl_private_encrypt(): key param is not a valid private key in %s on line %d
-bool(false)
-
-Warning: openssl_private_encrypt(): key param is not a valid private key in %s on line %d
-bool(false)
-
-Warning: openssl_private_encrypt(): key param is not a valid private key in %s on line %d
-bool(false)
-bool(true)
-string(4) "test"
diff -uNr php-5.3.29-ori/ext/openssl/tests/015.phpt php-5.3.29/ext/openssl/tests/015.phpt
--- php-5.3.29-ori/ext/openssl/tests/015.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/015.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,39 +0,0 @@
---TEST--
-openssl_public_encrypt() tests
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-$data = "Testing openssl_public_encrypt()";
-$privkey = "file://" . dirname(__FILE__) . "/private.key";
-$pubkey = "file://" . dirname(__FILE__) . "/public.key";
-$wrong = "wrong";
-class test {
-        function __toString() {
-                return "test";
-        }
-}
-$obj = new test;
-
-var_dump(openssl_public_encrypt($data, $encrypted, $pubkey));
-var_dump(openssl_public_encrypt($data, $encrypted, $privkey));
-var_dump(openssl_public_encrypt($data, $encrypted, $wrong));
-var_dump(openssl_public_encrypt($data, $encrypted, $obj));
-var_dump(openssl_public_encrypt($obj, $encrypted, $pubkey));
-openssl_private_decrypt($encrypted, $output, $privkey);
-var_dump($output);
-?>
---EXPECTF--
-bool(true)
-
-Warning: openssl_public_encrypt(): key parameter is not a valid public key in %s on line %d
-bool(false)
-
-Warning: openssl_public_encrypt(): key parameter is not a valid public key in %s on line %d
-bool(false)
-
-Warning: openssl_public_encrypt(): key parameter is not a valid public key in %s on line %d
-bool(false)
-bool(true)
-string(4) "test"
-
diff -uNr php-5.3.29-ori/ext/openssl/tests/016.phpt php-5.3.29/ext/openssl/tests/016.phpt
--- php-5.3.29-ori/ext/openssl/tests/016.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/016.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,48 +0,0 @@
---TEST--
-openssl_public_decrypt() tests
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-$data = "Testing openssl_public_decrypt()";
-$privkey = "file://" . dirname(__FILE__) . "/private.key";
-$pubkey = "file://" . dirname(__FILE__) . "/public.key";
-$wrong = "wrong";
-
-openssl_private_encrypt($data, $encrypted, $privkey);
-var_dump(openssl_public_decrypt($encrypted, $output, $pubkey));
-var_dump($output);
-var_dump(openssl_public_decrypt($encrypted, $output2, $wrong));
-var_dump($output2);
-var_dump(openssl_public_decrypt($wrong, $output3, $pubkey));
-var_dump($output3);
-var_dump(openssl_public_decrypt($encrypted, $output4, array()));
-var_dump($output4);
-var_dump(openssl_public_decrypt($encrypted, $output5, array($pubkey)));
-var_dump($output5);
-var_dump(openssl_public_decrypt($encrypted, $output6, array($pubkey, "")));
-var_dump($output6);
-?>
---EXPECTF--
-bool(true)
-string(32) "Testing openssl_public_decrypt()"
-
-Warning: openssl_public_decrypt(): key parameter is not a valid public key in %s on line %d
-bool(false)
-NULL
-bool(false)
-NULL
-
-Warning: openssl_public_decrypt(): key array must be of the form array(0 => key, 1 => phrase) in %s on line %d
-
-Warning: openssl_public_decrypt(): key parameter is not a valid public key in %s on line %d
-bool(false)
-NULL
-
-Warning: openssl_public_decrypt(): key array must be of the form array(0 => key, 1 => phrase) in %s on line %d
-
-Warning: openssl_public_decrypt(): key parameter is not a valid public key in %s on line %d
-bool(false)
-NULL
-bool(true)
-string(32) "Testing openssl_public_decrypt()"
diff -uNr php-5.3.29-ori/ext/openssl/tests/017.phpt php-5.3.29/ext/openssl/tests/017.phpt
--- php-5.3.29-ori/ext/openssl/tests/017.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/017.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,40 +0,0 @@
---TEST--
-openssl_private_decrypt() tests
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-$data = "Testing openssl_public_decrypt()";
-$privkey = "file://" . dirname(__FILE__) . "/private.key";
-$pubkey = "file://" . dirname(__FILE__) . "/public.key";
-$wrong = "wrong";
-
-openssl_public_encrypt($data, $encrypted, $pubkey);
-var_dump(openssl_private_decrypt($encrypted, $output, $privkey));
-var_dump($output);
-var_dump(openssl_private_decrypt($encrypted, $output2, $wrong));
-var_dump($output2);
-var_dump(openssl_private_decrypt($wrong, $output3, $privkey));
-var_dump($output3);
-var_dump(openssl_private_decrypt($encrypted, $output4, array($privkey)));
-var_dump($output4);
-var_dump(openssl_private_decrypt($encrypted, $output5, array($privkey, "")));
-var_dump($output5);
-?>
---EXPECTF--
-bool(true)
-string(32) "Testing openssl_public_decrypt()"
-
-Warning: openssl_private_decrypt(): key parameter is not a valid private key in %s on line %d
-bool(false)
-NULL
-bool(false)
-NULL
-
-Warning: openssl_private_decrypt(): key array must be of the form array(0 => key, 1 => phrase) in %s on line %d
-
-Warning: openssl_private_decrypt(): key parameter is not a valid private key in %s on line %d
-bool(false)
-NULL
-bool(true)
-string(32) "Testing openssl_public_decrypt()"
diff -uNr php-5.3.29-ori/ext/openssl/tests/018.phpt php-5.3.29/ext/openssl/tests/018.phpt
--- php-5.3.29-ori/ext/openssl/tests/018.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/018.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,22 +0,0 @@
---TEST--
-openssl_sign() tests
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-$data = "Testing openssl_sign()";
-$privkey = "file://" . dirname(__FILE__) . "/private.key";
-$wrong = "wrong";
-
-var_dump(openssl_sign($data, $sign, $privkey));                 // no output
-var_dump(openssl_sign($data, $sign, $wrong));
-var_dump(openssl_sign(array(), $sign, $privkey));
-?>
---EXPECTF--	
-bool(true)
-
-Warning: openssl_sign(): supplied key param cannot be coerced into a private key in %s on line %d
-bool(false)
-
-Warning: openssl_sign() expects parameter 1 to be string, array given in %s on line %d
-NULL
diff -uNr php-5.3.29-ori/ext/openssl/tests/019.phpt php-5.3.29/ext/openssl/tests/019.phpt
--- php-5.3.29-ori/ext/openssl/tests/019.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/019.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,28 +0,0 @@
---TEST--
-openssl_verify() tests
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-$data = "Testing openssl_verify()";
-$privkey = "file://" . dirname(__FILE__) . "/private.key";
-$pubkey = "file://" . dirname(__FILE__) . "/public.key";
-$wrong = "wrong";
-
-openssl_sign($data, $sign, $privkey);
-var_dump(openssl_verify($data, $sign, $pubkey));
-var_dump(openssl_verify($data, $sign, $privkey));
-var_dump(openssl_verify($data, $sign, $wrong));
-var_dump(openssl_verify($data, $wrong, $pubkey));
-var_dump(openssl_verify($wrong, $sign, $pubkey));
-?>
---EXPECTF--
-int(1)
-
-Warning: openssl_verify(): supplied key param cannot be coerced into a public key in %s on line %d
-bool(false)
-
-Warning: openssl_verify(): supplied key param cannot be coerced into a public key in %s on line %d
-bool(false)
-int(0)
-int(0)
diff -uNr php-5.3.29-ori/ext/openssl/tests/021.phpt php-5.3.29/ext/openssl/tests/021.phpt
--- php-5.3.29-ori/ext/openssl/tests/021.phpt	2019-01-25 02:38:50.308556347 +0800
+++ php-5.3.29/ext/openssl/tests/021.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,80 +0,0 @@
---TEST--
-openssl_csr_sign() tests
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-$cert = "file://" . dirname(__FILE__) . "/cert.crt";
-$priv = "file://" . dirname(__FILE__) . "/private.key";
-$wrong = "wrong";
-$pub = "file://" . dirname(__FILE__) . "/public.key";
-$config = __DIR__ . DIRECTORY_SEPARATOR . 'openssl.cnf';
-$config_arg = array('config' => $config);
-
-$dn = array(
-	"countryName" => "BR",
-	"stateOrProvinceName" => "Rio Grande do Sul",
-	"localityName" => "Porto Alegre",
-	"commonName" => "Henrique do N. Angelo",
-	"emailAddress" => "hnangelo@php.net"
-	);
-
-$args = array(
-	"digest_alg" => "sha1",
-	"private_key_bits" => 2048,
-	"private_key_type" => OPENSSL_KEYTYPE_DSA,
-	"encrypt_key" => true,
-	"config" => $config
-	);
-
-$privkey = openssl_pkey_new($config_arg);
-$csr = openssl_csr_new($dn, $privkey, $args);
-var_dump(openssl_csr_sign($csr, null, $privkey, 365, $args));
-var_dump(openssl_csr_sign($csr, null, $privkey, 365, $config_arg));
-var_dump(openssl_csr_sign($csr, $cert, $priv, 365, $config_arg));
-var_dump(openssl_csr_sign($csr, $wrong, $privkey, 365));
-var_dump(openssl_csr_sign($csr, null, $wrong, 365));
-var_dump(openssl_csr_sign($csr, null, $privkey, $wrong));
-var_dump(openssl_csr_sign($csr, null, $privkey, 365, $wrong));
-var_dump(openssl_csr_sign($wrong, null, $privkey, 365));
-var_dump(openssl_csr_sign(array(), null, $privkey, 365));
-var_dump(openssl_csr_sign($csr, array(), $privkey, 365));
-var_dump(openssl_csr_sign($csr, null, array(), 365));
-var_dump(openssl_csr_sign($csr, null, $privkey, array()));
-var_dump(openssl_csr_sign($csr, null, $privkey, 365, $config_arg));
-?>
---EXPECTF--
-resource(%d) of type (OpenSSL X.509)
-resource(%d) of type (OpenSSL X.509)
-resource(%d) of type (OpenSSL X.509)
-
-Warning: openssl_csr_sign(): cannot get cert from parameter 2 in %s on line %d
-bool(false)
-
-Warning: openssl_csr_sign(): cannot get private key from parameter 3 in %s on line %d
-bool(false)
-
-Warning: openssl_csr_sign() expects parameter 4 to be long, string given in %s on line %d
-NULL
-
-Warning: openssl_csr_sign() expects parameter 5 to be array, string given in %s on line %d
-NULL
-
-Warning: openssl_csr_sign(): cannot get CSR from parameter 1 in %s on line %d
-bool(false)
-
-Warning: openssl_csr_sign(): cannot get CSR from parameter 1 in %s on line %d
-bool(false)
-
-Warning: openssl_csr_sign(): cannot get cert from parameter 2 in %s on line %d
-bool(false)
-
-Warning: openssl_csr_sign(): key array must be of the form array(0 => key, 1 => phrase) in %s on line %d
-
-Warning: openssl_csr_sign(): cannot get private key from parameter 3 in %s on line %d
-bool(false)
-
-Warning: openssl_csr_sign() expects parameter 4 to be long, array given in %s on line %d
-NULL
-resource(%d) of type (OpenSSL X.509)
-
diff -uNr php-5.3.29-ori/ext/openssl/tests/022.phpt php-5.3.29/ext/openssl/tests/022.phpt
--- php-5.3.29-ori/ext/openssl/tests/022.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/022.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,48 +0,0 @@
---TEST--
-openssl_csr_export() tests
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-$wrong = "wrong";
-$config = __DIR__ . DIRECTORY_SEPARATOR . 'openssl.cnf';
-$config_arg = array('config' => $config);
-
-$dn = array(
-	"countryName" => "BR",
-	"stateOrProvinceName" => "Rio Grande do Sul",
-	"localityName" => "Porto Alegre",
-	"commonName" => "Henrique do N. Angelo",
-	"emailAddress" => "hnangelo@php.net"
-	);
-
-$args = array(
-	"digest_alg" => "sha1",
-	"private_key_bits" => 2048,
-	"private_key_type" => OPENSSL_KEYTYPE_DSA,
-	"encrypt_key" => true,
-	"config" => $config,
-	);
-
-$privkey = openssl_pkey_new($config_arg);
-$csr = openssl_csr_new($dn, $privkey, $args);
-var_dump(openssl_csr_export($csr, $output));
-var_dump(openssl_csr_export($wrong, $output));
-var_dump(openssl_csr_export($privkey, $output));
-var_dump(openssl_csr_export(array(), $output));
-var_dump(openssl_csr_export($csr, $output, false));
-?>
---EXPECTF--
-bool(true)
-
-Warning: openssl_csr_export() expects parameter 1 to be resource, string given in %s on line %d
-NULL
-
-Warning: openssl_csr_export(): supplied resource is not a valid OpenSSL X.509 CSR resource in %s on line %d
-
-Warning: openssl_csr_export(): cannot get CSR from parameter 1 in %s on line %d
-bool(false)
-
-Warning: openssl_csr_export() expects parameter 1 to be resource, array given in %s on line %d
-NULL
-bool(true)
diff -uNr php-5.3.29-ori/ext/openssl/tests/023.phpt php-5.3.29/ext/openssl/tests/023.phpt
--- php-5.3.29-ori/ext/openssl/tests/023.phpt	2019-01-25 02:38:50.308556347 +0800
+++ php-5.3.29/ext/openssl/tests/023.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,64 +0,0 @@
---TEST--
-openssl_pkcs7_encrypt() tests
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-$infile = dirname(__FILE__) . "/cert.crt";
-$outfile = tempnam("/tmp", "ssl");
-if ($outfile === false)
-	die("failed to get a temporary filename!");
-$outfile2 = tempnam("/tmp", "ssl");
-if ($outfile2 === false)
-	die("failed to get a temporary filename!");
-
-$single_cert = "file://" . dirname(__FILE__) . "/cert.crt";
-$privkey = "file://" . dirname(__FILE__) . "/private.key";
-$multi_certs = array($single_cert, $single_cert);
-$assoc_headers = array("To" => "test@test", "Subject" => "testing openssl_pkcs7_encrypt()");
-$headers = array("test@test", "testing openssl_pkcs7_encrypt()");
-$empty_headers = array();
-$wrong = "wrong";
-$empty = "";
-
-var_dump(openssl_pkcs7_encrypt($infile, $outfile, $single_cert, $headers));
-var_dump(openssl_pkcs7_decrypt($outfile, $outfile2, $single_cert, $privkey));
-var_dump(openssl_pkcs7_encrypt($infile, $outfile, $single_cert, $assoc_headers));
-var_dump(openssl_pkcs7_encrypt($infile, $outfile, $single_cert, $empty_headers));
-var_dump(openssl_pkcs7_encrypt($infile, $outfile, $single_cert, $wrong));
-var_dump(openssl_pkcs7_encrypt($wrong, $outfile, $single_cert, $headers));
-var_dump(openssl_pkcs7_encrypt($empty, $outfile, $single_cert, $headers));
-var_dump(openssl_pkcs7_encrypt($infile, $empty, $single_cert, $headers));
-var_dump(openssl_pkcs7_encrypt($infile, $outfile, $wrong, $headers));
-var_dump(openssl_pkcs7_encrypt($infile, $outfile, $empty, $headers));
-var_dump(openssl_pkcs7_encrypt($infile, $outfile, $single_cert, $empty));
-var_dump(openssl_pkcs7_encrypt($infile, $outfile, $multi_certs, $headers));
-
-if (file_exists($outfile)) {
-	echo "true\n";
-	unlink($outfile);
-}
-if (file_exists($outfile2)) {
-	echo "true\n";
-	unlink($outfile2);
-}
-?>
---EXPECTF--
-bool(true)
-bool(true)
-bool(true)
-bool(true)
-
-Warning: openssl_pkcs7_encrypt() expects parameter 4 to be array, string given in %s on line %d
-bool(false)
-bool(false)
-bool(false)
-bool(false)
-bool(false)
-bool(false)
-
-Warning: openssl_pkcs7_encrypt() expects parameter 4 to be array, string given in %s on line %d
-bool(false)
-bool(true)
-true
-true
diff -uNr php-5.3.29-ori/ext/openssl/tests/024.phpt php-5.3.29/ext/openssl/tests/024.phpt
--- php-5.3.29-ori/ext/openssl/tests/024.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/024.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,64 +0,0 @@
---TEST--
-openssl_pkcs7_decrypt() tests
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-$infile = dirname(__FILE__) . "/cert.crt";
-$privkey = "file://" . dirname(__FILE__) . "/private.key";
-$encrypted = tempnam("/tmp", "ssl");
-if ($encrypted === false)
-	die("failed to get a temporary filename!");
-$outfile = tempnam("/tmp", "ssl");
-if ($outfile === false) {
-	unlink($outfile);
-	die("failed to get a temporary filename!");
-}
-
-$single_cert = "file://" . dirname(__FILE__) . "/cert.crt";
-$headers = array("test@test", "testing openssl_pkcs7_encrypt()");
-$wrong = "wrong";
-$empty = "";
-
-openssl_pkcs7_encrypt($infile, $encrypted, $single_cert, $headers);
-var_dump(openssl_pkcs7_decrypt($encrypted, $outfile, $single_cert, $privkey));
-var_dump(openssl_pkcs7_decrypt($encrypted, $outfile, $single_cert, $wrong));
-var_dump(openssl_pkcs7_decrypt($encrypted, $outfile, $wrong, $privkey));
-var_dump(openssl_pkcs7_decrypt($encrypted, $outfile, null, $privkey));
-var_dump(openssl_pkcs7_decrypt($wrong, $outfile, $single_cert, $privkey));
-var_dump(openssl_pkcs7_decrypt($empty, $outfile, $single_cert, $privkey));
-var_dump(openssl_pkcs7_decrypt($encrypted, $empty, $single_cert, $privkey));
-var_dump(openssl_pkcs7_decrypt($encrypted, $outfile, $empty, $privkey));
-var_dump(openssl_pkcs7_decrypt($encrypted, $outfile, $single_cert, $empty));
-
-if (file_exists($encrypted)) {
-	echo "true\n";
-	unlink($encrypted);
-}
-if (file_exists($outfile)) {
-	echo "true\n";
-	unlink($outfile);
-}
-?>
---EXPECTF--
-bool(true)
-
-Warning: openssl_pkcs7_decrypt(): unable to get private key in %s on line %d
-bool(false)
-
-Warning: openssl_pkcs7_decrypt(): unable to coerce parameter 3 to x509 cert in %s on line %d
-bool(false)
-
-Warning: openssl_pkcs7_decrypt(): unable to coerce parameter 3 to x509 cert in %s on line %d
-bool(false)
-bool(false)
-bool(false)
-bool(false)
-
-Warning: openssl_pkcs7_decrypt(): unable to coerce parameter 3 to x509 cert in %s on line %d
-bool(false)
-
-Warning: openssl_pkcs7_decrypt(): unable to get private key in %s on line %d
-bool(false)
-true
-true
diff -uNr php-5.3.29-ori/ext/openssl/tests/025.phpt php-5.3.29/ext/openssl/tests/025.phpt
--- php-5.3.29-ori/ext/openssl/tests/025.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/025.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,65 +0,0 @@
---TEST--
-openssl_pkcs7_sign() tests
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-$infile = dirname(__FILE__) . "/cert.crt";
-$outfile = tempnam("/tmp", "ssl");
-if ($outfile === false)
-	die("failed to get a temporary filename!");
-
-$privkey = "file://" . dirname(__FILE__) . "/private.key";
-$single_cert = "file://" . dirname(__FILE__) . "/cert.crt";
-$assoc_headers = array("To" => "test@test", "Subject" => "testing openssl_pkcs7_sign()");
-$headers = array("test@test", "testing openssl_pkcs7_sign()");
-$empty_headers = array();
-$wrong = "wrong";
-$empty = "";
-
-var_dump(openssl_pkcs7_sign($infile, $outfile, $single_cert, $privkey, $headers));
-var_dump(openssl_pkcs7_sign($infile, $outfile, $single_cert, $privkey, $assoc_headers));
-var_dump(openssl_pkcs7_sign($infile, $outfile, $single_cert, $privkey, $empty_headers));
-var_dump(openssl_pkcs7_sign($infile, $outfile, $single_cert, $privkey, $wrong));
-var_dump(openssl_pkcs7_sign($wrong, $outfile, $single_cert, $privkey, $headers));
-var_dump(openssl_pkcs7_sign($empty, $outfile, $single_cert, $privkey, $headers));
-var_dump(openssl_pkcs7_sign($infile, $empty, $single_cert, $privkey, $headers));
-var_dump(openssl_pkcs7_sign($infile, $outfile, $wrong, $privkey, $headers));
-var_dump(openssl_pkcs7_sign($infile, $outfile, $empty, $privkey, $headers));
-var_dump(openssl_pkcs7_sign($infile, $outfile, $single_cert, $privkey, $empty));
-var_dump(openssl_pkcs7_sign($infile, $outfile, $single_cert, $wrong, $headers));
-
-if (file_exists($outfile)) {
-	echo "true\n";
-	unlink($outfile);
-}
-?>
---EXPECTF--
-bool(true)
-bool(true)
-bool(true)
-
-Warning: openssl_pkcs7_sign() expects parameter 5 to be array, string given in %s on line %d
-NULL
-
-Warning: openssl_pkcs7_sign(): error opening input file %s in %s on line %d
-bool(false)
-
-Warning: openssl_pkcs7_sign(): error opening input file %s in %s on line %d
-bool(false)
-
-Warning: openssl_pkcs7_sign(): error opening output file %s in %s on line %d
-bool(false)
-
-Warning: openssl_pkcs7_sign(): error getting cert in %s on line %d
-bool(false)
-
-Warning: openssl_pkcs7_sign(): error getting cert in %s on line %d
-bool(false)
-
-Warning: openssl_pkcs7_sign() expects parameter 5 to be array, string given in %s on line %d
-NULL
-
-Warning: openssl_pkcs7_sign(): error getting private key in %s on line %d
-bool(false)
-true
diff -uNr php-5.3.29-ori/ext/openssl/tests/026.phpt php-5.3.29/ext/openssl/tests/026.phpt
--- php-5.3.29-ori/ext/openssl/tests/026.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/026.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,12 +0,0 @@
---TEST--
-Options type checks
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-$x = openssl_pkey_new();
-$csr = openssl_csr_new(["countryName" => "DE"], $x, ["x509_extensions" => 0xDEADBEEF]);
-?>
-DONE
---EXPECT--
-DONE
diff -uNr php-5.3.29-ori/ext/openssl/tests/74651.pem php-5.3.29/ext/openssl/tests/74651.pem
--- php-5.3.29-ori/ext/openssl/tests/74651.pem	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/74651.pem	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,27 @@
+-----BEGIN CERTIFICATE-----
+MIIEoDCCBAmgAwIBAgIBJzANBgkqhkiG9w0BAQQFADCBkDELMAkGA1UEFhMCUk8x
+EDAOBgNVBAgTB1JvbWFuaWExEDAOBgNVBAcTB0NyYWlvdmExDzANBgNVBAoTBlNl
+cmdpdTETMBEGA1UECxMKU2VyZ2l1IFNSTDESMBAGA1UEAxMJU2VyZ2l1IENBMSMw
+IQYJKoZIhvcNAQkBFhRuX3NlcmdpdUBob3RtYWlsLmNvbTAeFw0wNDA1MTQxMzM0
+NTZaFw0wNTA1MTQxMzM0NTZaMIGaMQswCQYDVQQGEwJSTzEQMA4GA1UECBMHUm9t
+YW5pYTEQMA4GA1UEBxMHQ3JhaW92YTETMBEGA1UEChMKU2VyZ2l1IFNSTDETMBEG
+A1UECxMKU2VyZ2l1IFNSTDEYMBYGA1UEAxMPU2VyZ2l1IHBlcnNvbmFsMSMwIQYJ
+KoZIhvcNAQkBFhRuX3NlcmdpdUBob3RtYWlsLmNvbTCBnzANBgkqhkiG9w0BAQEF
+AAOBjQAwgYkCgYEApNj7XXz8T8FcLIWpBniPYom3QcT6T7u0xRPHqtqzj5oboBYp
+DJe5d354/y0gJTpiLt8+fTrPgWXnbHm3pOHgXzTcX6Arani0GDU0/xDi4VkCRGcS
+YqX2sJpcDzAbmK9UDMt3xf/O1B8AJan3RfO0Bm3ozTEPziLMkmsiYr5b/L4CAwEA
+AaOCAfwwggH4MAkGA1UdEwQCMAAwNQYJYIZIAYb4QgENBCgWJkZvciBHcmlkIHVz
+ZSBvbmx5OyByZXF1ZXN0IHRhZyB1c2VyVGFnMBEGCWCGSAGG+EIBAQQEAwIF4DA/
+BgNVHR8EODA2MDSgMqAwhi5odHRwOi8vbW9iaWxlLmJsdWUtc29mdHdhcmUucm86
+OTAvY2EvY3JsLnNodG1sMDUGCWCGSAGG+EIBCAQoFiZodHRwOi8vbW9iaWxlLmJs
+dWUtc29mdHdhcmUucm86OTAvcHViLzAhBgNVHREEGjAYgRZzZXJnaXVAYmx1ZXNv
+ZnR3YXJlLnJvMB0GA1UdDgQWBBSwp//5QRXeIzm93TEPl6CyonTg/DCBpwYDVR0j
+BIGfMIGcoYGWpIGTMIGQMQswCQYDVQQGEwJSTzEQMA4GA1UECBMHUm9tYW5pYTEQ
+MA4GA1UEBxMHQ3JhaW92YTEPMA0GA1UEChMGU2VyZ2l1MRMwEQYDVQQLEwpTZXJn
+aXUgU1JMMRIwEAYDVQQDEwlTZXJnaXUgQ0ExIzAhBgkqhkiG9w0BCQEWFG5fc2Vy
+Z2l1QGhvdG1haWwuY29tggEAMAsGA1UdDwQEAwIE8DAjBglghkgBhvhCAQIEFhYU
+aHR0cDovLzYyLjIzMS45OC41Mi8wCwYDKgMEBAQ+52I0MA0GCSqGSIb3DQEBBAUA
+A4GBAIBIOJ+iiLyQfNJEY+IMefayQea0nmuXYY+F+L1DFjSC7xChytgYoPNnKkhh
+3dWPtxbswiqKYUnGi6y3Hi4UhDsOaDW29t2S305hSc2qgjOiNtRYQIVYQ8EHG1k7
+Fl63S7uCOhnVJt+4MnUK1N6/pwgsp+Z2GvEsDG1qCKnvNpf6
+-----END CERTIFICATE-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/ServerClientTestCase.inc php-5.3.29/ext/openssl/tests/ServerClientTestCase.inc
--- php-5.3.29-ori/ext/openssl/tests/ServerClientTestCase.inc	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/ServerClientTestCase.inc	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,109 @@
+<?php
+
+const WORKER_ARGV_VALUE = 'RUN_WORKER';
+
+function phpt_notify()
+{
+    ServerClientTestCase::getInstance()->notify();
+}
+
+function phpt_wait()
+{
+    ServerClientTestCase::getInstance()->wait();
+}
+
+/**
+ * This is a singleton to let the wait/notify functions work
+ * I know it's horrible, but it's a means to an end
+ */
+class ServerClientTestCase
+{
+    private $isWorker = false;
+
+    private $workerHandle;
+
+    private $workerStdIn;
+
+    private $workerStdOut;
+
+    private static $instance;
+
+    public static function getInstance($isWorker = false)
+    {
+        if (!isset(self::$instance)) {
+            self::$instance = new self($isWorker);
+        }
+
+        return self::$instance;
+    }
+
+    public function __construct($isWorker = false)
+    {
+        if (!isset(self::$instance)) {
+            self::$instance = $this;
+        }
+
+        $this->isWorker = $isWorker;
+    }
+
+    private function spawnWorkerProcess($code)
+    {
+        $cmd = sprintf('%s "%s" %s', PHP_BINARY, __FILE__, WORKER_ARGV_VALUE);
+
+        $this->workerHandle = proc_open($cmd, [['pipe', 'r'], ['pipe', 'w'], STDERR], $pipes);
+        $this->workerStdIn = $pipes[0];
+        $this->workerStdOut = $pipes[1];
+
+        fwrite($this->workerStdIn, $code . "\n---\n");
+    }
+
+    private function cleanupWorkerProcess()
+    {
+        fclose($this->workerStdIn);
+        fclose($this->workerStdOut);
+        proc_close($this->workerHandle);
+    }
+
+    private function stripPhpTagsFromCode($code)
+    {
+        return preg_replace('/^\s*<\?(?:php)?|\?>\s*$/i', '', $code);
+    }
+
+    public function runWorker()
+    {
+        $code = '';
+
+        while (1) {
+            $line = fgets(STDIN);
+
+            if (trim($line) === "---") {
+                break;
+            }
+
+            $code .= $line;
+        }
+
+        eval($code);
+    }
+
+    public function run($proc1Code, $proc2Code)
+    {
+        $this->spawnWorkerProcess($this->stripPhpTagsFromCode($proc2Code));
+        eval($this->stripPhpTagsFromCode($proc1Code));
+        $this->cleanupWorkerProcess();
+    }
+    
+    public function wait()
+    {
+        fgets($this->isWorker ? STDIN : $this->workerStdOut);
+    }
+
+    public function notify()
+    {
+        fwrite($this->isWorker ? STDOUT : $this->workerStdIn, "\n");
+    }
+}
+
+if (isset($argv[1]) && $argv[1] === WORKER_ARGV_VALUE) {
+    ServerClientTestCase::getInstance(true)->runWorker();
+}
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug41033.phpt php-5.3.29/ext/openssl/tests/bug41033.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug41033.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/bug41033.phpt	2019-01-26 11:29:19.967117841 +0800
@@ -13,11 +13,11 @@
 
 $prkeyid = openssl_get_privatekey($prv, "1234");
 $ct = "Hello I am some text!";
-openssl_sign($ct, $signature, $prkeyid, OPENSSL_ALGO_DSS1);
+openssl_sign($ct, $signature, $prkeyid, OPENSSL_VERSION_NUMBER < 0x10100000 ? OPENSSL_ALGO_DSS1 : OPENSSL_ALGO_SHA1);
 echo "Signature: ".base64_encode($signature) . "\n";
 
 $pukeyid = openssl_get_publickey($pub);
-$valid = openssl_verify($ct, $signature, $pukeyid, OPENSSL_ALGO_DSS1);
+$valid = openssl_verify($ct, $signature, $pukeyid, OPENSSL_VERSION_NUMBER < 0x10100000 ? OPENSSL_ALGO_DSS1 : OPENSSL_ALGO_SHA1);
 echo "Signature validity: " . $valid . "\n";
 
 
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug46127.phpt php-5.3.29/ext/openssl/tests/bug46127.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug46127.phpt	2019-01-25 02:38:50.308556347 +0800
+++ php-5.3.29/ext/openssl/tests/bug46127.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -2,57 +2,41 @@
 #46127, openssl_sign/verify: accept different algos 
 --SKIPIF--
 <?php 
-if (!extension_loaded("openssl")) die("skip, openssl required");
-if (!extension_loaded("pcntl")) die("skip, pcntl required");
-if (OPENSSL_VERSION_NUMBER < 0x009070af) die("skip");
-?>
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+if (OPENSSL_VERSION_NUMBER < 0x009070af) die("skip openssl version too low");
 --FILE--
 <?php
-
-function ssl_server($port) {
-	$pem = dirname(__FILE__) . '/bug46127.pem';
-	$ssl = array(
-			'verify_peer' => false,
-			'allow_self_signed' => true,
-			'local_cert' => $pem,
-			//		'passphrase' => '',
-		    );
-	$context = stream_context_create(array('ssl' => $ssl));
-	$sock = stream_socket_server('ssl://127.0.0.1:'.$port, $errno, $errstr, STREAM_SERVER_BIND | STREAM_SERVER_LISTEN, $context);
-	if (!$sock) return false;
-
-	$link = stream_socket_accept($sock);
-	if (!$link) return false; // bad link?
-
-	fputs($link, "Sending bug 46127\n");
-
-	// close stuff
-	fclose($link);
-	fclose($sock);
-
-	exit;
-}
-
-echo "Running bug46127\n";
-
-$port = rand(15000, 32000);
-
-$pid = pcntl_fork();
-if ($pid == 0) { // child
-	ssl_server($port);
-	exit;
-}
-
-// client or failed
-sleep(1);
-$sock = fsockopen('ssl://127.0.0.1', $port, $errno, $errstr);
-if (!$sock) exit;
-
-echo fgets($sock);
-
-pcntl_waitpid($pid, $status);
-
-?>
---EXPECTF--
-Running bug46127
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug46127.pem',
+    ]]);
+
+    $sock = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    $link = stream_socket_accept($sock);
+    fwrite($link, "Sending bug 46127\n");
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $clientFlags = STREAM_CLIENT_CONNECT;
+
+    $clientCtx = stream_context_create(['ssl' => [
+        'verify_peer' => false,
+        'verify_peer_name' => false
+    ]]);
+
+    phpt_wait();
+    $sock = stream_socket_client($serverUri, $errno, $errstr, 2, $clientFlags, $clientCtx);
+
+    echo fgets($sock);
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECT--
 Sending bug 46127
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug48182.phpt php-5.3.29/ext/openssl/tests/bug48182.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug48182.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/bug48182.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -1,91 +1,49 @@
 --TEST--
-#48182,ssl handshake fails during asynchronous socket connection
+Bug #48182: ssl handshake fails during asynchronous socket connection
 --SKIPIF--
 <?php 
-if (!extension_loaded("openssl")) die("skip, openssl required");
-if (!extension_loaded("pcntl")) die("skip, pcntl required");
-if (OPENSSL_VERSION_NUMBER < 0x009070af) die("skip");
-?>
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+if (OPENSSL_VERSION_NUMBER < 0x009070af) die("skip openssl version too low");
 --FILE--
 <?php
-
-function ssl_server($port) {
-	$host = 'ssl://127.0.0.1'.':'.$port;
-	$flags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
-	$data = "Sending bug48182\n";
-
-	$pem = dirname(__FILE__) . '/bug46127.pem';
-	$ssl_params = array( 'verify_peer' => false, 'allow_self_signed' => true, 'local_cert' => $pem);
-	$ssl = array('ssl' => $ssl_params);
-
-	$context = stream_context_create($ssl);
-	$sock = stream_socket_server($host, $errno, $errstr, $flags, $context);
-	if (!$sock) return false;
-
-	$link = stream_socket_accept($sock);
-	if (!$link) return false; // bad link?
-
-	$r = array($link);
-	$w = array();
-	$e = array();
-	if (stream_select($r, $w, $e, 1, 0) != 0)
-		$data .= fread($link, 8192);
-
-	$r = array();
-	$w = array($link);
-	if (stream_select($r, $w, $e, 1, 0) != 0)
-		$wrote = fwrite($link, $data, strlen($data));
-
-	// close stuff
-	fclose($link);
-	fclose($sock);
-
-	exit;
-}
-
-function ssl_async_client($port) {
-	$host = 'ssl://127.0.0.1'.':'.$port;
-	$flags = STREAM_CLIENT_CONNECT | STREAM_CLIENT_ASYNC_CONNECT;
-	$data = "Sending data over to SSL server in async mode with contents like Hello World\n";
-
-	$socket = stream_socket_client($host, $errno, $errstr, 10, $flags);
-	stream_set_blocking($socket, 0);
-
-	while ($socket && $data) {
-		$wrote = fwrite($socket, $data, strlen($data));
-		$data = substr($data, $wrote);
-	}
-
-	$r = array($socket);
-	$w = array();
-	$e = array();
-	if (stream_select($r, $w, $e, 1, 0) != 0) 
-	{
-		$data .= fread($socket, 1024);
-	}
-
-	echo "$data";
-
-	fclose($socket);
-}
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug54992.pem'
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    $client = @stream_socket_accept($server, 1);
+
+    $data = "Sending bug48182\n" . fread($client, 8192);
+    fwrite($client, $data);
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $clientFlags = STREAM_CLIENT_CONNECT | STREAM_CLIENT_ASYNC_CONNECT;
+    $clientCtx = stream_context_create(['ssl' => [
+        'cafile' => __DIR__ . '/bug54992-ca.pem',
+        'peer_name' => 'bug54992.local'
+    ]]);
+
+    phpt_wait();
+    $client = stream_socket_client($serverUri, $errno, $errstr, 10, $clientFlags, $clientCtx);
+
+    $data = "Sending data over to SSL server in async mode with contents like Hello World\n";
+
+    fwrite($client, $data);
+    echo fread($client, 1024);
+CODE;
 
 echo "Running bug48182\n";
 
-$port = rand(15000, 32000);
-
-$pid = pcntl_fork();
-if ($pid == 0) { // child
-	ssl_server($port);
-	exit;
-}
-
-// client or failed
-sleep(1);
-ssl_async_client($port);
-
-pcntl_waitpid($pid, $status);
-
-?>
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
 --EXPECTF--
 Running bug48182
 Sending bug48182
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug54060.phpt php-5.3.29/ext/openssl/tests/bug54060.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug54060.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/bug54060.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -10,7 +10,7 @@
 972439 8478942 yrhfjkdhls";
 $pass = "r23498rui324hjbnkj";
 
-openssl_encrypt($data, 'des3', $pass, false, '1qazxsw2');
+openssl_encrypt($data, 'des3', $pass, 0, '1qazxsw2');
 echo "Done";
 ?>
 --EXPECT--
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug54061.phpt php-5.3.29/ext/openssl/tests/bug54061.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug54061.phpt	2019-01-25 02:38:50.308556347 +0800
+++ php-5.3.29/ext/openssl/tests/bug54061.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -9,8 +9,8 @@
 972439 8478942 yrhfjkdhls";
 $pass = "r23498rui324hjbnkj";
 
-$cr = openssl_encrypt($data, 'des3', $pass, false, '1qazxsw2');
-$dcr = openssl_decrypt($cr, 'des3', $pass, false, '1qazxsw2');
+$cr = openssl_encrypt($data, 'des3', $pass, 0, '1qazxsw2');
+$dcr = openssl_decrypt($cr, 'des3', $pass, 0, '1qazxsw2');
 echo "Done";
 ?>
 --EXPECT--
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug54992.phpt php-5.3.29/ext/openssl/tests/bug54992.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug54992.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/bug54992.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -2,37 +2,40 @@
 Bug #54992: Stream not closed and error not returned when SSL CN_match fails
 --SKIPIF--
 <?php 
-if (!extension_loaded("openssl")) die("skip");
-if (!function_exists('pcntl_fork')) die("skip no fork");
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
 --FILE--
 <?php
-$context = stream_context_create();
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug54992.pem',
+    ]]);
 
-stream_context_set_option($context, 'ssl', 'local_cert', __DIR__ . "/bug54992.pem");
-stream_context_set_option($context, 'ssl', 'allow_self_signed', true);
-$server = stream_socket_server('ssl://127.0.0.1:64321', $errno, $errstr,
-	STREAM_SERVER_BIND|STREAM_SERVER_LISTEN, $context);
-
-
-$pid = pcntl_fork();
-if ($pid == -1) {
-	die('could not fork');
-} else if ($pid) {
-	$contextC = stream_context_create(
-		array(
-			'ssl' => array(
-				'verify_peer'		=> true,
-				'cafile'		=> __DIR__ . '/bug54992-ca.pem',
-				'CN_match'		=> 'buga_buga',
-			)
-		)
-	);
-	var_dump(stream_socket_client("ssl://127.0.0.1:64321", $errno, $errstr, 1,
-		STREAM_CLIENT_CONNECT, $contextC));
-} else {	
-	@pcntl_wait($status);
-	@stream_socket_accept($server, 1);
-}
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    @stream_socket_accept($server, 1);
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $clientFlags = STREAM_CLIENT_CONNECT;
+    $clientCtx = stream_context_create(['ssl' => [
+        'verify_peer' => true,
+        'cafile' => __DIR__ . '/bug54992-ca.pem',
+        'peer_name' => 'buga_buga',
+    ]]);
+
+    phpt_wait();
+    $client = stream_socket_client($serverUri, $errno, $errstr, 2, $clientFlags, $clientCtx);
+
+    var_dump($client);
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
 --EXPECTF--
 Warning: stream_socket_client(): Peer certificate CN=`bug54992.local' did not match expected CN=`buga_buga' in %s on line %d
 
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug55259.phpt php-5.3.29/ext/openssl/tests/bug55259.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug55259.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug55259.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,29 @@
+--TEST--
+Bug #55259 (openssl extension does not get the DH parameters from DH key resource)
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) die("skip"); ?>
+--FILE--
+<?php
+
+$phex = 'dcf93a0b883972ec0e19989ac5a2ce310e1d37717e8d9571bb7623731866e61e' .
+		'f75a2e27898b057f9891c2e27a639c3f29b60814581cd3b2ca3986d268370557' .
+		'7d45c2e7e52dc81c7a171876e5cea74b1448bfdfaf18828efd2519f14e45e382' .
+		'6634af1949e5b535cc829a483b8a76223e5d490a257f05bdff16f2fb22c583ab';
+$dh_details = array( 'p' => $phex, 'g' => '2' );
+$dh = openssl_pkey_new(array( 'dh'=> array( 'p' => $phex, 'g' => '2' )));
+var_dump($dh);
+$dh = openssl_pkey_new(array( 'dh'=> array( 'p' => hex2bin($phex), 'g' => '2' )));
+$details = openssl_pkey_get_details($dh);
+var_dump(bin2hex($details['dh']['p']));
+var_dump($details['dh']['g']);
+var_dump(strlen($details['dh']['pub_key']) > 0);
+var_dump(strlen($details['dh']['priv_key']) > 0);
+echo "Done";
+?>
+--EXPECT--
+bool(false)
+string(256) "dcf93a0b883972ec0e19989ac5a2ce310e1d37717e8d9571bb7623731866e61ef75a2e27898b057f9891c2e27a639c3f29b60814581cd3b2ca3986d2683705577d45c2e7e52dc81c7a171876e5cea74b1448bfdfaf18828efd2519f14e45e3826634af1949e5b535cc829a483b8a76223e5d490a257f05bdff16f2fb22c583ab"
+string(1) "2"
+bool(true)
+bool(true)
+Done
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug55646.phpt php-5.3.29/ext/openssl/tests/bug55646.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug55646.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug55646.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,38 @@
+--TEST--
+Bug #55646: textual input in openssl_csr_new() is not expected in UTF-8
+--SKIPIF--
+<?php
+if (!function_exists('openssl_csr_new'))
+	die('skip no openssl extension');
+--FILE--
+<?php
+function stringAsHex($string){$unpacked = unpack("H*", $string);return implode(" ", str_split($unpacked[1],2));}
+
+$config = array("digest_alg" => "sha1","x509_extensions" => "v3_ca","req_extensions" => "v3_req","private_key_bits" => 2048,"private_key_type" => OPENSSL_KEYTYPE_RSA,"encrypt_key" => false,);
+$csr_info = array(
+  "countryName" => "US",
+  "stateOrProvinceName" => "Utah",
+  "localityName" => "Lindon",
+  "organizationName" => "Chinese",
+  "organizationalUnitName" => "IT \xe4\xba\x92",
+  "commonName" => "www.example.com",);
+$private = openssl_pkey_new($config);
+while (openssl_error_string()) {}
+$csr_res = openssl_csr_new($csr_info, $private,
+	['config' => __DIR__."/openssl.cnf"]);
+if (!$csr_res) {
+	while ($e = openssl_error_string()) { $err = $e; }
+	die("Failed; last error: $err");
+}
+openssl_csr_export($csr_res, $csr);
+$output = openssl_csr_get_subject($csr);
+
+echo "A: ".$csr_info["organizationalUnitName"]."\n";
+echo "B: ".stringAsHex($csr_info["organizationalUnitName"])."\n";
+echo "C: ".$output['OU']."\n";
+echo "D: ".stringAsHex($output['OU'])."\n";
+--EXPECT--
+A: IT 
+B: 49 54 20 e4 ba 92
+C: IT 
+D: 49 54 20 e4 ba 92
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug60632.phpt php-5.3.29/ext/openssl/tests/bug60632.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug60632.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug60632.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,26 @@
+--TEST--
+Bug #60632: openssl_seal fails with AES
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+?>
+--FILE--
+<?php
+$pkey = openssl_pkey_new(array(
+	'digest_alg' => 'sha256',
+	'private_key_bits' => 1024,
+	'private_key_type' => OPENSSL_KEYTYPE_RSA,
+	'encrypt_key' => false,
+	'config' => __DIR__ . DIRECTORY_SEPARATOR . 'openssl.cnf',
+));
+$details = openssl_pkey_get_details($pkey);
+$test_pubkey = $details['key'];
+$pubkey = openssl_pkey_get_public($test_pubkey);
+$encrypted = null;
+$ekeys = array();
+$result = openssl_seal('test phrase', $encrypted, $ekeys, array($pubkey), 'AES-256-CBC');
+echo "Done";
+?>
+--EXPECTF--
+Warning: openssl_seal(): Ciphers with modes requiring IV are not supported in %s on line %d
+Done
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug61930.phpt php-5.3.29/ext/openssl/tests/bug61930.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug61930.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug61930.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,24 @@
+--TEST--
+Bug #61930: openssl corrupts ssl key resource when using openssl_get_publickey()
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip");
+?>
+--FILE--
+<?php
+$cert = file_get_contents(__DIR__.'/cert.crt');
+
+$data = <<<DATA
+Please verify me
+DATA;
+
+$sig = 'f9Gyb6NV/ENn7GUa37ygTLcF93XHf5fbFTnoYF/O+fXbq3iChGUbET0RuhOsptlAODi6JsDLnJO4ikcVZo0tC1fFTj3LyCuPy3ZdgJbbVxQ/rviROCmuMFTqUW/Xa2LQYiapeCCgLQeWTLg7TM/BoHEkKbKLG/XT5jHvep1758A=';
+
+$key = openssl_get_publickey($cert);
+var_dump(openssl_get_publickey($key));
+var_dump(openssl_verify($data, base64_decode($sig), $key));
+?>
+--EXPECTF--
+resource(%d) of type (OpenSSL key)
+int(1)
+
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug64802.pem php-5.3.29/ext/openssl/tests/bug64802.pem
--- php-5.3.29-ori/ext/openssl/tests/bug64802.pem	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug64802.pem	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,37 @@
+-----BEGIN CERTIFICATE-----
+MIIGfzCCBWegAwIBAgIQSVCinGH6MkvjJZjRyjK9nTANBgkqhkiG9w0BAQUFADCB
+jjELMAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4G
+A1UEBxMHU2FsZm9yZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxNDAyBgNV
+BAMTK0NPTU9ETyBFeHRlbmRlZCBWYWxpZGF0aW9uIFNlY3VyZSBTZXJ2ZXIgQ0Ew
+HhcNMTIwMjI5MDAwMDAwWhcNMTQwMjI4MjM1OTU5WjCCAW8xEjAQBgNVBAMTCXd3
+dy5yZC5pbzERMA8GA1UEAxMIcmRpby5jb20xDjAMBgNVBAMTBXJkLmlvMRUwEwYD
+VQQDEwxhcGkucmRpby5jb20xEjAQBgNVBAMTCWFwaS5yZC5pbzEQMA4GA1UEBRMH
+NDU4NjAwNzETMBEGCysGAQQBgjc8AgEDEwJVUzEZMBcGCysGAQQBgjc8AgECEwhE
+ZWxhd2FyZTEdMBsGA1UEDxMUUHJpdmF0ZSBPcmdhbml6YXRpb24xCzAJBgNVBAYT
+AlVTMQ4wDAYDVQQREwU5NDEwMzELMAkGA1UECBMCQ0ExFjAUBgNVBAcTDVNhbiBG
+cmFuY2lzY28xFzAVBgNVBAkTDjE1NTAgQnJ5YW50IHN0MRMwEQYDVQQKEwpSZGlv
+LCBJbmMuMSMwIQYDVQQLExpDT01PRE8gRVYgTXVsdGktRG9tYWluIFNTTDEVMBMG
+A1UEAxMMd3d3LnJkaW8uY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC
+AQEAt0AgYOe8EBJNVBAuSJFLKHRKZn0/ObCLBFG4xVH/5fb1rfYHBT1XSjjOqR3t
+iGC/A3esF8YC7TuHQcTLVephx0DtJv1ASxRg3zPM8ebBRsuul18N0W+sY1aNXpkd
+36quxvjg5UdBrAweuekJ7OTSZcCe2Ry/SKBeZSWWtkWsI4krCLv7JaKUwxw2h+Hn
+TAZSBLVxz/mixF0WYdepYwnq2Hm7XvvVEIQ7wxOQ9bA7iCevLojZOnb39BT2QII7
+cy8AB47RZdfYg7UwaO3bST2rauA4MKar7/Ozqc0aemNFpLatJfgv07cydiuj9fsd
+5aE/c8is8C9M9+7MmSMkcNEgGwIDAQABo4IB8zCCAe8wHwYDVR0jBBgwFoAUiERR
+/1AqaV4tiPQhutkM8s7L6nwwHQYDVR0OBBYEFCrYw8bfrYJ61NS2yYx6/CnhjzT4
+MA4GA1UdDwEB/wQEAwIFoDAMBgNVHRMBAf8EAjAAMB0GA1UdJQQWMBQGCCsGAQUF
+BwMBBggrBgEFBQcDAjBGBgNVHSAEPzA9MDsGDCsGAQQBsjEBAgEFATArMCkGCCsG
+AQUFBwIBFh1odHRwczovL3NlY3VyZS5jb21vZG8uY29tL0NQUzBTBgNVHR8ETDBK
+MEigRqBEhkJodHRwOi8vY3JsLmNvbW9kb2NhLmNvbS9DT01PRE9FeHRlbmRlZFZh
+bGlkYXRpb25TZWN1cmVTZXJ2ZXJDQS5jcmwwgYQGCCsGAQUFBwEBBHgwdjBOBggr
+BgEFBQcwAoZCaHR0cDovL2NydC5jb21vZG9jYS5jb20vQ09NT0RPRXh0ZW5kZWRW
+YWxpZGF0aW9uU2VjdXJlU2VydmVyQ0EuY3J0MCQGCCsGAQUFBzABhhhodHRwOi8v
+b2NzcC5jb21vZG9jYS5jb20wTAYDVR0RBEUwQ4IMd3d3LnJkaW8uY29tgglhcGku
+cmQuaW+CDGFwaS5yZGlvLmNvbYIFcmQuaW+CCHJkaW8uY29tggl3d3cucmQuaW8w
+DQYJKoZIhvcNAQEFBQADggEBAKFd4bPVFRyrlqIKPtrtMuqGqid6685ohxf0cv52
+sjdRYwLVTjnZOrmkDdNaF3R2A1ZlVMRN+67rK+qfY5sTeijFcudV3/i0PDtOFRwP
+6yYVD2uZmYkxfPiW309HPmDF+EzhxpVjWlTQEOwkfFLTmJmwl3Qu2Kffp8F1ENXW
+OTVNvj5VtMghvzu68PpzKl1VjlOR4Ej9NCwh1dUjNKEoTPzvpehXsIZ7jHSpX/T1
+wSSt9ckiechDdpgZXTzHgbxHNibK0Uhh+QhkBgYMj5F8qj5BlBhWAWqQa/VnEdmr
+Pfo7U+QmadoqQd7qt06hE2hG1nfZ0vPJDbWV3oVSwG2Yt7I=
+-----END CERTIFICATE-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug64802.phpt php-5.3.29/ext/openssl/tests/bug64802.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug64802.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug64802.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,28 @@
+--TEST--
+Bug #64802: openssl_x509_parse fails to parse subject properly in some cases
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip");
+if (!defined('OPENSSL_KEYTYPE_EC')) die("skip no EC available");
+?>
+--FILE--
+<?php
+$cert = file_get_contents(__DIR__.'/bug64802.pem');
+$r = openssl_x509_parse($cert,$use_short_names=false);
+var_dump($r['subject']['commonName']);
+?>
+--EXPECTF--
+array(6) {
+  [0]=>
+  string(9) "www.rd.io"
+  [1]=>
+  string(8) "rdio.com"
+  [2]=>
+  string(5) "rd.io"
+  [3]=>
+  string(12) "api.rdio.com"
+  [4]=>
+  string(9) "api.rd.io"
+  [5]=>
+  string(12) "www.rdio.com"
+}
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug65538.phar php-5.3.29/ext/openssl/tests/bug65538.phar
--- php-5.3.29-ori/ext/openssl/tests/bug65538.phar	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug65538.phar	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,336 @@
+<?php
+
+$web = 'index.php';
+
+if (in_array('phar', stream_get_wrappers()) && class_exists('Phar', 0)) {
+Phar::interceptFileFuncs();
+set_include_path('phar://' . __FILE__ . PATH_SEPARATOR . get_include_path());
+Phar::webPhar(null, $web);
+include 'phar://' . __FILE__ . '/' . Extract_Phar::START;
+return;
+}
+
+if (@(isset($_SERVER['REQUEST_URI']) && isset($_SERVER['REQUEST_METHOD']) && ($_SERVER['REQUEST_METHOD'] == 'GET' || $_SERVER['REQUEST_METHOD'] == 'POST'))) {
+Extract_Phar::go(true);
+$mimes = array(
+'phps' => 2,
+'c' => 'text/plain',
+'cc' => 'text/plain',
+'cpp' => 'text/plain',
+'c++' => 'text/plain',
+'dtd' => 'text/plain',
+'h' => 'text/plain',
+'log' => 'text/plain',
+'rng' => 'text/plain',
+'txt' => 'text/plain',
+'xsd' => 'text/plain',
+'php' => 1,
+'inc' => 1,
+'avi' => 'video/avi',
+'bmp' => 'image/bmp',
+'css' => 'text/css',
+'gif' => 'image/gif',
+'htm' => 'text/html',
+'html' => 'text/html',
+'htmls' => 'text/html',
+'ico' => 'image/x-ico',
+'jpe' => 'image/jpeg',
+'jpg' => 'image/jpeg',
+'jpeg' => 'image/jpeg',
+'js' => 'application/x-javascript',
+'midi' => 'audio/midi',
+'mid' => 'audio/midi',
+'mod' => 'audio/mod',
+'mov' => 'movie/quicktime',
+'mp3' => 'audio/mp3',
+'mpg' => 'video/mpeg',
+'mpeg' => 'video/mpeg',
+'pdf' => 'application/pdf',
+'png' => 'image/png',
+'swf' => 'application/shockwave-flash',
+'tif' => 'image/tiff',
+'tiff' => 'image/tiff',
+'wav' => 'audio/wav',
+'xbm' => 'image/xbm',
+'xml' => 'text/xml',
+);
+
+header("Cache-Control: no-cache, must-revalidate");
+header("Pragma: no-cache");
+
+$basename = basename(__FILE__);
+if (!strpos($_SERVER['REQUEST_URI'], $basename)) {
+chdir(Extract_Phar::$temp);
+include $web;
+return;
+}
+$pt = substr($_SERVER['REQUEST_URI'], strpos($_SERVER['REQUEST_URI'], $basename) + strlen($basename));
+if (!$pt || $pt == '/') {
+$pt = $web;
+header('HTTP/1.1 301 Moved Permanently');
+header('Location: ' . $_SERVER['REQUEST_URI'] . '/' . $pt);
+exit;
+}
+$a = realpath(Extract_Phar::$temp . DIRECTORY_SEPARATOR . $pt);
+if (!$a || strlen(dirname($a)) < strlen(Extract_Phar::$temp)) {
+header('HTTP/1.0 404 Not Found');
+echo "<html>\n <head>\n  <title>File Not Found<title>\n </head>\n <body>\n  <h1>404 - File ", $pt, " Not Found</h1>\n </body>\n</html>";
+exit;
+}
+$b = pathinfo($a);
+if (!isset($b['extension'])) {
+header('Content-Type: text/plain');
+header('Content-Length: ' . filesize($a));
+readfile($a);
+exit;
+}
+if (isset($mimes[$b['extension']])) {
+if ($mimes[$b['extension']] === 1) {
+include $a;
+exit;
+}
+if ($mimes[$b['extension']] === 2) {
+highlight_file($a);
+exit;
+}
+header('Content-Type: ' .$mimes[$b['extension']]);
+header('Content-Length: ' . filesize($a));
+readfile($a);
+exit;
+}
+}
+
+class Extract_Phar
+{
+static $temp;
+static $origdir;
+const GZ = 0x1000;
+const BZ2 = 0x2000;
+const MASK = 0x3000;
+const START = 'index.php';
+const LEN = 6685;
+
+static function go($return = false)
+{
+$fp = fopen(__FILE__, 'rb');
+fseek($fp, self::LEN);
+$L = unpack('V', $a = (binary)fread($fp, 4));
+$m = (binary)'';
+
+do {
+$read = 8192;
+if ($L[1] - strlen($m) < 8192) {
+$read = $L[1] - strlen($m);
+}
+$last = (binary)fread($fp, $read);
+$m .= $last;
+} while (strlen($last) && strlen($m) < $L[1]);
+
+if (strlen($m) < $L[1]) {
+die('ERROR: manifest length read was "' .
+strlen($m) .'" should be "' .
+$L[1] . '"');
+}
+
+$info = self::_unpack($m);
+$f = $info['c'];
+
+if ($f & self::GZ) {
+if (!function_exists('gzinflate')) {
+die('Error: zlib extension is not enabled -' .
+' gzinflate() function needed for zlib-compressed .phars');
+}
+}
+
+if ($f & self::BZ2) {
+if (!function_exists('bzdecompress')) {
+die('Error: bzip2 extension is not enabled -' .
+' bzdecompress() function needed for bz2-compressed .phars');
+}
+}
+
+$temp = self::tmpdir();
+
+if (!$temp || !is_writable($temp)) {
+$sessionpath = session_save_path();
+if (strpos ($sessionpath, ";") !== false)
+$sessionpath = substr ($sessionpath, strpos ($sessionpath, ";")+1);
+if (!file_exists($sessionpath) || !is_dir($sessionpath)) {
+die('Could not locate temporary directory to extract phar');
+}
+$temp = $sessionpath;
+}
+
+$temp .= '/pharextract/'.basename(__FILE__, '.phar');
+self::$temp = $temp;
+self::$origdir = getcwd();
+@mkdir($temp, 0777, true);
+$temp = realpath($temp);
+
+if (!file_exists($temp . DIRECTORY_SEPARATOR . md5_file(__FILE__))) {
+self::_removeTmpFiles($temp, getcwd());
+@mkdir($temp, 0777, true);
+@file_put_contents($temp . '/' . md5_file(__FILE__), '');
+
+foreach ($info['m'] as $path => $file) {
+$a = !file_exists(dirname($temp . '/' . $path));
+@mkdir(dirname($temp . '/' . $path), 0777, true);
+clearstatcache();
+
+if ($path[strlen($path) - 1] == '/') {
+@mkdir($temp . '/' . $path, 0777);
+} else {
+file_put_contents($temp . '/' . $path, self::extractFile($path, $file, $fp));
+@chmod($temp . '/' . $path, 0666);
+}
+}
+}
+
+chdir($temp);
+
+if (!$return) {
+include self::START;
+}
+}
+
+static function tmpdir()
+{
+if (strpos(PHP_OS, 'WIN') !== false) {
+if ($var = getenv('TMP') ? getenv('TMP') : getenv('TEMP')) {
+return $var;
+}
+if (is_dir('/temp') || mkdir('/temp')) {
+return realpath('/temp');
+}
+return false;
+}
+if ($var = getenv('TMPDIR')) {
+return $var;
+}
+return realpath('/tmp');
+}
+
+static function _unpack($m)
+{
+$info = unpack('V', substr($m, 0, 4));
+ $l = unpack('V', substr($m, 10, 4));
+$m = substr($m, 14 + $l[1]);
+$s = unpack('V', substr($m, 0, 4));
+$o = 0;
+$start = 4 + $s[1];
+$ret['c'] = 0;
+
+for ($i = 0; $i < $info[1]; $i++) {
+ $len = unpack('V', substr($m, $start, 4));
+$start += 4;
+ $savepath = substr($m, $start, $len[1]);
+$start += $len[1];
+   $ret['m'][$savepath] = array_values(unpack('Va/Vb/Vc/Vd/Ve/Vf', substr($m, $start, 24)));
+$ret['m'][$savepath][3] = sprintf('%u', $ret['m'][$savepath][3]
+& 0xffffffff);
+$ret['m'][$savepath][7] = $o;
+$o += $ret['m'][$savepath][2];
+$start += 24 + $ret['m'][$savepath][5];
+$ret['c'] |= $ret['m'][$savepath][4] & self::MASK;
+}
+return $ret;
+}
+
+static function extractFile($path, $entry, $fp)
+{
+$data = '';
+$c = $entry[2];
+
+while ($c) {
+if ($c < 8192) {
+$data .= @fread($fp, $c);
+$c = 0;
+} else {
+$c -= 8192;
+$data .= @fread($fp, 8192);
+}
+}
+
+if ($entry[4] & self::GZ) {
+$data = gzinflate($data);
+} elseif ($entry[4] & self::BZ2) {
+$data = bzdecompress($data);
+}
+
+if (strlen($data) != $entry[0]) {
+die("Invalid internal .phar file (size error " . strlen($data) . " != " .
+$stat[7] . ")");
+}
+
+if ($entry[3] != sprintf("%u", crc32((binary)$data) & 0xffffffff)) {
+die("Invalid internal .phar file (checksum error)");
+}
+
+return $data;
+}
+
+static function _removeTmpFiles($temp, $origdir)
+{
+chdir($temp);
+
+foreach (glob('*') as $f) {
+if (file_exists($f)) {
+is_dir($f) ? @rmdir($f) : @unlink($f);
+if (file_exists($f) && is_dir($f)) {
+self::_removeTmpFiles($f, getcwd());
+}
+}
+}
+
+@rmdir($temp);
+clearstatcache();
+chdir($origdir);
+}
+}
+
+Extract_Phar::go();
+__HALT_COMPILER(); ?>=                     bug54992-ca.pemB
+   SB
+  u/      -----BEGIN CERTIFICATE-----
+MIIHZzCCBU+gAwIBAgIBATANBgkqhkiG9w0BAQQFADCByzEpMCcGA1UEAxMgQ2F0
+YXBocmFjdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkxCzAJBgNVBAYTAlBUMQ8wDQYD
+VQQHEwZMaXNib2ExETAPBgNVBAgTCFBvcnR1Z2FsMSkwJwYDVQQKEyBDYXRhcGhy
+YWN0IENlcnRpZmljYXRlIEF1dGhvcml0eTEcMBoGA1UECxMTQ2VydGlmaWNhdGUg
+U2lnbmluZzEkMCIGCSqGSIb3DQEJARYVQ2F0YXBocmFjdEBuZXRjYWJvLnB0MB4X
+DTAzMTIwNTAwMTExOVoXDTE4MTIwMTAwMTExOVowgcsxKTAnBgNVBAMTIENhdGFw
+aHJhY3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5MQswCQYDVQQGEwJQVDEPMA0GA1UE
+BxMGTGlzYm9hMREwDwYDVQQIEwhQb3J0dWdhbDEpMCcGA1UEChMgQ2F0YXBocmFj
+dCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkxHDAaBgNVBAsTE0NlcnRpZmljYXRlIFNp
+Z25pbmcxJDAiBgkqhkiG9w0BCQEWFUNhdGFwaHJhY3RAbmV0Y2Fiby5wdDCCAiIw
+DQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANg+noZuxtWdxmZjxanJGEpzmDYu
+Uko9OHdmhVr3UU+z04a9JFT7aH5wuwrnpadNy1u9CqrSHVWFEtSmOMOH8QYzIy4C
+qCjFPSJR5UQjxpxTZeXaTvfhKI9n0LMSqc7I68HkP5MF64N3Z2cRdYvM4U6R5ERD
+Xw2LiRpii/+J2cezgi/Nw3vS4hZlWDWMkttfBd0HKSwxxN7OlPcjyzoTVhQgSISV
+Zvd3kwENTWD7s3EnnPRtMiW8Vzcjd8eSTCSjuGBG/8NnI44amLo7gSWocCJ2os69
+CJgiqMpp0tLT8cJm0mQUBk0o9gBS7l1GPpgq5fwWG+DmoLIHrKjxpuI5v2DW23gx
+yimXSyiD1GX0JLlTqZ+klM7Mv7ptnigRXA8F5f4GbVzBlGM1L1EERd8orsSmzPEA
+S6puHdlNzjcx00glp1UoAs6+tV39eW/fjiP493biPcar0pNO8QWfRSqPsgy6/qKN
+m7x2DoSdTbRgCalBMp57xYCUHIETZvlewGKnQD1Tj9FlbzvOnH6r52gj5U/5r3pn
+E4DshILn/qtdRwd/2Dwx/KSyBJznU7Yu0vEeMwQioZ6YFH1FnC4229lHYCN6ByVw
+UE7OMH7n0A8SUN8flxr2X7MmWpQsMrgVfrAjufmFwUaeIRq9X3wihDYw0MYP0brU
+x5ONmY+VA93gLdStAgMBAAGjggFSMIIBTjASBgNVHRMBAf8ECDAGAQH/AgEBMB0G
+A1UdDgQWBBQj+82/Y4YWpR8kIi0obJULkqmBwTCB+AYDVR0jBIHwMIHtgBQj+82/
+Y4YWpR8kIi0obJULkqmBwaGB0aSBzjCByzEpMCcGA1UEAxMgQ2F0YXBocmFjdCBD
+ZXJ0aWZpY2F0ZSBBdXRob3JpdHkxCzAJBgNVBAYTAlBUMQ8wDQYDVQQHEwZMaXNi
+b2ExETAPBgNVBAgTCFBvcnR1Z2FsMSkwJwYDVQQKEyBDYXRhcGhyYWN0IENlcnRp
+ZmljYXRlIEF1dGhvcml0eTEcMBoGA1UECxMTQ2VydGlmaWNhdGUgU2lnbmluZzEk
+MCIGCSqGSIb3DQEJARYVQ2F0YXBocmFjdEBuZXRjYWJvLnB0ggEBMAsGA1UdDwQE
+AwIBBjARBglghkgBhvhCAQEEBAMCAAcwDQYJKoZIhvcNAQEEBQADggIBAKN6pRY1
+8GwQx378ukmw4pzvODlee5IKSPRT92hfLKNGNUAMu2LFo+bjItpilhSvR4aklRvh
+5RBoVE8ejEdZXsz0HobMUUcL9IemaRwBCWHPii7Y3zX2J1FUiS/KmWhrYvw5hb1P
+P83f/kxdWhxD+MbwuGc2I/6WgfsRyzevQsxdJgElQvNGkOXsC56pEXm2ChVoLbZL
+sZX0zPa5ZzXByQGwXl9eqOkV7fdNKulJPcLPOs/y1cAfcxXrDYHpqBGf9nb14p3C
+NaWXFhvq9Khk/QiWKSO4QarPlYS4H0Sl6tp7zBaE+dZHAjci2mSTraUf7q61kqoJ
+g/ZA3qupd1rR67NzN+6x/TJmIq0G3GUxnDNNqNAHvS4YJx8g4Ji0F3Qoz3CgKnc4
+HsneYQ/LCLq2pDjsffnLI88MBGbfHZDjdj2nowwX76W/6PPutD5IR/kOmHEaX1TJ
+/Ff99bVV4HwNF3GPwmKPmHpw3hB9A/xG9aiQRcYs0reXoYeQ+8nyCGmu41LweFyV
+1WVwWJ/MHgdtzJZHdPjeXKMWQzOx3AS3TCc31oi4IEo4NgNigcuvl0qgUcwDRXBI
+HZm4f7npm7xiES8BSoq5PIVCj8EXJd4b7Gk6dHGJGO+APaw3kYKqfqg5+AN1e4a5
+x3onNvWhjcwDGgcs/xAfVJIUucEqpC5h0pZq
+-----END CERTIFICATE-----
+K;.ej#cS'   GBMB
\ No newline at end of file
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug65538_001.phpt php-5.3.29/ext/openssl/tests/bug65538_001.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug65538_001.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug65538_001.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,52 @@
+--TEST--
+Bug #65538: SSL context "cafile" supports stream wrappers
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug54992.pem',
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    $client = @stream_socket_accept($server);
+    if ($client) {
+        $in = '';
+        while (!preg_match('/\r?\n\r?\n/', $in)) {
+            $in .= fread($client, 2048);
+        }
+        $response = "HTTP/1.0 200 OK\r\n"
+                  . "Content-Type: text/plain\r\n"
+                  . "Content-Length: 12\r\n"
+                  . "Connection: close\r\n"
+                  . "\r\n"
+                  . "Hello World!";
+        fwrite($client, $response);
+        fclose($client);
+    }
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "https://127.0.0.1:64321/";
+    $clientCtx = stream_context_create(['ssl' => [
+        'cafile' => 'file://' . __DIR__ . '/bug54992-ca.pem',
+        'peer_name' => 'bug54992.local',
+    ]]);
+
+    phpt_wait();
+    $html = file_get_contents($serverUri, false, $clientCtx);
+
+    var_dump($html);
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECT--
+string(12) "Hello World!"
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug65538_002.phpt php-5.3.29/ext/openssl/tests/bug65538_002.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug65538_002.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug65538_002.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,18 @@
+--TEST--
+Bug #65538: SSL context "cafile" disallows URL stream wrappers
+--SKIPIF--
+<?php
+if (!extension_loaded('openssl')) die('skip, openssl required');
+if (getenv("SKIP_ONLINE_TESTS")) die("skip online test");
+--FILE--
+<?php
+$clientCtx = stream_context_create(['ssl' => [
+    'cafile' => 'http://curl.haxx.se/ca/cacert.pem'
+]]);
+file_get_contents('https://github.com', false, $clientCtx);
+--EXPECTF--
+Warning: remote cafile streams are disabled for security purposes in %s on line %d
+
+Warning: file_get_contents(): Failed to enable crypto in %s on line %d
+
+Warning: file_get_contents(%s): failed to open stream: operation failed in %s on line %d
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug65538_003.phpt php-5.3.29/ext/openssl/tests/bug65538_003.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug65538_003.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug65538_003.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,53 @@
+--TEST--
+Bug #65538: SSL context "cafile" supports phar wrapper
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!extension_loaded("phar")) die("skip phar not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug54992.pem',
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    $client = @stream_socket_accept($server);
+    if ($client) {
+        $in = '';
+        while (!preg_match('/\r?\n\r?\n/', $in)) {
+            $in .= fread($client, 2048);
+        }
+        $response = "HTTP/1.0 200 OK\r\n"
+                  . "Content-Type: text/plain\r\n"
+                  . "Content-Length: 12\r\n"
+                  . "Connection: close\r\n"
+                  . "\r\n"
+                  . "Hello World!";
+        fwrite($client, $response);
+        fclose($client);
+    }
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "https://127.0.0.1:64321/";
+    $clientCtx = stream_context_create(['ssl' => [
+        'cafile' => 'phar://' . __DIR__ . '/bug65538.phar/bug54992-ca.pem',
+        'peer_name' => 'bug54992.local',
+    ]]);
+
+    phpt_wait();
+    $html = file_get_contents($serverUri, false, $clientCtx);
+
+    var_dump($html);
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+string(12) "Hello World!"
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug65698.crt php-5.3.29/ext/openssl/tests/bug65698.crt
--- php-5.3.29-ori/ext/openssl/tests/bug65698.crt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug65698.crt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,28 @@
+-----BEGIN CERTIFICATE-----
+MIIEsTCCA5mgAwIBAgIQdwrGwrpRpBwdXS+ZsmsMGjANBgkqhkiG9w0BAQUFADA+
+MQswCQYDVQQGEwJQTDEbMBkGA1UEChMSVW5pemV0byBTcC4geiBvLm8uMRIwEAYD
+VQQDEwlDZXJ0dW0gQ0EwIhgPMjAwOTAzMDMxMjUzMThaGA8yMDI0MDMwMzEyNTMx
+OFowdzELMAkGA1UEBhMCUEwxIjAgBgNVBAoTGVVuaXpldG8gVGVjaG5vbG9naWVz
+IFMuQS4xJzAlBgNVBAsTHkNlcnR1bSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTEb
+MBkGA1UEAxMSQ2VydHVtIExldmVsIElJIENBMIIBIjANBgkqhkiG9w0BAQEFAAOC
+AQ8AMIIBCgKCAQEA4LE0Ixw8h5Lper9tHVtZkWIujxYsPVgUZABeZZgQsKTdJjaG
+VP64B/oiEV5Hd3AxRqaZ7dRRsf4Pg/PSS/2mHRQQ/SH3XACbrDHmucDvYgtU/WoZ
+yp9d6PXVPY4j7J5t/52s+EbZD5swSuQLGjZ9iwg9sXX3JdJ9Ty+B3z80oiajpK0B
+wqAxrcX3DekEOknj7LkAOK6iuQKI85REj4IVb9kD7KKIWdISGbfL4Ezh/TP51e0L
+/WhTJ7lHbHbRzFfPU/oi3Qyt5tEexrPKe+6N+Jrejdb5Ya7Ne3tKujDU7KlbO+dn
+pzFH7VHkBPJcQJ7QUrprPaqVsVg3JJ1PXTqVnwIDAQABo4IBbDCCAWgwDwYDVR0T
+AQH/BAUwAwEB/zAdBgNVHQ4EFgQUgGIR3sBrpxDhCPBVtDCDv/qPCGAwUgYDVR0j
+BEswSaFCpEAwPjELMAkGA1UEBhMCUEwxGzAZBgNVBAoTElVuaXpldG8gU3AuIHog
+by5vLjESMBAGA1UEAxMJQ2VydHVtIENBggMBACAwDgYDVR0PAQH/BAQDAgEGMCwG
+A1UdHwQlMCMwIaAfoB2GG2h0dHA6Ly9jcmwuY2VydHVtLnBsL2NhLmNybDBoBggr
+BgEFBQcBAQRcMFowKAYIKwYBBQUHMAGGHGh0dHA6Ly9zdWJjYS5vY3NwLWNlcnR1
+bS5jb20wLgYIKwYBBQUHMAKGImh0dHA6Ly9yZXBvc2l0b3J5LmNlcnR1bS5wbC9j
+YS5jZXIwOgYDVR0gBDMwMTAvBgRVHSAAMCcwJQYIKwYBBQUHAgEWGWh0dHBzOi8v
+d3d3LmNlcnR1bS5wbC9DUFMwDQYJKoZIhvcNAQEFBQADggEBAI/jSDAW/w9qLzF6
+4oQiIRB7dGKp2Nlj27xZFYDBRINn4DKyZExkpanASF2of9eEzvrS+qoDY29mhXCi
+MkiGr0vCsVhn0ReUpjg4Z5SsiQhZ2BGSjXiOJgaDI7Dw1MH7Ru6jdfSbLyd97EFj
+ER0ERGdrcA2kLw7KfQm78IkClXEEKjKnAUTn1d/5Y4UuBWDCEL0FLgO9AqNXEzIy
+rlXVGIs73kdefAK+Z1T6dm83vUrDMyzemWNRBI2tVBujkN6zkaF6uPjE4hfoIkEQ
+Z4317byFkG4mxjATU+tQLG1Bs88HUAOrxtJOo/WoeCNsFJaxbYPt4oQGxIVYdz29
+OUX9CQA=
+-----END CERTIFICATE-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug65698.phpt php-5.3.29/ext/openssl/tests/bug65698.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug65698.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug65698.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,19 @@
+--TEST--
+Bug #65689 (GeneralizedTime format parsing)
+--SKIPIF--
+<?php 
+if (!extension_loaded("openssl")) die("skip"); 
+?>
+--FILE--
+<?php
+$crt = substr(__FILE__, 0, -4).'.crt';
+$info = openssl_x509_parse("file://$crt");
+var_dump($info["validFrom"], $info["validFrom_time_t"], $info["validTo"], $info["validTo_time_t"]);
+?>
+Done
+--EXPECTF--
+string(15) "20090303125318Z"
+int(12360%d)
+string(15) "20240303125318Z"
+int(17094%d)
+Done
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug65729.pem php-5.3.29/ext/openssl/tests/bug65729.pem
--- php-5.3.29-ori/ext/openssl/tests/bug65729.pem	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug65729.pem	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,32 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIICXgIBAAKBgQDU8RgB8O2uR3ApjlxEX5rpCI+gIaZ3h0RBAF9rNA/s0pPTtX/e
+NGJgDyuT/TF6mcv0I/0/s2WSmIE50NW6tgWZ7RoBdVw/MiByPt6vK1aDrggbycN/
+C6RrxrEsdZe3E9CDZCFM1br8/8tnV19Ju80g8zY2MgDjAjSkeXN5yp3kgQIDAQAB
+AoGBANFKKRt3TlRVmHLvndYB1YKmzGtJx5CBXV85247FO8W67lpNcGDYQbxCDMXG
+PARQ9vl9CeK7EuDzjUdi7z40uujUOJtsLbMP6ikwKFi/tA2cW1yoLionZ3JkfyEr
+4Uu8kkkIut0VLX8uuVz/Y03lt8Uzc+GvD2DPhkSQn80f10SFAkEA94EcjwFcwuVi
+QofgOPbf7qfOoWDsXYhlMU9g1CaPJiMcMcvgoLK3V514oMDxlkvuLujlYeG9NvRS
+tREluGsbywJBANxARX5MSzAkFRNZNZKDUvifdC0BA2Dqzd2iOJRcTdcebGENd7+e
+oub/9lVLGrX7T4U2en8IXwJV4UHxwoQLz2MCQQCI1Bj8ui0VFgj/bOy5sUnVP3IN
+Z27kuo3u98o5HuQOmmRw5xxU2thfGJBilqg4hdu0lU6SkWCwq9u5fDRVQumHAkAM
+mJBg3LQgGLAr3xo1OtVv6o6WVEyBKmyDlFdwBKde+hpwoniKuOPQGitYTWdFqQ2v
+LKJsyWnFlGvBfbYGHzbJAkEA17SgCf7Wx7NxuLCSMj/rd25ul0jlIrjx6+/HfyLb
++T2SXXU4g2DBiPngrfJ9jX8QGoLpZiBGcwX3QxssX5FgJQ==
+-----END RSA PRIVATE KEY-----
+-----BEGIN CERTIFICATE-----
+MIICvDCCAiWgAwIBAgIJANOyJnvPEioVMA0GCSqGSIb3DQEBBQUAMEkxCzAJBgNV
+BAYTAlNHMRIwEAYDVQQIEwlUZXN0dmlsbGUxETAPBgNVBAoTCGRhdGliYmF3MRMw
+EQYDVQQDFAoqLnRlc3QuY29tMB4XDTE0MTAxNTEzMDg1OFoXDTM0MTAxMDEzMDg1
+OFowSTELMAkGA1UEBhMCU0cxEjAQBgNVBAgTCVRlc3R2aWxsZTERMA8GA1UEChMI
+ZGF0aWJiYXcxEzARBgNVBAMUCioudGVzdC5jb20wgZ8wDQYJKoZIhvcNAQEBBQAD
+gY0AMIGJAoGBANTxGAHw7a5HcCmOXERfmukIj6AhpneHREEAX2s0D+zSk9O1f940
+YmAPK5P9MXqZy/Qj/T+zZZKYgTnQ1bq2BZntGgF1XD8yIHI+3q8rVoOuCBvJw38L
+pGvGsSx1l7cT0INkIUzVuvz/y2dXX0m7zSDzNjYyAOMCNKR5c3nKneSBAgMBAAGj
+gaswgagwHQYDVR0OBBYEFErHO0eHLp9YvBWVvvhty/jGie5wMHkGA1UdIwRyMHCA
+FErHO0eHLp9YvBWVvvhty/jGie5woU2kSzBJMQswCQYDVQQGEwJTRzESMBAGA1UE
+CBMJVGVzdHZpbGxlMREwDwYDVQQKEwhkYXRpYmJhdzETMBEGA1UEAxQKKi50ZXN0
+LmNvbYIJANOyJnvPEioVMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEFBQADgYEA
+gMv2HUUp0FMTYQ6tL9YgNUNARukxJzGDWweo4/YuNSgI+Ljpye4Nf1MpyDWfhZGc
+QbUhfm5CdEvcBzZBtI0lLXs61yGdLnDH/6QHViXP2rlH0yeAABw8+wSdxuiZN1yR
+ed4pNXU+tczgW2Ri2+T0ScOZd0XommKHrQnu2T9mMBY=
+-----END CERTIFICATE-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug65729.phpt php-5.3.29/ext/openssl/tests/bug65729.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug65729.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug65729.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,60 @@
+--TEST--
+Bug #65729: CN_match gives false positive when wildcard is used
+--SKIPIF--
+<?php 
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug65729.pem'
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    $expected_names = ['foo.test.com.sg', 'foo.test.com', 'FOO.TEST.COM', 'foo.bar.test.com'];
+    foreach ($expected_names as $name) {
+        @stream_socket_accept($server, 1);
+    }
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $clientFlags = STREAM_CLIENT_CONNECT;
+
+    phpt_wait();
+
+    $expected_names = ['foo.test.com.sg', 'foo.test.com', 'FOO.TEST.COM', 'foo.bar.test.com'];
+    foreach ($expected_names as $expected_name) {
+        $clientCtx = stream_context_create(['ssl' => [
+            'verify_peer'       => true,
+            'allow_self_signed'    => true,
+            'peer_name'          => $expected_name,
+        ]]);
+
+        var_dump(stream_socket_client($serverUri, $errno, $errstr, 2, $clientFlags, $clientCtx));
+    }
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+Warning: stream_socket_client(): Peer certificate CN=`*.test.com' did not match expected CN=`foo.test.com.sg' in %s on line %d
+
+Warning: stream_socket_client(): Failed to enable crypto in %s on line %d
+
+Warning: stream_socket_client(): unable to connect to ssl://127.0.0.1:64321 (Unknown error) in %s on line %d
+bool(false)
+resource(%d) of type (stream)
+resource(%d) of type (stream)
+
+Warning: stream_socket_client(): Peer certificate CN=`*.test.com' did not match expected CN=`foo.bar.test.com' in %s on line %d
+
+Warning: stream_socket_client(): Failed to enable crypto in %s on line %d
+
+Warning: stream_socket_client(): unable to connect to ssl://127.0.0.1:64321 (Unknown error) in %s on line %d
+bool(false)
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug66501.phpt php-5.3.29/ext/openssl/tests/bug66501.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug66501.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug66501.phpt	2019-01-26 11:29:19.967117841 +0800
@@ -0,0 +1,22 @@
+--TEST--
+Bug #66501: EC private key support in openssl_sign
+--SKIPIF--
+<?php 
+if (!extension_loaded("openssl")) die("skip");
+if (!defined('OPENSSL_KEYTYPE_EC')) die("skip no EC available");
+--FILE--
+<?php
+$pkey = 'ASN1 OID: prime256v1
+-----BEGIN EC PARAMETERS-----
+BggqhkjOPQMBBw==
+-----END EC PARAMETERS-----
+-----BEGIN EC PRIVATE KEY-----
+MHcCAQEEILPkqoeyM7XgwYkuSj3077lrsrfWJK5LqMolv+m2oOjZoAoGCCqGSM49
+AwEHoUQDQgAEPq4hbIWHvB51rdWr8ejrjWo4qVNWVugYFtPg/xLQw0mHkIPZ4DvK
+sqOTOnMoezkbSmVVMuwz9flvnqHGmQvmug==
+-----END EC PRIVATE KEY-----';
+$key = openssl_pkey_get_private($pkey);
+$res = openssl_sign($data ='alpha', $sign, $key, OPENSSL_VERSION_NUMBER < 0x10100000 ? 'ecdsa-with-SHA1' : 'SHA1');
+var_dump($res);
+--EXPECTF--
+bool(true)
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug67403.phpt php-5.3.29/ext/openssl/tests/bug67403.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug67403.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug67403.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,23 @@
+--TEST--
+Bug #67403: Add signatureType to openssl_x509_parse
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip");
+--FILE--
+<?php
+$r = openssl_x509_parse(file_get_contents(__DIR__.'/bug64802.pem'));
+var_dump($r['signatureTypeSN']);
+var_dump($r['signatureTypeLN']);
+var_dump($r['signatureTypeNID']);
+
+$r = openssl_x509_parse(file_get_contents(__DIR__.'/bug37820cert.pem'));
+var_dump($r['signatureTypeSN']);
+var_dump($r['signatureTypeLN']);
+var_dump($r['signatureTypeNID']);
+--EXPECTF--
+string(8) "RSA-SHA1"
+string(21) "sha1WithRSAEncryption"
+int(65)
+string(7) "RSA-MD5"
+string(20) "md5WithRSAEncryption"
+int(8)
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug68265.pem php-5.3.29/ext/openssl/tests/bug68265.pem
--- php-5.3.29-ori/ext/openssl/tests/bug68265.pem	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug68265.pem	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,33 @@
+-----BEGIN ENCRYPTED PRIVATE KEY-----
+MIICxjBABgkqhkiG9w0BBQ0wMzAbBgkqhkiG9w0BBQwwDgQIuw/AFD7RWcMCAggA
+MBQGCCqGSIb3DQMHBAh98F6GmaGn1ASCAoBpzaFxyttEhyh4dhMjarJIqTz24DjO
+yZnp1K5qthejSYx2P28uUsh+gQOh6F2jbVAq++eAWkTBGuc4pWhhoT7nY8vhf0Y0
+6yTlVrTxuI/8MNo/lfa0xE/+ZD4B5zp0hQxfij4GTd8l6V/kpXMgiYD1JmIXArm7
+sucn+9XV3RucsTBpeIJ1nLEDfpbyEWqNfhoyskQ+S3I6HkMgELI9JpsO6OR9fh1Q
+ttdoYxBU+YjoDYcSWRGkTGrJFeGGhTQzz+L2ijgoqNWDSfrLBoQR1bqNVUuw6gcE
+9PpA/vpRlxcHbUNNkOWft+4e0tV3I2EqscEcsYeNbd2Ta4yu7f6pk4/Kxn40wrQ8
+6Ss9GZylghaFth2xppL/vpmGaCC7FqpZRh+NKqjlcBobIkwyRcsQrPHB0CYLPHA4
+yak/dNTY8L5K8Rtd5XG3+E41CoDF6ssNY0Kw7l9kAn/neDVh+WnQkWIiWPmq210a
+p4L/uiXRK7aYi+UqKJ5+svayNw2w1dkqpbeejwLq2F1+ek/447JFPVJcvP8Nm7sr
+04Mcg+ZHusZdjiWEv4W6CBq8o6eF2JdhfpSDgPkHwiZ/EarHfx0vcYIMJhlEQBmk
+a/XsZPk2wnamKSPfJautO3MIus0M6SniWF6eDA4/AZzSjXV8Vc0unb6lc+Nc8tJa
+6MU1soTsmki/YraCmQswqpL+kXFZVeHuLowOC5oH+CimQoscmiZ9tBvpnYo6XwEZ
+S9jZRIBQ77oMku+rlMPfz2FURgVXZpEfrGmxKvA5Vt3ojrYfTwwD2YqZHVcm39zy
+iKqA1qVt7A2A90ILMAzYnN0VRE4SO3yIDN1ZBp5OOY61AduPrhpaHl81
+-----END ENCRYPTED PRIVATE KEY-----
+-----BEGIN CERTIFICATE-----
+MIICdjCCAd+gAwIBAgIJAPbIVRT31Al2MA0GCSqGSIb3DQEBCwUAMFgxCzAJBgNV
+BAYTAlhYMRUwEwYDVQQHDAxEZWZhdWx0IENpdHkxHDAaBgNVBAoME0RlZmF1bHQg
+Q29tcGFueSBMdGQxFDASBgNVBAMMC3BocCB0ZXN0IGNhMB4XDTE1MDMwNTA2MTYz
+MFoXDTI1MDMwMjA2MTYzMFowUjELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAlNDMRUw
+EwYDVQQHDAxNeXJ0bGUgQmVhY2gxDDAKBgNVBAsMA1BIUDERMA8GA1UEAwwIdGVz
+dC5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAKp5gxUbKvY5eFwZJti0
+6d6YBo400Or6M+bLfIMnz5C1WQ7dMfiQpeFLpSIlOIaFqyrqkeeR9k5dsx1K9FOu
+PAJ4+lmWA4R93RpdJFz8kmQoNu3P59JMATXi8wvNBIrN/Vc08NT0wBRImeyQSVHd
+UcFIXBEbBM0dQsPKQ1k8n5WDAgMBAAGjTjBMMAkGA1UdEwQCMAAwCwYDVR0PBAQD
+AgXgMDIGA1UdEQQrMCmCEmRlYnMuYWstb25saW5lLmJlLoITZGVicy5hay1vbmxp
+bmUubmV0LjANBgkqhkiG9w0BAQsFAAOBgQB8PaLt+IX690UIbHKuko4qAdc5SzWA
+Vbm3D4StZeFwWQbZbBGFCDn0/0ON0iDv4JUgZnaX84mBDPczN26QG2PJND0Cggmi
+umylEVYhclPF4RoGcoKd3jT2igzDNyzk/lu+NUtRv/Nj161ds9vb9XiOrEkPn8Ne
+mzz3wA0D5A65lw==
+-----END CERTIFICATE-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug68265.phpt php-5.3.29/ext/openssl/tests/bug68265.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug68265.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug68265.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,41 @@
+--TEST--
+Bug #68265: SAN match fails with trailing DNS dot
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug68265.pem',
+        'passphrase' => 'elephpant',
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    stream_socket_accept($server, 30);
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $clientFlags = STREAM_CLIENT_CONNECT;
+    $clientCtx = stream_context_create(['ssl' => [
+        'verify_peer' => false,
+        'verify_peer_name' => true,
+        'peer_name' => 'debs.ak-online.net',
+    ]]);
+
+    phpt_wait();
+
+    var_dump(stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx));
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+resource(%d) of type (stream)
+
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug68879.pem php-5.3.29/ext/openssl/tests/bug68879.pem
--- php-5.3.29-ori/ext/openssl/tests/bug68879.pem	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug68879.pem	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,33 @@
+-----BEGIN ENCRYPTED PRIVATE KEY-----
+MIICxjBABgkqhkiG9w0BBQ0wMzAbBgkqhkiG9w0BBQwwDgQIuw/AFD7RWcMCAggA
+MBQGCCqGSIb3DQMHBAh98F6GmaGn1ASCAoBpzaFxyttEhyh4dhMjarJIqTz24DjO
+yZnp1K5qthejSYx2P28uUsh+gQOh6F2jbVAq++eAWkTBGuc4pWhhoT7nY8vhf0Y0
+6yTlVrTxuI/8MNo/lfa0xE/+ZD4B5zp0hQxfij4GTd8l6V/kpXMgiYD1JmIXArm7
+sucn+9XV3RucsTBpeIJ1nLEDfpbyEWqNfhoyskQ+S3I6HkMgELI9JpsO6OR9fh1Q
+ttdoYxBU+YjoDYcSWRGkTGrJFeGGhTQzz+L2ijgoqNWDSfrLBoQR1bqNVUuw6gcE
+9PpA/vpRlxcHbUNNkOWft+4e0tV3I2EqscEcsYeNbd2Ta4yu7f6pk4/Kxn40wrQ8
+6Ss9GZylghaFth2xppL/vpmGaCC7FqpZRh+NKqjlcBobIkwyRcsQrPHB0CYLPHA4
+yak/dNTY8L5K8Rtd5XG3+E41CoDF6ssNY0Kw7l9kAn/neDVh+WnQkWIiWPmq210a
+p4L/uiXRK7aYi+UqKJ5+svayNw2w1dkqpbeejwLq2F1+ek/447JFPVJcvP8Nm7sr
+04Mcg+ZHusZdjiWEv4W6CBq8o6eF2JdhfpSDgPkHwiZ/EarHfx0vcYIMJhlEQBmk
+a/XsZPk2wnamKSPfJautO3MIus0M6SniWF6eDA4/AZzSjXV8Vc0unb6lc+Nc8tJa
+6MU1soTsmki/YraCmQswqpL+kXFZVeHuLowOC5oH+CimQoscmiZ9tBvpnYo6XwEZ
+S9jZRIBQ77oMku+rlMPfz2FURgVXZpEfrGmxKvA5Vt3ojrYfTwwD2YqZHVcm39zy
+iKqA1qVt7A2A90ILMAzYnN0VRE4SO3yIDN1ZBp5OOY61AduPrhpaHl81
+-----END ENCRYPTED PRIVATE KEY-----
+-----BEGIN CERTIFICATE-----
+MIICkTCCAfqgAwIBAgIJAPbIVRT31Al1MA0GCSqGSIb3DQEBCwUAMFgxCzAJBgNV
+BAYTAlhYMRUwEwYDVQQHDAxEZWZhdWx0IENpdHkxHDAaBgNVBAoME0RlZmF1bHQg
+Q29tcGFueSBMdGQxFDASBgNVBAMMC3BocCB0ZXN0IGNhMB4XDTE1MDMwNTA0NTQx
+NVoXDTI1MDMwMjA0NTQxNVowUjELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAlNDMRUw
+EwYDVQQHDAxNeXJ0bGUgQmVhY2gxDDAKBgNVBAsMA1BIUDERMA8GA1UEAwwIdGVz
+dC5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAKp5gxUbKvY5eFwZJti0
+6d6YBo400Or6M+bLfIMnz5C1WQ7dMfiQpeFLpSIlOIaFqyrqkeeR9k5dsx1K9FOu
+PAJ4+lmWA4R93RpdJFz8kmQoNu3P59JMATXi8wvNBIrN/Vc08NT0wBRImeyQSVHd
+UcFIXBEbBM0dQsPKQ1k8n5WDAgMBAAGjaTBnMAkGA1UdEwQCMAAwCwYDVR0PBAQD
+AgXgME0GA1UdEQRGMESCCHRlc3QuY29tggx3d3cudGVzdC5jb22CEnN1YmRvbWFp
+bi50ZXN0LmNvbYcQAAAAAAAAAAAAAP//CgIAAYcECgIAATANBgkqhkiG9w0BAQsF
+AAOBgQBZ4TptNXV85gNj3wcB5feWFcwKO8cN4hwnhrbqiHN280r9O/g1CQiLmB4K
+2txrJt06UNCnvWse7CdvsN14wu6rRGRk/+7M36NBw5ERkAzp5HXgZUWVdMl3YltB
+PpqbLhGGrkVn7/jW2FdAxfax7qaGDYgC3qcQNfiK6K92SPxV7Q==
+-----END CERTIFICATE-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug68879.phpt php-5.3.29/ext/openssl/tests/bug68879.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug68879.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug68879.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,41 @@
+--TEST--
+Bug #68879: Match IP address fields in subjectAltName checks
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug68879.pem',
+        'passphrase' => 'elephpant',
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    stream_socket_accept($server, 30);
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $clientFlags = STREAM_CLIENT_CONNECT;
+    $clientCtx = stream_context_create(['ssl' => [
+        'verify_peer' => false,
+        'verify_peer_name' => true,
+        'peer_name' => '10.2.0.1',
+    ]]);
+
+    phpt_wait();
+
+    var_dump(stream_socket_client($serverUri, $errno, $errstr, 30, $clientFlags, $clientCtx));
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+resource(%d) of type (stream)
+
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug68912.phpt php-5.3.29/ext/openssl/tests/bug68912.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug68912.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug68912.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,21 @@
+--TEST--
+Bug #68912 (Segmentation fault at openssl_spki_new)
+--SKIPIF--
+<?php 
+if (!extension_loaded("openssl")) die("skip");
+if (!extension_loaded("xml")) die("skip xml extension not loaded");
+if (!@openssl_pkey_new()) die("skip cannot create private key");
+?>
+--FILE--
+<?php
+
+$var1=xml_parser_create_ns();
+$var2=2; 
+$var3=3; 
+
+openssl_spki_new($var1, $var2, $var3);
+?>
+--EXPECTF--
+Warning: openssl_spki_new(): supplied resource is not a valid OpenSSL X.509/key resource in %sbug68912.php on line %d
+
+Warning: openssl_spki_new(): Unable to use supplied private key in %sbug68912.php on line %d
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug68920.phpt php-5.3.29/ext/openssl/tests/bug68920.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug68920.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug68920.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,81 @@
+--TEST--
+Bug #68920: peer_fingerprint input checks should be strict
+--SKIPIF--
+<?php 
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/san-cert.pem',
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    stream_socket_accept($server, 30);
+    stream_socket_accept($server, 30);
+    stream_socket_accept($server, 30);
+    stream_socket_accept($server, 30);
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $clientFlags = STREAM_CLIENT_CONNECT;
+
+    phpt_wait();
+
+    $ctx = stream_context_create(['ssl' => ['verify_peer'=> false, 'peer_fingerprint' => true]]);
+    $sock = stream_socket_client($serverUri, $errno, $errstr, 30, $clientFlags, $ctx);
+    var_dump($sock);
+
+    $ctx = stream_context_create(['ssl' => ['verify_peer'=> false, 'peer_fingerprint' => null]]);
+    $sock = stream_socket_client($serverUri, $errno, $errstr, 30, $clientFlags, $ctx);
+    var_dump($sock);
+
+    $ctx = stream_context_create(['ssl' => ['verify_peer'=> false, 'peer_fingerprint' => []]]);
+    $sock = stream_socket_client($serverUri, $errno, $errstr, 30, $clientFlags, $ctx);
+    var_dump($sock);
+
+    $ctx = stream_context_create(['ssl' => ['verify_peer'=> false, 'peer_fingerprint' => ['foo']]]);
+    $sock = stream_socket_client($serverUri, $errno, $errstr, 30, $clientFlags, $ctx);
+    var_dump($sock);
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+Warning: stream_socket_client(): Expected peer fingerprint must be a string or an array in %s on line %d
+
+Warning: stream_socket_client(): Failed to enable crypto in %s on line %d
+
+Warning: stream_socket_client(): unable to connect to %s (Unknown error) in %s on line %d
+bool(false)
+
+Warning: stream_socket_client(): Expected peer fingerprint must be a string or an array in %s on line %d
+
+Warning: stream_socket_client(): Failed to enable crypto in %s on line %d
+
+Warning: stream_socket_client(): unable to connect to %s (Unknown error) in %s on line %d
+bool(false)
+
+Warning: stream_socket_client(): Invalid peer_fingerprint array; [algo => fingerprint] form required in %s on line %d
+
+Warning: stream_socket_client(): peer_fingerprint match failure in %s on line %d
+
+Warning: stream_socket_client(): Failed to enable crypto in %s on line %d
+
+Warning: stream_socket_client(): unable to connect to %s (Unknown error) in %s on line %d
+bool(false)
+
+Warning: stream_socket_client(): Invalid peer_fingerprint array; [algo => fingerprint] form required in %s on line %d
+
+Warning: stream_socket_client(): peer_fingerprint match failure in %s on line %d
+
+Warning: stream_socket_client(): Failed to enable crypto in %s on line %d
+
+Warning: stream_socket_client(): unable to connect to %s (Unknown error) in %s on line %d
+bool(false)
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug69215-ca.pem php-5.3.29/ext/openssl/tests/bug69215-ca.pem
--- php-5.3.29-ori/ext/openssl/tests/bug69215-ca.pem	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug69215-ca.pem	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,16 @@
+-----BEGIN CERTIFICATE-----
+MIICfjCCAeegAwIBAgIJAMO7Amv3ZHJBMA0GCSqGSIb3DQEBCwUAMFgxCzAJBgNV
+BAYTAlhYMRUwEwYDVQQHDAxEZWZhdWx0IENpdHkxHDAaBgNVBAoME0RlZmF1bHQg
+Q29tcGFueSBMdGQxFDASBgNVBAMMC3BocCB0ZXN0IGNhMB4XDTE1MDMwMzE3NTQz
+OVoXDTI1MDIyODE3NTQzOVowWDELMAkGA1UEBhMCWFgxFTATBgNVBAcMDERlZmF1
+bHQgQ2l0eTEcMBoGA1UECgwTRGVmYXVsdCBDb21wYW55IEx0ZDEUMBIGA1UEAwwL
+cGhwIHRlc3QgY2EwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAKac+r8AzEEk
+Cdnue7nx3gxmsXTYzwnywjjGJSknoWCdNEE+LqtT8RU0J+V76w4ehWRnhLVtu//v
+3InsrpcniGfTcov60NelHQOfn5XCCV5zqVi628WddwwdVw4AI58K3YrNk450VCBu
+dMy6m2Tm+dQwgVbtR+nIwzfm47CMWW2DAgMBAAGjUDBOMB0GA1UdDgQWBBTtMxRr
+plep4RW3PjhosYsIdIoMojAfBgNVHSMEGDAWgBTtMxRrplep4RW3PjhosYsIdIoM
+ojAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBCwUAA4GBADMF2pL8jCF6PFPhMuFN
+zxoLSuy6uLAkjkujo5e33kSUW5MI4jT/aoL2hnBPA4uJPC/TZXoBHKBpnPES2GkJ
+r7tOR51Jsk7HRTdvOMkcdD9Fe+M+Q5rOMUlCtyX/SRhc1uFnC2//Y/rx4Tc8djGl
+RqrH/Oi38u1083krmNRQNw/Z
+-----END CERTIFICATE-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug69215-client.pem php-5.3.29/ext/openssl/tests/bug69215-client.pem
--- php-5.3.29-ori/ext/openssl/tests/bug69215-client.pem	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug69215-client.pem	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,32 @@
+-----BEGIN RSA PRIVATE KEY-----
+Proc-Type: 4,ENCRYPTED
+DEK-Info: DES-EDE3-CBC,CE3DEB59F7DF7AF4
+
+9REujZuwDkwoN949Gw77c3aJiQvwoPiUXJ+cDirn4ii56OsHBSCWfCe4Mqn976GK
+9IAPwHJ5yRewPpFvb+xRqtMtnm8S7HIfVtZqW4FkG+g/paEg6rwqVpW78Jco/gww
+6XFGrmU1bwKWrB05YV1BWnbB4L7Q+/U0ZcNvdNISOBW//2HuHeKVWe1DKoaRtoVz
+v4BFQxr7F3A9tm3vz9Jn2JreVrihdWQVlVTVOsfiQk/yPVA7twxiT2Hfimp/gFSX
+l28rA+jB7xd6IhpA/EXAYnCbxSp9kSXYtba26dO3rQHlgRv1a38AwvCD/3igQzF/
+XjetX2a75ITi5c7bUT4ZpVX8ZPU8oVBqSo6MXisFWBT0Svx+KhWyyn2V0z66APdR
+X1V6dZiAcqN7giRg3Yj/lMDo0nV4Ph+Ce7p3Mv/p4qU0mxf7O8sPhp7DloHQFEF0
+HyooNp26YT4V47NDxwIlkoj9YZ5nkO/svQ1qxiTKWNUdfWw5r3lFiAw5xTyDDiBs
+Sz776DaFo3Ss3JSUr5RLe4rEEc02iVqYB9OPXoUaUwS+//1KKgzF3xq/yxsJM5dR
+ljphraCViZzJPw4z69Lmao9CPRfDxKChVOSLkKgmFIOeronLdTypieanc3/o002c
+2ecb/x9f7G2XAn0iwcfylMkSZHirxqaos8LodsPxg8GdNJT89C66n+EJerrFwi6i
+qT0EvNfkbxYd3zj82+j1weNFLsQuB0O1UJBWEdyj74gIX+4HkZpSYLQ2O8MTz3yE
+52JcRRyl9ECdNJw15jkDQIusUreYMHb7YW+u+3+ci21H94Iay5XSYw==
+-----END RSA PRIVATE KEY-----
+-----BEGIN CERTIFICATE-----
+MIICKDCCAZECCQD2yFUU99QJdzANBgkqhkiG9w0BAQsFADBYMQswCQYDVQQGEwJY
+WDEVMBMGA1UEBwwMRGVmYXVsdCBDaXR5MRwwGgYDVQQKDBNEZWZhdWx0IENvbXBh
+bnkgTHRkMRQwEgYDVQQDDAtwaHAgdGVzdCBjYTAeFw0xNTAzMTAyMzM0MDNaFw0y
+NTAzMDcyMzM0MDNaMFkxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJTQzEVMBMGA1UE
+BwwMTXlydGxlIEJlYWNoMQwwCgYDVQQLDANQSFAxGDAWBgNVBAMMD2J1ZzY5MjE1
+LWNsaWVudDCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAyLTbIGryqx0wGDD+
+xdrJsrcwXFyTYpCOHUaxl1wt/6j6u7yW5m4TJFEDUtIGnqBGYiPE9iynkLkOwUF/
+IpheONJENIjXkdSJPUEy/Ggz9WOa0qO6dQZU44NpGO7LFW97HglBIsbhioOsdcf/
+INAgidoMJNizkuTBNRGW7iKp0lsCAwEAATANBgkqhkiG9w0BAQsFAAOBgQBKkZLQ
+aU12/cPvW5e9AXArnE9jxMhnzuCKy81eHj30CC/nHpId9i5YZytHcZEZyEOWE6DQ
+IsqmsP5ZheXq26mUtHOcEdEgcqcXTRotKXFwIxTZxP5jkCRn0xGbeHh7H9pg6TP0
+QekWTkWCh5qcf3NXvJtk4TCfLC6FSjehHkq9yQ==
+-----END CERTIFICATE-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug69215-server.pem php-5.3.29/ext/openssl/tests/bug69215-server.pem
--- php-5.3.29-ori/ext/openssl/tests/bug69215-server.pem	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug69215-server.pem	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,32 @@
+-----BEGIN RSA PRIVATE KEY-----
+Proc-Type: 4,ENCRYPTED
+DEK-Info: DES-EDE3-CBC,4C7155D678EDABFA
+
+NdOGB8UpC5xrnCFIOzxV6s4y4PZlxgX8s+iL/JeGVmS7a8pDSTzbb6wjauYy3n/2
+KCywHsFdAjifi8SGHJOJBVep3GS7dWw979vWdiKjQEAlJpoouv6P58Xpn4jDf1uX
+ZrpmSTXI0iH7HYE2pzrkxPbg0Cz5GV2d2VlL7U5d4+UxXh8fSBndgHligmoc8mCU
+1AG7ZmvPhMDTewhR333qKBYi9TBZuw75Crpy5CjPO30vBMfZpseOvtEnmI0JYGwe
+75Q3e6sgY0o9b7Q42+g9v+FpGBTHhmldwYD7k1TtOC/PT4eO68E3mDawR2v+X9r8
+4jL22d3tB4Q4qAfBwbR37umTaQHLIxtjzc2OjXb/Ju35LW9d0hEuaAQK3oY8yeEi
+gctYWrCN4K+cxZQwq1+ulpkHXULGs9QxXT9KJYfV1+HWkauWUSycFhA74jWW0mL5
+InlGaFf6oiRrP4lgRVXD3rtTLCwkCD2JcvTbF+re9+vCpui7zPW2peGwcE/W7TiK
+wHFJhQQyYGcAWsal7ekXshTLoz4jeaPgak7dg50ZjjwcWr0bJuJ3RRaocMhYZ6Bd
+DiF30nCijVSJfrLhugN2RJmSysT4WNXn5qaDGEOhVgkXZscZ3ClFGsMnxAz9sqbJ
+J+ZMbqxkwSIf/+dPfhnjOWm3HPpP3T9wioYZT7KuI98pfGnHMZmX5CaJ6d/uBO5G
+8jMvQLWOx+1WoDfWDkn7SfNDyTg4/dEo5IJFXv2S9zSPynCnQcBkYUevIfJ7vDo/
+7pXCkcY+C1zssW8R1J+WNbHI1syzVbvSg6hlgyEPXuDbErCRqiFm1g==
+-----END RSA PRIVATE KEY-----
+-----BEGIN CERTIFICATE-----
+MIICKDCCAZECCQD2yFUU99QJeDANBgkqhkiG9w0BAQsFADBYMQswCQYDVQQGEwJY
+WDEVMBMGA1UEBwwMRGVmYXVsdCBDaXR5MRwwGgYDVQQKDBNEZWZhdWx0IENvbXBh
+bnkgTHRkMRQwEgYDVQQDDAtwaHAgdGVzdCBjYTAeFw0xNTAzMTAyMzM1MjFaFw0y
+NTAzMDcyMzM1MjFaMFkxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJTQzEVMBMGA1UE
+BwwMTXlydGxlIEJlYWNoMQwwCgYDVQQLDANQSFAxGDAWBgNVBAMMD2J1ZzY5MjE1
+LXNlcnZlcjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAup0kaIwQufxQWXmE
+QWbd7yxMQ69UHRhbb2stAo7qxmYMeH3bWCaR/oAPOswjtkXZQgyj0slLAWJDXKDg
+zCnEKsU2yWLnvQy/h1rq/kBIybMoLKMIkRZQtrGcApKJtyrq8OtTz6odKQ7k9hym
+DtPF+2lcVhSAd+qjngF3txrVKjsCAwEAATANBgkqhkiG9w0BAQsFAAOBgQCfXuL4
+TODLV54uKKVdVGwr8U3EQ3JdYOqN3Hr9kpmxe6StIcLxQ1e+mSDgKcixzw6CXN3P
+f++8NugAt4Ja2SDqqw1gzrX+9u6KZpnMKpEDIK0Z3Ss51ZwqilAXmFVybNTyYeVo
+HweM1IY/zrBpSTQv/aKs1R2Pyb0Heindnp0PUQ==
+-----END CERTIFICATE-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug69215.phpt php-5.3.29/ext/openssl/tests/bug69215.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug69215.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug69215.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,48 @@
+--TEST--
+Bug #69215: Crypto servers should send client CA list
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug69215-server.pem',
+        'passphrase' => 'elephpant',
+        'cafile' => __DIR__ . '/bug69215-ca.pem',
+        'verify_peer' => true,
+        'verify_peer_name' => true,
+        'peer_name' => 'bug69215-client',
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    stream_socket_accept($server, 30);
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $clientFlags = STREAM_CLIENT_CONNECT;
+    $clientCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug69215-client.pem',
+        'passphrase' => 'elephpant',
+        'cafile' => __DIR__ . '/bug69215-ca.pem',
+        'verify_peer' => true,
+        'verify_peer_name' => true,
+        'peer_name' => 'bug69215-server',
+    ]]);
+
+    phpt_wait();
+
+    var_dump(stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx));
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+resource(%d) of type (stream)
+
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug69882.phpt php-5.3.29/ext/openssl/tests/bug69882.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug69882.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug69882.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,17 @@
+--TEST--
+Bug #69882: OpenSSL error "key values mismatch" after openssl_pkcs12_read with extra certs
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip");
+?>
+--FILE--
+<?php
+$p12 = file_get_contents(__DIR__.'/p12_with_extra_certs.p12');
+
+$result = openssl_pkcs12_read($p12, $cert_data, 'qwerty');
+var_dump($result);
+var_dump(openssl_error_string());
+?>
+--EXPECTF--
+bool(true)
+bool(false)
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug70395.phpt php-5.3.29/ext/openssl/tests/bug70395.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug70395.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug70395.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,19 @@
+--TEST--
+Bug #70395 (Missing ARG_INFO for openssl_seal())
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+?>
+--FILE--
+<?php
+$func = new ReflectionFunction('openssl_seal');
+$param = $func->getParameters()[4];
+var_dump($param);
+var_dump($param->isOptional());
+?>
+--EXPECTF--
+object(ReflectionParameter)#%d (1) {
+  ["name"]=>
+  string(6) "method"
+}
+bool(true)
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug72336.phpt php-5.3.29/ext/openssl/tests/bug72336.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug72336.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug72336.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,24 @@
+--TEST--
+Bug #72336 (openssl_pkey_new does not fail for invalid DSA params)
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+$p = '00f8000ae45b2dacb47dd977d58b719d097bdf07cb2c17660ad898518c08' .
+        '1a61659a16daadfaa406a0a994c743df5eda07e36bd0adcad921b77432ff' .
+        '24ccc31e782d647e66768122b578857e9293df78387dc8b44af2a4a3f305' .
+        '1f236b1000a3e31da489c6681b0031f7ec37c2e1091bdb698e7660f135b6' .
+        '996def90090303b7ad';
+
+$q = '009b3734fc9f7a4a9d6437ec314e0a78c2889af64b';
+
+$g = '00b320300a0bc55b8f0ec6edc218e2185250f38fbb8291db8a89227f6e41' .
+        '00d47d6ccb9c7d42fc43280ecc2ed386e81ff65bc5d6a2ae78db7372f5dc' .
+        'f780f4558e7ed3dd0c96a1b40727ac56c5165aed700a3b63997893a1fb21' .
+        '4e882221f0dd9604820dc34e2725dd6901c93e0ca56f6d76d495c332edc5' .
+        'b81747c4c447a941f3';
+
+var_dump(openssl_pkey_new(array('dsa' => array('p' => $p, 'q' => $q, 'g' => $g))));
+?>
+--EXPECT--
+bool(false)
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug73072.phpt php-5.3.29/ext/openssl/tests/bug73072.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug73072.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug73072.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,45 @@
+--TEST--
+Bug #73072: Invalid path SNI_server_certs causes segfault
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+?>
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $flags = STREAM_SERVER_BIND|STREAM_SERVER_LISTEN;
+	$ctx = stream_context_create(['ssl' => [
+	    'local_cert' => __DIR__ . '/domain1.pem',
+		'SNI_server_certs' => [
+		    "domain1.com" => __DIR__ . "/sni_server_domain1.pem",
+			"domain2.com" => __DIR__ . "/not_existing.pem",
+		]
+	]]);
+
+    $server = stream_socket_server('tls://127.0.0.1:64322', $errno, $errstr, $flags, $ctx);
+
+    phpt_notify();
+	@stream_socket_accept($server, 3);
+	// if there is a segfault, this won't be called
+	fwrite(STDERR, "done\n");
+CODE;
+
+$clientCode = <<<'CODE'
+    $flags = STREAM_CLIENT_CONNECT;
+	$ctxArr = [
+	    'cafile' => __DIR__ . '/sni_server_ca.pem',
+		'capture_peer_cert' => true
+	];
+
+    phpt_wait();
+
+    $ctxArr['peer_name'] = 'domain1.com';
+	$ctx = stream_context_create(['ssl' => $ctxArr]);
+	@stream_socket_client("tls://127.0.0.1:64322", $errno, $errstr, 1, $flags, $ctx);
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+?>
+--EXPECT--
+done
diff -uNr php-5.3.29-ori/ext/openssl/tests/bug74651.phpt php-5.3.29/ext/openssl/tests/bug74651.phpt
--- php-5.3.29-ori/ext/openssl/tests/bug74651.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/bug74651.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,17 @@
+--TEST--
+Bug #74651: negative-size-param (-1) in memcpy in zif_openssl_seal()
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+?>
+--FILE--
+<?php
+
+$inputstr = file_get_contents(__DIR__ . "/74651.pem");
+$pub_key_id = openssl_get_publickey($inputstr);
+var_dump($pub_key_id);
+var_dump(openssl_seal($inputstr, $sealed, $ekeys, array($pub_key_id, $pub_key_id), 'AES-128-ECB'));
+?>
+--EXPECTF--
+resource(%d) of type (OpenSSL key)
+bool(false)
\ No newline at end of file
diff -uNr php-5.3.29-ori/ext/openssl/tests/capture_peer_cert_001.phpt php-5.3.29/ext/openssl/tests/capture_peer_cert_001.phpt
--- php-5.3.29-ori/ext/openssl/tests/capture_peer_cert_001.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/capture_peer_cert_001.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,39 @@
+--TEST--
+capture_peer_cert context captures on verify failure
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug54992.pem'
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    @stream_socket_accept($server, 1);
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $clientFlags = STREAM_CLIENT_CONNECT;
+    $clientCtx = stream_context_create(['ssl' => [
+        'capture_peer_cert' => true,
+        'cafile' => __DIR__ . '/bug54992-ca.pem'
+    ]]);
+
+    phpt_wait();
+    $client = @stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx);
+    $cert = stream_context_get_options($clientCtx)['ssl']['peer_certificate'];
+    var_dump(openssl_x509_parse($cert)['subject']['CN']);
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+string(%d) "bug54992.local"
diff -uNr php-5.3.29-ori/ext/openssl/tests/cert.csr php-5.3.29/ext/openssl/tests/cert.csr
--- php-5.3.29-ori/ext/openssl/tests/cert.csr	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/cert.csr	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,22 @@
+-----BEGIN NEW CERTIFICATE REQUEST-----
+MIIDYzCCAswCAQAwgYcxCzAJBgNVBAYTAk5MMRYwFAYDVQQIEw1Ob29yZCBCcmFi
+YW50MQ0wCwYDVQQHEwRVZGVuMRMwEQYDVQQKEwpUcmljb25uZWN0MRMwEQYDVQQL
+EwpUcmljb25uZWN0MScwJQYDVQQDHh4AKgAuAHQAcgBpAGMAbwBuAG4AZQBjAHQA
+LgBuAGwwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBANjE/qKAKgo93162HhtX
+OZdvunF5eG/PFK2yn6uAUDWgZciPoKBslgL6a6sK+RdcS7LjWdjWEOOANGzZY1Kk
+FelzxrIjIGSGJHC9eubebdu2LWFFM5cEMDiH0QSD9Rdiy7svSLWvngUDYj0wwd+m
+iV2duzUFHnusj9iVPpD9s47RAgMBAAGgggGZMBoGCisGAQQBgjcNAgMxDBYKNS4y
+LjM3OTAuMjB7BgorBgEEAYI3AgEOMW0wazAOBgNVHQ8BAf8EBAMCBPAwRAYJKoZI
+hvcNAQkPBDcwNTAOBggqhkiG9w0DAgICAIAwDgYIKoZIhvcNAwQCAgCAMAcGBSsO
+AwIHMAoGCCqGSIb3DQMHMBMGA1UdJQQMMAoGCCsGAQUFBwMBMIH9BgorBgEEAYI3
+DQICMYHuMIHrAgEBHloATQBpAGMAcgBvAHMAbwBmAHQAIABSAFMAQQAgAFMAQwBo
+AGEAbgBuAGUAbAAgAEMAcgB5AHAAdABvAGcAcgBhAHAAaABpAGMAIABQAHIAbwB2
+AGkAZABlAHIDgYkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
+AAAAADANBgkqhkiG9w0BAQUFAAOBgQA4agiUkIblhF+n0wth4vQY+PwMadyaBpA4
+epr4TKL0QEkA0bQBbIERw5dDE3WQi6aVFJe6y870QymBwmKIvfBBfOyyA0IlQq/n
+uybhzQNQbSMKF1T82hpfh1w2RwVGaGrw7f6qH+CLyP1ydvBPvmD88HwiibNBBB3c
+R23mEEGYUQ==
+-----END NEW CERTIFICATE REQUEST-----
+
diff -uNr php-5.3.29-ori/ext/openssl/tests/check_default_conf_path.phpt php-5.3.29/ext/openssl/tests/check_default_conf_path.phpt
--- php-5.3.29-ori/ext/openssl/tests/check_default_conf_path.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/check_default_conf_path.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,24 @@
+--TEST--
+Check for default OpenSSL config path on Windows
+--SKIPIF--
+<?php
+if (substr(PHP_OS, 0, 3) != 'WIN') {
+    die('skip windows only test');
+}
+?>
+--FILE--
+<?php
+
+ob_start();
+phpinfo();
+$info = ob_get_contents();
+ob_end_clean();
+
+preg_match(",Openssl default config .* (.*),", $info, $m);
+
+if (isset($m[1])) {
+	var_dump(str_replace('/', '\\', strtolower($m[1])));
+}
+?>
+--EXPECT--
+string(28) "c:\usr\local\ssl\openssl.cnf"
diff -uNr php-5.3.29-ori/ext/openssl/tests/cve-2013-6420.phpt php-5.3.29/ext/openssl/tests/cve-2013-6420.phpt
--- php-5.3.29-ori/ext/openssl/tests/cve-2013-6420.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/cve-2013-6420.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -12,7 +12,7 @@
 ?>
 Done
 --EXPECTF--
-%s openssl_x509_parse(): illegal ASN1 data type for timestamp in %s%ecve-2013-6420.php on line 3
+%s openssl_x509_parse(): illegal length in timestamp in %s%ecve-2013-6420.php on line 3
 string(27) "stefan.esser@sektioneins.de"
 int(-1)
 Done
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl.cnf php-5.3.29/ext/openssl/tests/openssl.cnf
--- php-5.3.29-ori/ext/openssl/tests/openssl.cnf	2019-01-25 02:38:50.308556347 +0800
+++ php-5.3.29/ext/openssl/tests/openssl.cnf	2019-01-26 02:28:51.216128000 +0800
@@ -3,7 +3,7 @@
 default_keyfile 	= privkey.pem
 distinguished_name	= req_distinguished_name
 attributes		= req_attributes
-x509_extensions	= v3_ca	# The extentions to add to the self signed cert
+x509_extensions	= v3_ca	# The extensions to add to the self signed cert
 string_mask = MASK:4294967295
 
 
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_csr_export_bacis.phpt php-5.3.29/ext/openssl/tests/openssl_csr_export_bacis.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_csr_export_bacis.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_csr_export_bacis.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,48 @@
+--TEST--
+openssl_csr_export() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+$wrong = "wrong";
+$config = __DIR__ . DIRECTORY_SEPARATOR . 'openssl.cnf';
+$config_arg = array('config' => $config);
+
+$dn = array(
+	"countryName" => "BR",
+	"stateOrProvinceName" => "Rio Grande do Sul",
+	"localityName" => "Porto Alegre",
+	"commonName" => "Henrique do N. Angelo",
+	"emailAddress" => "hnangelo@php.net"
+);
+
+$args = array(
+	"digest_alg" => "sha1",
+	"private_key_bits" => 2048,
+	"private_key_type" => OPENSSL_KEYTYPE_DSA,
+	"encrypt_key" => true,
+	"config" => $config,
+);
+
+$privkey = openssl_pkey_new($config_arg);
+$csr = openssl_csr_new($dn, $privkey, $args);
+var_dump(openssl_csr_export($csr, $output));
+var_dump(openssl_csr_export($wrong, $output));
+var_dump(openssl_csr_export($privkey, $output));
+var_dump(openssl_csr_export(array(), $output));
+var_dump(openssl_csr_export($csr, $output, false));
+?>
+--EXPECTF--
+bool(true)
+
+Warning: openssl_csr_export() expects parameter 1 to be resource, string given in %s on line %d
+NULL
+
+Warning: openssl_csr_export(): supplied resource is not a valid OpenSSL X.509 CSR resource in %s on line %d
+
+Warning: openssl_csr_export(): cannot get CSR from parameter 1 in %s on line %d
+bool(false)
+
+Warning: openssl_csr_export() expects parameter 1 to be resource, array given in %s on line %d
+NULL
+bool(true)
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_csr_get_subject_basic.phpt php-5.3.29/ext/openssl/tests/openssl_csr_get_subject_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_csr_get_subject_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_csr_get_subject_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,34 @@
+--TEST--
+openssl_csr_get_subject() tests
+--SKIPIF--
+<?php 
+if (!extension_loaded("openssl")) die("skip"); 
+if (!function_exists("utf8_decode")) die("skip");
+?>
+--FILE--
+<?php
+
+$csr = file_get_contents(dirname(__FILE__) . '/cert.csr');
+if ($out = openssl_csr_get_subject($csr, 1)) {
+	var_dump($out);
+}
+echo "\n";
+$cn = utf8_decode($out['CN']);
+var_dump($cn);
+--EXPECTF--	
+array(6) {
+  ["C"]=>
+  string(2) "NL"
+  ["ST"]=>
+  string(13) "Noord Brabant"
+  ["L"]=>
+  string(4) "Uden"
+  ["O"]=>
+  string(10) "Triconnect"
+  ["OU"]=>
+  string(10) "Triconnect"
+  ["CN"]=>
+  string(15) "*.triconnect.nl"
+}
+
+string(15) "*.triconnect.nl"
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_csr_new_basic.phpt php-5.3.29/ext/openssl/tests/openssl_csr_new_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_csr_new_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_csr_new_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,41 @@
+--TEST--
+openssl_csr_new() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+
+$a = 1;
+var_dump(openssl_csr_new(1,$a));
+var_dump(openssl_csr_new(1,$a,1,1));
+$a = array();
+
+$conf = array('config' => dirname(__FILE__) . DIRECTORY_SEPARATOR . 'openssl.cnf');
+var_dump(openssl_csr_new(array(), $a, $conf, array()));
+
+// this leaks
+$a = array(1,2);
+$b = array(1,2);
+var_dump(openssl_csr_new($a, $b, $conf));
+
+// options type check
+$x = openssl_pkey_new($conf);
+var_dump(openssl_csr_new(["countryName" => "DE"], $x, $conf + ["x509_extensions" => 0xDEADBEEF]));
+
+
+echo "Done\n";
+?>
+--EXPECTF--	
+Warning: openssl_csr_new() expects parameter 1 to be array, integer given in %s on line %d
+NULL
+
+Warning: openssl_csr_new() expects parameter 1 to be array, integer given in %s on line %d
+NULL
+
+Warning: openssl_csr_new(): key array must be of the form array(0 => key, 1 => phrase) in %s on line %d
+
+Warning: openssl_csr_new(): add1_attr_by_txt challengePassword_min -> 4 (failed; check error queue and value of string_mask OpenSSL option if illegal characters are reported) in %s on line %d
+bool(false)
+resource(%d) of type (OpenSSL X.509 CSR)
+resource(%d) of type (OpenSSL X.509 CSR)
+Done
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_csr_sign_basic.phpt php-5.3.29/ext/openssl/tests/openssl_csr_sign_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_csr_sign_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_csr_sign_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,80 @@
+--TEST--
+openssl_csr_sign() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+$cert = "file://" . dirname(__FILE__) . "/cert.crt";
+$priv = "file://" . dirname(__FILE__) . "/private_rsa_1024.key";
+$wrong = "wrong";
+$pub = "file://" . dirname(__FILE__) . "/public.key";
+$config = __DIR__ . DIRECTORY_SEPARATOR . 'openssl.cnf';
+$config_arg = array('config' => $config);
+
+$dn = array(
+	"countryName" => "BR",
+	"stateOrProvinceName" => "Rio Grande do Sul",
+	"localityName" => "Porto Alegre",
+	"commonName" => "Henrique do N. Angelo",
+	"emailAddress" => "hnangelo@php.net"
+	);
+
+$args = array(
+	"digest_alg" => "sha1",
+	"private_key_bits" => 2048,
+	"private_key_type" => OPENSSL_KEYTYPE_DSA,
+	"encrypt_key" => true,
+	"config" => $config
+	);
+
+$privkey = openssl_pkey_new($config_arg);
+$csr = openssl_csr_new($dn, $privkey, $args);
+var_dump(openssl_csr_sign($csr, null, $privkey, 365, $args));
+var_dump(openssl_csr_sign($csr, null, $privkey, 365, $config_arg));
+var_dump(openssl_csr_sign($csr, $cert, $priv, 365, $config_arg));
+var_dump(openssl_csr_sign($csr, $wrong, $privkey, 365));
+var_dump(openssl_csr_sign($csr, null, $wrong, 365));
+var_dump(openssl_csr_sign($csr, null, $privkey, $wrong));
+var_dump(openssl_csr_sign($csr, null, $privkey, 365, $wrong));
+var_dump(openssl_csr_sign($wrong, null, $privkey, 365));
+var_dump(openssl_csr_sign(array(), null, $privkey, 365));
+var_dump(openssl_csr_sign($csr, array(), $privkey, 365));
+var_dump(openssl_csr_sign($csr, null, array(), 365));
+var_dump(openssl_csr_sign($csr, null, $privkey, array()));
+var_dump(openssl_csr_sign($csr, null, $privkey, 365, $config_arg));
+?>
+--EXPECTF--
+resource(%d) of type (OpenSSL X.509)
+resource(%d) of type (OpenSSL X.509)
+resource(%d) of type (OpenSSL X.509)
+
+Warning: openssl_csr_sign(): cannot get cert from parameter 2 in %s on line %d
+bool(false)
+
+Warning: openssl_csr_sign(): cannot get private key from parameter 3 in %s on line %d
+bool(false)
+
+Warning: openssl_csr_sign() expects parameter 4 to be long, string given in %s on line %d
+NULL
+
+Warning: openssl_csr_sign() expects parameter 5 to be array, string given in %s on line %d
+NULL
+
+Warning: openssl_csr_sign(): cannot get CSR from parameter 1 in %s on line %d
+bool(false)
+
+Warning: openssl_csr_sign(): cannot get CSR from parameter 1 in %s on line %d
+bool(false)
+
+Warning: openssl_csr_sign(): cannot get cert from parameter 2 in %s on line %d
+bool(false)
+
+Warning: openssl_csr_sign(): key array must be of the form array(0 => key, 1 => phrase) in %s on line %d
+
+Warning: openssl_csr_sign(): cannot get private key from parameter 3 in %s on line %d
+bool(false)
+
+Warning: openssl_csr_sign() expects parameter 4 to be long, array given in %s on line %d
+NULL
+resource(%d) of type (OpenSSL X.509)
+
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_decrypt_basic.phpt php-5.3.29/ext/openssl/tests/openssl_decrypt_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_decrypt_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_decrypt_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,31 @@
+--TEST--
+openssl_decrypt() tests dependent on openssl_encrypt
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+$data = "openssl_encrypt() and openssl_decrypt() tests";
+$method = "AES-128-CBC";
+$password = "openssl";
+
+$ivlen = openssl_cipher_iv_length($method);
+$iv    = '';
+srand(time() + ((microtime(true) * 1000000) % 1000000));
+while(strlen($iv) < $ivlen) $iv .= chr(rand(0,255));
+
+$encrypted = openssl_encrypt($data, $method, $password, 0, $iv);
+$output = openssl_decrypt($encrypted, $method, $password, 0, $iv);
+var_dump($output);
+$encrypted = openssl_encrypt($data, $method, $password, OPENSSL_RAW_DATA, $iv);
+$output = openssl_decrypt($encrypted, $method, $password, OPENSSL_RAW_DATA, $iv);
+var_dump($output);
+// if we want to manage our own padding
+$padded_data = $data . str_repeat(' ', 16 - (strlen($data) % 16));
+$encrypted = openssl_encrypt($padded_data, $method, $password, OPENSSL_RAW_DATA|OPENSSL_ZERO_PADDING, $iv);
+$output = openssl_decrypt($encrypted, $method, $password, OPENSSL_RAW_DATA|OPENSSL_ZERO_PADDING, $iv);
+var_dump(rtrim($output));
+?>
+--EXPECT--
+string(45) "openssl_encrypt() and openssl_decrypt() tests"
+string(45) "openssl_encrypt() and openssl_decrypt() tests"
+string(45) "openssl_encrypt() and openssl_decrypt() tests"
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_decrypt_error.phpt php-5.3.29/ext/openssl/tests/openssl_decrypt_error.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_decrypt_error.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_decrypt_error.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -12,7 +12,7 @@
 
 $encrypted = openssl_encrypt($data, $method, $password);
 var_dump($encrypted); /* Not passing $iv should be the same as all-NULL iv, but with a warning */
-var_dump(openssl_encrypt($data, $method, $password, false, $iv)); 
+var_dump(openssl_encrypt($data, $method, $password, 0, $iv)); 
 var_dump(openssl_decrypt($encrypted, $method, $wrong));
 var_dump(openssl_decrypt($encrypted, $wrong, $password));
 var_dump(openssl_decrypt($wrong, $method, $password));
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_error_string_basic.phpt php-5.3.29/ext/openssl/tests/openssl_error_string_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_error_string_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_error_string_basic.phpt	2019-01-26 11:29:19.967117841 +0800
@@ -0,0 +1,167 @@
+--TEST--
+openssl_error_string() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+// helper function to check openssl errors
+function expect_openssl_errors($name, $expected_error_codes) {
+	$expected_errors = array_fill_keys($expected_error_codes, false);
+	while (($error_string = openssl_error_string()) !== false) {
+		if (strlen($error_string) > 14) {
+			$error_code = substr($error_string, 6, 8);
+			if (isset($expected_errors[$error_code])) {
+				$expected_errors[$error_code] = true;
+			}
+		}
+	}
+
+	$fail = false;
+	foreach ($expected_errors as $error_code => $error_code_found) {
+		if (!$error_code_found) {
+			$fail = true;
+			echo "$name: no error code $error_code\n";
+		}
+	}
+
+	if (!$fail) {
+		echo "$name: ok\n";
+	}
+}
+
+// helper for debugging errors
+function dump_openssl_errors($name) {
+	echo "\n$name\n";
+	while (($error_string = openssl_error_string()) !== false) {
+		var_dump($error_string);
+	}
+}
+
+// common output file
+$output_file =  __DIR__ . "/openssl_error_string_basic_output.tmp";
+// invalid file for read is something that does not exist in current directory
+$invalid_file_for_read = __DIR__ . "/invalid_file_for_read_operation.txt";
+// invalid file for is the test dir as writting file to existing dir should alway fail
+$invalid_file_for_write = __DIR__;
+// crt file
+$crt_file = "file://" . __DIR__ . "/cert.crt";
+// csr file
+$csr_file = "file://" . __DIR__ . "/cert.csr";
+// public key file
+$public_key_file = "file://" .__DIR__ . "/public.key";
+// private key file
+$private_key_file = "file://" .__DIR__ . "/private_rsa_1024.key";
+// private key file with password (password is 'php')
+$private_key_file_with_pass = "file://" .__DIR__ . "/private_rsa_2048_pass_php.key";
+
+// ENCRYPTION
+$data = "test";
+$method = "AES-128-ECB";
+$enc_key = str_repeat('x', 40);
+// error because password is longer then key length and
+// EVP_CIPHER_CTX_set_key_length fails for AES
+openssl_encrypt($data, $method, $enc_key);
+$enc_error = openssl_error_string();
+var_dump($enc_error);
+// make sure that error is cleared now
+var_dump(openssl_error_string());
+// internally OpenSSL ERR won't save more than 15 (16 - 1) errors so lets test it
+for ($i = 0; $i < 20; $i++) {
+	openssl_encrypt($data, $method, $enc_key);
+}
+$error_queue_size = 0;
+while (($enc_error_new = openssl_error_string()) !== false) {
+	if ($enc_error_new !== $enc_error) {
+		echo "The new encoding error doesn't match the expected one\n";
+	}
+	++$error_queue_size;
+}
+var_dump($error_queue_size);
+echo "\n";
+
+// PKEY
+echo "PKEY errors\n";
+// file for pkey (file:///) fails when opennig (BIO_new_file)
+@openssl_pkey_export_to_file("file://" . $invalid_file_for_read, $output_file);
+expect_openssl_errors('openssl_pkey_export_to_file opening', ['02001002', '2006D080']);
+// file or private pkey is not correct PEM - failing PEM_read_bio_PrivateKey
+@openssl_pkey_export_to_file($csr_file, $output_file);
+expect_openssl_errors('openssl_pkey_export_to_file pem', ['0906D06C']);
+// file to export cannot be written
+@openssl_pkey_export_to_file($private_key_file, $invalid_file_for_write);
+expect_openssl_errors('openssl_pkey_export_to_file write', ['2006D002', '09072007']);
+// succesful export
+@openssl_pkey_export($private_key_file_with_pass, $out, 'wrong pwd');
+expect_openssl_errors('openssl_pkey_export', ['06065064', '0906A065']);
+// invalid x509 for getting public key
+@openssl_pkey_get_public($private_key_file);
+expect_openssl_errors('openssl_pkey_get_public', ['0906D06C']);
+// private encrypt with unknown padding
+@openssl_private_encrypt("data", $crypted, $private_key_file, 1000);
+expect_openssl_errors('openssl_private_encrypt', ['04066076']);
+// private decrypt with failed padding check
+@openssl_private_decrypt("data", $crypted, $private_key_file);
+expect_openssl_errors('openssl_private_decrypt', ['04065072']);
+// public encrypt and decrypt with failed padding check and padding
+@openssl_public_encrypt("data", $crypted, $public_key_file, 1000);
+@openssl_public_decrypt("data", $crypted, $public_key_file);
+expect_openssl_errors('openssl_private_(en|de)crypt padding', OPENSSL_VERSION_NUMBER < 0x10100000 ? ['0906D06C', '04068076', '0407006A', '04067072'] : ['0906D06C', '04068076', '04067072']);
+
+// X509
+echo "X509 errors\n";
+// file for x509 (file:///) fails when opennig (BIO_new_file)
+@openssl_x509_export_to_file("file://" . $invalid_file_for_read, $output_file);
+expect_openssl_errors('openssl_x509_export_to_file open', ['02001002']);
+// file or str cert is not correct PEM - failing PEM_read_bio_X509 or PEM_ASN1_read_bio
+@openssl_x509_export_to_file($csr_file, $output_file);
+expect_openssl_errors('openssl_x509_export_to_file pem', ['0906D06C']);
+// file to export cannot be written
+@openssl_x509_export_to_file($crt_file, $invalid_file_for_write);
+expect_openssl_errors('openssl_x509_export_to_file write', ['2006D002']);
+// checking purpose fails because there is no such purpose 1000
+@openssl_x509_checkpurpose($crt_file, 1000);
+expect_openssl_errors('openssl_x509_checkpurpose purpose', ['0B086079']);
+
+// CSR
+echo "CSR errors\n";
+// file for csr (file:///) fails when opennig (BIO_new_file)
+@openssl_csr_get_subject("file://" . $invalid_file_for_read);
+expect_openssl_errors('openssl_csr_get_subject open', ['02001002', '2006D080', '20068079', '0906D06C']);
+// file or str csr is not correct PEM - failing PEM_read_bio_X509_REQ
+@openssl_csr_get_subject($crt_file);
+expect_openssl_errors('openssl_csr_get_subjec pem', ['0906D06C']);
+
+// other possible cuases that are difficult to catch:
+// - ASN1_STRING_to_UTF8 fails in add_assoc_name_entry
+// - invalid php_x509_request field (NULL) would cause error with CONF_get_string
+
+?>
+--CLEAN--
+<?php
+$output_file =  __DIR__ . "/openssl_error_string_basic_output.tmp";
+if (is_file($output_file)) {
+	unlink($output_file);
+}
+?>
+--EXPECT--
+string(89) "error:0607A082:digital envelope routines:EVP_CIPHER_CTX_set_key_length:invalid key length"
+bool(false)
+int(15)
+
+PKEY errors
+openssl_pkey_export_to_file opening: ok
+openssl_pkey_export_to_file pem: ok
+openssl_pkey_export_to_file write: ok
+openssl_pkey_export: ok
+openssl_pkey_get_public: ok
+openssl_private_encrypt: ok
+openssl_private_decrypt: ok
+openssl_private_(en|de)crypt padding: ok
+X509 errors
+openssl_x509_export_to_file open: ok
+openssl_x509_export_to_file pem: ok
+openssl_x509_export_to_file write: ok
+openssl_x509_checkpurpose purpose: ok
+CSR errors
+openssl_csr_get_subject open: ok
+openssl_csr_get_subjec pem: ok
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_get_cipher_methods.phpt php-5.3.29/ext/openssl/tests/openssl_get_cipher_methods.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_get_cipher_methods.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_get_cipher_methods.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,16 @@
+--TEST--
+openssl_get_cipher_methods basic test
+--CREDITS--
+marcosptf - <marcosptf@yahoo.com.br>
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) print "skip";
+?>
+--FILE--
+<?php
+var_dump(is_array(openssl_get_cipher_methods(true)));
+var_dump(is_array(openssl_get_cipher_methods(false)));
+?>
+--EXPECT--
+bool(true)
+bool(true)
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_get_md_methods.phpt php-5.3.29/ext/openssl/tests/openssl_get_md_methods.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_get_md_methods.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_get_md_methods.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,16 @@
+--TEST--
+openssl_get_md_methods basic test
+--CREDITS--
+marcosptf - <marcosptf@yahoo.com.br>
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) print "skip";
+?>
+--FILE--
+<?php
+var_dump(is_array(openssl_get_md_methods(true)));
+var_dump(is_array(openssl_get_md_methods(false)));
+?>
+--EXPECT--
+bool(true)
+bool(true)
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_open_basic.phpt php-5.3.29/ext/openssl/tests/openssl_open_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_open_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_open_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,28 @@
+--TEST--
+openssl_open() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+$data = "openssl_open() test";
+$pub_key = "file://" . dirname(__FILE__) . "/public.key";
+$priv_key = "file://" . dirname(__FILE__) . "/private_rsa_1024.key";
+$wrong = "wrong";
+
+openssl_seal($data, $sealed, $ekeys, array($pub_key, $pub_key, $pub_key));
+openssl_open($sealed, $output, $ekeys[0], $priv_key);
+var_dump($output);
+openssl_open($sealed, $output2, $ekeys[1], $wrong);
+var_dump($output2);
+openssl_open($sealed, $output3, $ekeys[2], $priv_key);
+var_dump($output3);
+openssl_open($sealed, $output4, $wrong, $priv_key);
+var_dump($output4);
+?>
+--EXPECTF--
+string(19) "openssl_open() test"
+
+Warning: openssl_open(): unable to coerce parameter 4 into a private key in %s on line %d
+NULL
+string(19) "openssl_open() test"
+NULL
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_pbkdf2_basic.phpt php-5.3.29/ext/openssl/tests/openssl_pbkdf2_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_pbkdf2_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_pbkdf2_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,26 @@
+--TEST--
+openssl_pbkdf2() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl") || !function_exists("openssl_pbkdf2")) print "skip"; ?>
+--FILE--
+<?php
+// official test vectors
+var_dump(bin2hex(openssl_pbkdf2('password', 'salt', 20, 1)));
+var_dump(bin2hex(openssl_pbkdf2('password', 'salt', 20, 2)));
+var_dump(bin2hex(openssl_pbkdf2('password', 'salt', 20, 4096)));
+
+/* really slow but should be:
+string(40) "eefe3d61cd4da4e4e9945b3d6ba2158c2634e984"
+var_dump(bin2hex(openssl_pbkdf2('password', 'salt', 20, 16777216)));
+*/
+
+var_dump(bin2hex(openssl_pbkdf2('passwordPASSWORDpassword', 'saltSALTsaltSALTsaltSALTsaltSALTsalt', 25, 4096)));
+var_dump(bin2hex(openssl_pbkdf2("pass\0word", "sa\0lt", 16, 4096)));
+
+?>
+--EXPECTF--
+string(40) "0c60c80f961f0e71f3a9b524af6012062fe037a6"
+string(40) "ea6c014dc72d6f8ccd1ed92ace1d41f0d8de8957"
+string(40) "4b007901b765489abead49d926f721d065a429c1"
+string(50) "3d2eec4fe41c849b80c8d83662c0e44a8b291a964cf2f07038"
+string(32) "56fa6aa75548099dcc37d7f03425e0c3"
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_peer_fingerprint_basic.phpt php-5.3.29/ext/openssl/tests/openssl_peer_fingerprint_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_peer_fingerprint_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_peer_fingerprint_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,54 @@
+--TEST--
+Testing peer fingerprint on connection
+--SKIPIF--
+<?php 
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug54992.pem'
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    @stream_socket_accept($server, 1);
+    @stream_socket_accept($server, 1);
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $clientFlags = STREAM_CLIENT_CONNECT;
+    $clientCtx = stream_context_create(['ssl' => [
+        'verify_peer'       => true,
+        'cafile'            => __DIR__ . '/bug54992-ca.pem',
+        'capture_peer_cert'    => true,
+        'peer_name'          => 'bug54992.local',
+    ]]);
+
+    phpt_wait();
+
+    // should be: 81cafc260aa8d82956ebc6212a362ecc
+    stream_context_set_option($clientCtx, 'ssl', 'peer_fingerprint', '81cafc260aa8d82956ebc6212a362ece');
+    var_dump(stream_socket_client($serverUri, $errno, $errstr, 2, $clientFlags, $clientCtx));
+
+    stream_context_set_option($clientCtx, 'ssl', 'peer_fingerprint', [
+        'sha256' => '78ea579f2c3b439359dec5dac9d445108772927427c4780037e87df3799a0aa0',
+    ]);
+    var_dump(stream_socket_client($serverUri, $errno, $errstr, 2, $clientFlags, $clientCtx));
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+Warning: stream_socket_client(): peer_fingerprint match failure in %s on line %d
+
+Warning: stream_socket_client(): Failed to enable crypto in %s on line %d
+
+Warning: stream_socket_client(): unable to connect to ssl://127.0.0.1:64321 (Unknown error) in %s on line %d
+bool(false)
+resource(%d) of type (stream)
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_pkcs7_decrypt_basic.phpt php-5.3.29/ext/openssl/tests/openssl_pkcs7_decrypt_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_pkcs7_decrypt_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_pkcs7_decrypt_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,64 @@
+--TEST--
+openssl_pkcs7_decrypt() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+$infile = dirname(__FILE__) . "/cert.crt";
+$privkey = "file://" . dirname(__FILE__) . "/private_rsa_1024.key";
+$encrypted = tempnam("/tmp", "ssl");
+if ($encrypted === false)
+	die("failed to get a temporary filename!");
+$outfile = tempnam("/tmp", "ssl");
+if ($outfile === false) {
+	unlink($outfile);
+	die("failed to get a temporary filename!");
+}
+
+$single_cert = "file://" . dirname(__FILE__) . "/cert.crt";
+$headers = array("test@test", "testing openssl_pkcs7_encrypt()");
+$wrong = "wrong";
+$empty = "";
+
+openssl_pkcs7_encrypt($infile, $encrypted, $single_cert, $headers);
+var_dump(openssl_pkcs7_decrypt($encrypted, $outfile, $single_cert, $privkey));
+var_dump(openssl_pkcs7_decrypt($encrypted, $outfile, $single_cert, $wrong));
+var_dump(openssl_pkcs7_decrypt($encrypted, $outfile, $wrong, $privkey));
+var_dump(openssl_pkcs7_decrypt($encrypted, $outfile, null, $privkey));
+var_dump(openssl_pkcs7_decrypt($wrong, $outfile, $single_cert, $privkey));
+var_dump(openssl_pkcs7_decrypt($empty, $outfile, $single_cert, $privkey));
+var_dump(openssl_pkcs7_decrypt($encrypted, $empty, $single_cert, $privkey));
+var_dump(openssl_pkcs7_decrypt($encrypted, $outfile, $empty, $privkey));
+var_dump(openssl_pkcs7_decrypt($encrypted, $outfile, $single_cert, $empty));
+
+if (file_exists($encrypted)) {
+	echo "true\n";
+	unlink($encrypted);
+}
+if (file_exists($outfile)) {
+	echo "true\n";
+	unlink($outfile);
+}
+?>
+--EXPECTF--
+bool(true)
+
+Warning: openssl_pkcs7_decrypt(): unable to get private key in %s on line %d
+bool(false)
+
+Warning: openssl_pkcs7_decrypt(): unable to coerce parameter 3 to x509 cert in %s on line %d
+bool(false)
+
+Warning: openssl_pkcs7_decrypt(): unable to coerce parameter 3 to x509 cert in %s on line %d
+bool(false)
+bool(false)
+bool(false)
+bool(false)
+
+Warning: openssl_pkcs7_decrypt(): unable to coerce parameter 3 to x509 cert in %s on line %d
+bool(false)
+
+Warning: openssl_pkcs7_decrypt(): unable to get private key in %s on line %d
+bool(false)
+true
+true
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_pkcs7_decrypt_error.phpt php-5.3.29/ext/openssl/tests/openssl_pkcs7_decrypt_error.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_pkcs7_decrypt_error.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_pkcs7_decrypt_error.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,43 @@
+--TEST--
+openssl_pkcs7_decrypt() and invalid parameters
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+
+function myErrorHandler($errno, $errstr, $errfile, $errline) {
+	var_dump($errstr);
+} 
+set_error_handler("myErrorHandler"); 
+
+$a = 1; 
+$b = 1; 
+$c = new stdclass; 
+$d = new stdclass; 
+
+var_dump(openssl_pkcs7_decrypt($a, $b, $c, $d));
+var_dump($c);
+
+var_dump(openssl_pkcs7_decrypt($b, $b, $b, $b));
+var_dump(openssl_pkcs7_decrypt($a, $b, "", ""));
+var_dump(openssl_pkcs7_decrypt($a, $b, true, false));
+var_dump(openssl_pkcs7_decrypt($a, $b, 0, 0));
+
+echo "Done\n";
+?>
+--EXPECTF--	
+string(57) "Object of class stdClass could not be converted to string"
+string(45) "Object of class stdClass to string conversion"
+string(66) "openssl_pkcs7_decrypt(): unable to coerce parameter 3 to x509 cert"
+bool(false)
+object(stdClass)#1 (0) {
+}
+string(66) "openssl_pkcs7_decrypt(): unable to coerce parameter 3 to x509 cert"
+bool(false)
+string(66) "openssl_pkcs7_decrypt(): unable to coerce parameter 3 to x509 cert"
+bool(false)
+string(66) "openssl_pkcs7_decrypt(): unable to coerce parameter 3 to x509 cert"
+bool(false)
+string(66) "openssl_pkcs7_decrypt(): unable to coerce parameter 3 to x509 cert"
+bool(false)
+Done
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_pkcs7_encrypt_basic.phpt php-5.3.29/ext/openssl/tests/openssl_pkcs7_encrypt_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_pkcs7_encrypt_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_pkcs7_encrypt_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,64 @@
+--TEST--
+openssl_pkcs7_encrypt() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+$infile = dirname(__FILE__) . "/cert.crt";
+$outfile = tempnam("/tmp", "ssl");
+if ($outfile === false)
+	die("failed to get a temporary filename!");
+$outfile2 = tempnam("/tmp", "ssl");
+if ($outfile2 === false)
+	die("failed to get a temporary filename!");
+
+$single_cert = "file://" . dirname(__FILE__) . "/cert.crt";
+$privkey = "file://" . dirname(__FILE__) . "/private_rsa_1024.key";
+$multi_certs = array($single_cert, $single_cert);
+$assoc_headers = array("To" => "test@test", "Subject" => "testing openssl_pkcs7_encrypt()");
+$headers = array("test@test", "testing openssl_pkcs7_encrypt()");
+$empty_headers = array();
+$wrong = "wrong";
+$empty = "";
+
+var_dump(openssl_pkcs7_encrypt($infile, $outfile, $single_cert, $headers));
+var_dump(openssl_pkcs7_decrypt($outfile, $outfile2, $single_cert, $privkey));
+var_dump(openssl_pkcs7_encrypt($infile, $outfile, $single_cert, $assoc_headers));
+var_dump(openssl_pkcs7_encrypt($infile, $outfile, $single_cert, $empty_headers));
+var_dump(openssl_pkcs7_encrypt($infile, $outfile, $single_cert, $wrong));
+var_dump(openssl_pkcs7_encrypt($wrong, $outfile, $single_cert, $headers));
+var_dump(openssl_pkcs7_encrypt($empty, $outfile, $single_cert, $headers));
+var_dump(openssl_pkcs7_encrypt($infile, $empty, $single_cert, $headers));
+var_dump(openssl_pkcs7_encrypt($infile, $outfile, $wrong, $headers));
+var_dump(openssl_pkcs7_encrypt($infile, $outfile, $empty, $headers));
+var_dump(openssl_pkcs7_encrypt($infile, $outfile, $single_cert, $empty));
+var_dump(openssl_pkcs7_encrypt($infile, $outfile, $multi_certs, $headers));
+
+if (file_exists($outfile)) {
+	echo "true\n";
+	unlink($outfile);
+}
+if (file_exists($outfile2)) {
+	echo "true\n";
+	unlink($outfile2);
+}
+?>
+--EXPECTF--
+bool(true)
+bool(true)
+bool(true)
+bool(true)
+
+Warning: openssl_pkcs7_encrypt() expects parameter 4 to be array, string given in %s on line %d
+bool(false)
+bool(false)
+bool(false)
+bool(false)
+bool(false)
+bool(false)
+
+Warning: openssl_pkcs7_encrypt() expects parameter 4 to be array, string given in %s on line %d
+bool(false)
+bool(true)
+true
+true
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_pkcs7_sign_basic.phpt php-5.3.29/ext/openssl/tests/openssl_pkcs7_sign_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_pkcs7_sign_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_pkcs7_sign_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,66 @@
+--TEST--
+openssl_pkcs7_sign() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+$infile = dirname(__FILE__) . "/cert.crt";
+$outfile = tempnam("/tmp", "ssl");
+if ($outfile === false) {
+	die("failed to get a temporary filename!");
+}
+
+$privkey = "file://" . dirname(__FILE__) . "/private_rsa_1024.key";
+$single_cert = "file://" . dirname(__FILE__) . "/cert.crt";
+$assoc_headers = array("To" => "test@test", "Subject" => "testing openssl_pkcs7_sign()");
+$headers = array("test@test", "testing openssl_pkcs7_sign()");
+$empty_headers = array();
+$wrong = "wrong";
+$empty = "";
+
+var_dump(openssl_pkcs7_sign($infile, $outfile, $single_cert, $privkey, $headers));
+var_dump(openssl_pkcs7_sign($infile, $outfile, $single_cert, $privkey, $assoc_headers));
+var_dump(openssl_pkcs7_sign($infile, $outfile, $single_cert, $privkey, $empty_headers));
+var_dump(openssl_pkcs7_sign($infile, $outfile, $single_cert, $privkey, $wrong));
+var_dump(openssl_pkcs7_sign($wrong, $outfile, $single_cert, $privkey, $headers));
+var_dump(openssl_pkcs7_sign($empty, $outfile, $single_cert, $privkey, $headers));
+var_dump(openssl_pkcs7_sign($infile, $empty, $single_cert, $privkey, $headers));
+var_dump(openssl_pkcs7_sign($infile, $outfile, $wrong, $privkey, $headers));
+var_dump(openssl_pkcs7_sign($infile, $outfile, $empty, $privkey, $headers));
+var_dump(openssl_pkcs7_sign($infile, $outfile, $single_cert, $privkey, $empty));
+var_dump(openssl_pkcs7_sign($infile, $outfile, $single_cert, $wrong, $headers));
+
+if (file_exists($outfile)) {
+	echo "true\n";
+	unlink($outfile);
+}
+?>
+--EXPECTF--
+bool(true)
+bool(true)
+bool(true)
+
+Warning: openssl_pkcs7_sign() expects parameter 5 to be array, string given in %s on line %d
+NULL
+
+Warning: openssl_pkcs7_sign(): error opening input file %s in %s on line %d
+bool(false)
+
+Warning: openssl_pkcs7_sign(): error opening input file %s in %s on line %d
+bool(false)
+
+Warning: openssl_pkcs7_sign(): error opening output file %s in %s on line %d
+bool(false)
+
+Warning: openssl_pkcs7_sign(): error getting cert in %s on line %d
+bool(false)
+
+Warning: openssl_pkcs7_sign(): error getting cert in %s on line %d
+bool(false)
+
+Warning: openssl_pkcs7_sign() expects parameter 5 to be array, string given in %s on line %d
+NULL
+
+Warning: openssl_pkcs7_sign(): error getting private key in %s on line %d
+bool(false)
+true
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_pkey_export_basic.phpt php-5.3.29/ext/openssl/tests/openssl_pkey_export_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_pkey_export_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_pkey_export_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,54 @@
+--TEST--
+openssl_pkey_export() with EC key
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip");
+if (!defined('OPENSSL_KEYTYPE_EC')) die("skip no EC available");
+?>
+--FILE--
+<?php
+$key = openssl_pkey_get_private('file://' . dirname(__FILE__) . '/private_ec.key');
+var_dump($key);
+
+$config_arg = array("config" => __DIR__ . DIRECTORY_SEPARATOR . "openssl.cnf");
+
+var_dump(openssl_pkey_export($key, $output, NULL, $config_arg));
+echo $output;
+
+// Load the private key from the exported pem string
+$details = openssl_pkey_get_details(openssl_pkey_get_private($output));
+var_dump(OPENSSL_KEYTYPE_EC === $details['type']);
+
+// Export key with passphrase
+openssl_pkey_export($key, $output, 'passphrase', $config_arg);
+
+$details = openssl_pkey_get_details(openssl_pkey_get_private($output, 'passphrase'));
+var_dump(OPENSSL_KEYTYPE_EC === $details['type']);
+
+// Read public key
+$pKey = openssl_pkey_get_public('file://' . dirname(__FILE__) . '/public_ec.key');
+var_dump($pKey);
+// The details are the same for a public or private key
+var_dump($details === openssl_pkey_get_details($pKey));
+
+
+// Export to file
+$tempname = tempnam(sys_get_temp_dir(), 'openssl_ec');
+var_dump(openssl_pkey_export_to_file($key, $tempname, NULL, $config_arg));
+$details = openssl_pkey_get_details(openssl_pkey_get_private('file://' . $tempname));
+var_dump(OPENSSL_KEYTYPE_EC === $details['type']);
+
+// Clean the temporary file
+@unlink($tempname);
+
+?>
+--EXPECTF--
+resource(%d) of type (OpenSSL key)
+bool(true)
+-----BEGIN EC PRIVATE KEY-----%a-----END EC PRIVATE KEY-----
+bool(true)
+bool(true)
+resource(%d) of type (OpenSSL key)
+bool(true)
+bool(true)
+bool(true)
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_pkey_get_details_basic.phpt php-5.3.29/ext/openssl/tests/openssl_pkey_get_details_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_pkey_get_details_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_pkey_get_details_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,28 @@
+--TEST--
+openssl_pkey_get_details() with EC key
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip");
+if (!defined('OPENSSL_KEYTYPE_EC')) die("skip no EC available");
+?>
+--FILE--
+<?php
+$key = openssl_pkey_get_private('file://' . dirname(__FILE__) . '/private_ec.key');
+
+print_r(openssl_pkey_get_details($key));
+?>
+--EXPECTF--
+Array
+(
+    [bits] => 256
+    [key] => -----BEGIN PUBLIC KEY-----%a
+-----END PUBLIC KEY-----
+
+    [ec] => Array
+        (
+            [curve_name] => prime256v1
+            [curve_oid] => 1.2.840.10045.3.1.7
+        )
+
+    [type] => 3
+)
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_pkey_new_basic.phpt php-5.3.29/ext/openssl/tests/openssl_pkey_new_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_pkey_new_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_pkey_new_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,106 @@
+--TEST--
+openssl_pkey_new() basic usage tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+function openssl_pkey_test_cmp($expected, $bin_key) {
+	var_dump(strcasecmp(ltrim($expected, '0'), bin2hex($bin_key)));
+}
+
+// RSA
+$nhex = "BBF82F090682CE9C2338AC2B9DA871F7368D07EED41043A440D6B6F07454F51F" .
+		"B8DFBAAF035C02AB61EA48CEEB6FCD4876ED520D60E1EC4619719D8A5B8B807F" .
+		"AFB8E0A3DFC737723EE6B4B7D93A2584EE6A649D060953748834B2454598394E" .
+		"E0AAB12D7B61A51F527A9A41F6C1687FE2537298CA2A8F5946F8E5FD091DBDCB";
+
+$ehex = "11";
+$dhex = "A5DAFC5341FAF289C4B988DB30C1CDF83F31251E0668B42784813801579641B2" .
+		"9410B3C7998D6BC465745E5C392669D6870DA2C082A939E37FDCB82EC93EDAC9" .
+		"7FF3AD5950ACCFBC111C76F1A9529444E56AAF68C56C092CD38DC3BEF5D20A93" .
+		"9926ED4F74A13EDDFBE1A1CECC4894AF9428C2B7B8883FE4463A4BC85B1CB3C1";
+
+$phex = "EECFAE81B1B9B3C908810B10A1B5600199EB9F44AEF4FDA493B81A9E3D84F632" .
+		"124EF0236E5D1E3B7E28FAE7AA040A2D5B252176459D1F397541BA2A58FB6599";
+
+$qhex = "C97FB1F027F453F6341233EAAAD1D9353F6C42D08866B1D05A0F2035028B9D86" .
+		"9840B41666B42E92EA0DA3B43204B5CFCE3352524D0416A5A441E700AF461503";
+
+$rsa= openssl_pkey_new(array(
+	'rsa' => array(
+		'n' => hex2bin($nhex),
+		'e' => hex2bin($ehex),
+		'd' => hex2bin($dhex),
+		'p' => hex2bin($phex),
+		'q' => hex2bin($qhex),
+	)
+));
+$details = openssl_pkey_get_details($rsa);
+$rsa_details = $details['rsa'];
+openssl_pkey_test_cmp($nhex, $rsa_details['n']);
+openssl_pkey_test_cmp($ehex, $rsa_details['e']);
+openssl_pkey_test_cmp($dhex, $rsa_details['d']);
+openssl_pkey_test_cmp($phex, $rsa_details['p']);
+openssl_pkey_test_cmp($qhex, $rsa_details['q']);
+
+// DSA
+$phex = '00f8000ae45b2dacb47dd977d58b719d097bdf07cb2c17660ad898518c08' .
+		'1a61659a16daadfaa406a0a994c743df5eda07e36bd0adcad921b77432ff' .
+		'24ccc31e782d647e66768122b578857e9293df78387dc8b44af2a4a3f305' .
+		'1f236b1000a3e31da489c6681b0031f7ec37c2e1091bdb698e7660f135b6' .
+		'996def90090303b7ad';
+
+$qhex = '009b3734fc9f7a4a9d6437ec314e0a78c2889af64b';
+
+$ghex = '00b320300a0bc55b8f0ec6edc218e2185250f38fbb8291db8a89227f6e41' .
+		'00d47d6ccb9c7d42fc43280ecc2ed386e81ff65bc5d6a2ae78db7372f5dc' .
+		'f780f4558e7ed3dd0c96a1b40727ac56c5165aed700a3b63997893a1fb21' .
+		'4e882221f0dd9604820dc34e2725dd6901c93e0ca56f6d76d495c332edc5' .
+		'b81747c4c447a941f3';
+$dsa = openssl_pkey_new(array(
+	'dsa' => array(
+		'p' => hex2bin($phex),
+		'q' => hex2bin($qhex),
+		'g' => hex2bin($ghex)
+	)
+));
+$details = openssl_pkey_get_details($dsa);
+$dsa_details = $details['dsa'];
+openssl_pkey_test_cmp($phex, $dsa_details['p']);
+openssl_pkey_test_cmp($qhex, $dsa_details['q']);
+openssl_pkey_test_cmp($ghex, $dsa_details['g']);
+var_dump(strlen($dsa_details['priv_key']));
+var_dump(strlen($dsa_details['pub_key']));
+
+// DH
+$phex = 'dcf93a0b883972ec0e19989ac5a2ce310e1d37717e8d9571bb7623731866e61e' .
+		'f75a2e27898b057f9891c2e27a639c3f29b60814581cd3b2ca3986d268370557' .
+		'7d45c2e7e52dc81c7a171876e5cea74b1448bfdfaf18828efd2519f14e45e382' .
+		'6634af1949e5b535cc829a483b8a76223e5d490a257f05bdff16f2fb22c583ab';
+
+$dh_details = array('p' => $phex, 'g' => '2');
+$dh = openssl_pkey_new(array(
+	'dh'=> array('p' => hex2bin($phex), 'g' => '2'))
+);
+$details = openssl_pkey_get_details($dh);
+$dh_details = $details['dh'];
+openssl_pkey_test_cmp($phex, $dh_details['p']);
+var_dump($dh_details['g']);
+var_dump(strlen($dh_details['pub_key']) > 0);
+var_dump(strlen($dh_details['priv_key']) > 0);
+?>
+--EXPECT--
+int(0)
+int(0)
+int(0)
+int(0)
+int(0)
+int(0)
+int(0)
+int(0)
+int(20)
+int(128)
+int(0)
+string(1) "2"
+bool(true)
+bool(true)
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_pkey_new_error.phpt php-5.3.29/ext/openssl/tests/openssl_pkey_new_error.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_pkey_new_error.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_pkey_new_error.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,25 @@
+--TEST--
+openssl_pkey_new() error tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+/* openssl_pkey_get_details() segfaults when getting the information
+	from openssl_pkey_new() with an empty sub-array arg 		*/
+
+$rsa = array("rsa" => array());
+$dsa = array("dsa" => array());
+$dh = array("dh" => array());
+
+openssl_pkey_get_details(openssl_pkey_new($rsa));
+openssl_pkey_get_details(openssl_pkey_new($dsa));
+openssl_pkey_get_details(openssl_pkey_new($dh));
+?>
+--EXPECTF--
+
+Warning: openssl_pkey_get_details() expects parameter 1 to be resource, boolean given in %s on line %d
+
+Warning: openssl_pkey_get_details() expects parameter 1 to be resource, boolean given in %s on line %d
+
+Warning: openssl_pkey_get_details() expects parameter 1 to be resource, boolean given in %s on line %d
+
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_private_decrypt_basic.phpt php-5.3.29/ext/openssl/tests/openssl_private_decrypt_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_private_decrypt_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_private_decrypt_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,40 @@
+--TEST--
+openssl_private_decrypt() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+$data = "Testing openssl_public_decrypt()";
+$privkey = "file://" . dirname(__FILE__) . "/private_rsa_1024.key";
+$pubkey = "file://" . dirname(__FILE__) . "/public.key";
+$wrong = "wrong";
+
+openssl_public_encrypt($data, $encrypted, $pubkey);
+var_dump(openssl_private_decrypt($encrypted, $output, $privkey));
+var_dump($output);
+var_dump(openssl_private_decrypt($encrypted, $output2, $wrong));
+var_dump($output2);
+var_dump(openssl_private_decrypt($wrong, $output3, $privkey));
+var_dump($output3);
+var_dump(openssl_private_decrypt($encrypted, $output4, array($privkey)));
+var_dump($output4);
+var_dump(openssl_private_decrypt($encrypted, $output5, array($privkey, "")));
+var_dump($output5);
+?>
+--EXPECTF--
+bool(true)
+string(32) "Testing openssl_public_decrypt()"
+
+Warning: openssl_private_decrypt(): key parameter is not a valid private key in %s on line %d
+bool(false)
+NULL
+bool(false)
+NULL
+
+Warning: openssl_private_decrypt(): key array must be of the form array(0 => key, 1 => phrase) in %s on line %d
+
+Warning: openssl_private_decrypt(): key parameter is not a valid private key in %s on line %d
+bool(false)
+NULL
+bool(true)
+string(32) "Testing openssl_public_decrypt()"
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_private_encrypt_basic.phpt php-5.3.29/ext/openssl/tests/openssl_private_encrypt_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_private_encrypt_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_private_encrypt_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,39 @@
+--TEST--
+openssl_private_encrypt() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+$data = "Testing openssl_private_encrypt()";
+$privkey = "file://" . dirname(__FILE__) . "/private_rsa_1024.key";
+$pubkey = "file://" . dirname(__FILE__) . "/public.key";
+$wrong = "wrong";
+
+class test {
+	function __toString() {
+		return "test";
+	}
+}
+$obj = new test;
+
+var_dump(openssl_private_encrypt($data, $encrypted, $privkey));
+var_dump(openssl_private_encrypt($data, $encrypted, $pubkey));
+var_dump(openssl_private_encrypt($data, $encrypted, $wrong));
+var_dump(openssl_private_encrypt($data, $encrypted, $obj));
+var_dump(openssl_private_encrypt($obj, $encrypted, $privkey));
+openssl_public_decrypt($encrypted, $output, $pubkey);
+var_dump($output);
+?>
+--EXPECTF--
+bool(true)
+
+Warning: openssl_private_encrypt(): key param is not a valid private key in %s on line %d
+bool(false)
+
+Warning: openssl_private_encrypt(): key param is not a valid private key in %s on line %d
+bool(false)
+
+Warning: openssl_private_encrypt(): key param is not a valid private key in %s on line %d
+bool(false)
+bool(true)
+string(4) "test"
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_public_decrypt_basic.phpt php-5.3.29/ext/openssl/tests/openssl_public_decrypt_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_public_decrypt_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_public_decrypt_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,48 @@
+--TEST--
+openssl_public_decrypt() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+$data = "Testing openssl_public_decrypt()";
+$privkey = "file://" . dirname(__FILE__) . "/private_rsa_1024.key";
+$pubkey = "file://" . dirname(__FILE__) . "/public.key";
+$wrong = "wrong";
+
+openssl_private_encrypt($data, $encrypted, $privkey);
+var_dump(openssl_public_decrypt($encrypted, $output, $pubkey));
+var_dump($output);
+var_dump(openssl_public_decrypt($encrypted, $output2, $wrong));
+var_dump($output2);
+var_dump(openssl_public_decrypt($wrong, $output3, $pubkey));
+var_dump($output3);
+var_dump(openssl_public_decrypt($encrypted, $output4, array()));
+var_dump($output4);
+var_dump(openssl_public_decrypt($encrypted, $output5, array($pubkey)));
+var_dump($output5);
+var_dump(openssl_public_decrypt($encrypted, $output6, array($pubkey, "")));
+var_dump($output6);
+?>
+--EXPECTF--
+bool(true)
+string(32) "Testing openssl_public_decrypt()"
+
+Warning: openssl_public_decrypt(): key parameter is not a valid public key in %s on line %d
+bool(false)
+NULL
+bool(false)
+NULL
+
+Warning: openssl_public_decrypt(): key array must be of the form array(0 => key, 1 => phrase) in %s on line %d
+
+Warning: openssl_public_decrypt(): key parameter is not a valid public key in %s on line %d
+bool(false)
+NULL
+
+Warning: openssl_public_decrypt(): key array must be of the form array(0 => key, 1 => phrase) in %s on line %d
+
+Warning: openssl_public_decrypt(): key parameter is not a valid public key in %s on line %d
+bool(false)
+NULL
+bool(true)
+string(32) "Testing openssl_public_decrypt()"
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_public_encrypt_basic.phpt php-5.3.29/ext/openssl/tests/openssl_public_encrypt_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_public_encrypt_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_public_encrypt_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,40 @@
+--TEST--
+openssl_public_encrypt() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+$data = "Testing openssl_public_encrypt()";
+$privkey = "file://" . dirname(__FILE__) . "/private_rsa_1024.key";
+$pubkey = "file://" . dirname(__FILE__) . "/public.key";
+$wrong = "wrong";
+
+class test {
+	function __toString() {
+		return "test";
+	}
+}
+$obj = new test;
+
+var_dump(openssl_public_encrypt($data, $encrypted, $pubkey));
+var_dump(openssl_public_encrypt($data, $encrypted, $privkey));
+var_dump(openssl_public_encrypt($data, $encrypted, $wrong));
+var_dump(openssl_public_encrypt($data, $encrypted, $obj));
+var_dump(openssl_public_encrypt($obj, $encrypted, $pubkey));
+openssl_private_decrypt($encrypted, $output, $privkey);
+var_dump($output);
+?>
+--EXPECTF--
+bool(true)
+
+Warning: openssl_public_encrypt(): key parameter is not a valid public key in %s on line %d
+bool(false)
+
+Warning: openssl_public_encrypt(): key parameter is not a valid public key in %s on line %d
+bool(false)
+
+Warning: openssl_public_encrypt(): key parameter is not a valid public key in %s on line %d
+bool(false)
+bool(true)
+string(4) "test"
+
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_random_pseudo_bytes.phpt php-5.3.29/ext/openssl/tests/openssl_random_pseudo_bytes.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_random_pseudo_bytes.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_random_pseudo_bytes.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,22 +0,0 @@
---TEST--
-openssl_random_pseudo_bytes() tests
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; ?>
---FILE--
-<?php
-for ($i = 0; $i < 10; $i++) {
-	var_dump(bin2hex(openssl_random_pseudo_bytes($i, $strong)));
-}
-
-?>
---EXPECTF--
-string(0) ""
-string(2) "%s"
-string(4) "%s"
-string(6) "%s"
-string(8) "%s"
-string(10) "%s"
-string(12) "%s"
-string(14) "%s"
-string(16) "%s"
-string(18) "%s"
\ No newline at end of file
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_random_pseudo_bytes_basic.phpt php-5.3.29/ext/openssl/tests/openssl_random_pseudo_bytes_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_random_pseudo_bytes_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_random_pseudo_bytes_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,22 @@
+--TEST--
+openssl_random_pseudo_bytes() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+for ($i = 0; $i < 10; $i++) {
+	var_dump(bin2hex(openssl_random_pseudo_bytes($i, $strong)));
+}
+
+?>
+--EXPECTF--
+string(0) ""
+string(2) "%s"
+string(4) "%s"
+string(6) "%s"
+string(8) "%s"
+string(10) "%s"
+string(12) "%s"
+string(14) "%s"
+string(16) "%s"
+string(18) "%s"
\ No newline at end of file
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_seal_basic.phpt php-5.3.29/ext/openssl/tests/openssl_seal_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_seal_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_seal_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,58 @@
+--TEST--
+openssl_seal() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+// simple tests
+$a = 1;
+$b = array(1);
+$c = array(1);
+$d = array(1);
+
+var_dump(openssl_seal($a, $b, $c, $d));
+var_dump(openssl_seal($a, $a, $a, array()));
+var_dump(openssl_seal($c, $c, $c, 1));
+var_dump(openssl_seal($b, $b, $b, ""));
+
+// tests with cert
+$data = "openssl_open() test";
+$pub_key = "file://" . dirname(__FILE__) . "/public.key";
+$wrong = "wrong";
+
+var_dump(openssl_seal($data, $sealed, $ekeys, array($pub_key)));                  // no output
+var_dump(openssl_seal($data, $sealed, $ekeys, array($pub_key, $pub_key)));        // no output
+var_dump(openssl_seal($data, $sealed, $ekeys, array($pub_key, $wrong)));
+var_dump(openssl_seal($data, $sealed, $ekeys, $pub_key));
+var_dump(openssl_seal($data, $sealed, $ekeys, array()));
+var_dump(openssl_seal($data, $sealed, $ekeys, array($wrong)));
+
+echo "Done\n";
+?>
+--EXPECTF--	
+Warning: openssl_seal(): not a public key (1th member of pubkeys) in %s on line %d
+bool(false)
+
+Warning: openssl_seal(): Fourth argument to openssl_seal() must be a non-empty array in %s on line %d
+bool(false)
+
+Warning: openssl_seal() expects parameter 1 to be string, array given in %s on line %d
+NULL
+
+Warning: openssl_seal() expects parameter 1 to be string, array given in %s on line %d
+NULL
+int(19)
+int(19)
+
+Warning: openssl_seal(): not a public key (2th member of pubkeys) in %s on line %d
+bool(false)
+
+Warning: openssl_seal() expects parameter 4 to be array, string given in %s on line %d
+NULL
+
+Warning: openssl_seal(): Fourth argument to openssl_seal() must be a non-empty array in %s on line %d
+bool(false)
+
+Warning: openssl_seal(): not a public key (1th member of pubkeys) in %s on line %d
+bool(false)
+Done
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_sign_basic.phpt php-5.3.29/ext/openssl/tests/openssl_sign_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_sign_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_sign_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,22 @@
+--TEST--
+openssl_sign() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+$data = "Testing openssl_sign()";
+$privkey = "file://" . dirname(__FILE__) . "/private_rsa_1024.key";
+$wrong = "wrong";
+
+var_dump(openssl_sign($data, $sign, $privkey));                 // no output
+var_dump(openssl_sign($data, $sign, $wrong));
+var_dump(openssl_sign(array(), $sign, $privkey));
+?>
+--EXPECTF--	
+bool(true)
+
+Warning: openssl_sign(): supplied key param cannot be coerced into a private key in %s on line %d
+bool(false)
+
+Warning: openssl_sign() expects parameter 1 to be string, array given in %s on line %d
+NULL
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_spki_export_basic.phpt php-5.3.29/ext/openssl/tests/openssl_spki_export_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_spki_export_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_spki_export_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,60 @@
+--TEST--
+openssl_spki_export() tests for exporting public key
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip");
+if (!@openssl_pkey_new()) die("skip cannot create private key");
+?>
+--FILE--
+<?php
+
+/* array of private key sizes to test */
+$key_sizes = array(1024, 2048, 4096);
+$pkeys = array();
+foreach ($key_sizes as $key_size) {
+	$key_file = "file://" . dirname(__FILE__) . "/private_rsa_" . $key_size . ".key";
+	$pkeys[] = openssl_pkey_get_private($key_file);
+}
+
+
+/* array of available hashings to test */
+$algo = array(
+	OPENSSL_ALGO_MD4,
+	OPENSSL_ALGO_MD5,
+	OPENSSL_ALGO_SHA1,
+	OPENSSL_ALGO_SHA224,
+	OPENSSL_ALGO_SHA256,
+	OPENSSL_ALGO_SHA384,
+	OPENSSL_ALGO_SHA512,
+	OPENSSL_ALGO_RMD160
+);
+
+/* loop over key sizes for test */
+foreach ($pkeys as $pkey) {
+
+	/* loop to create and verify results */
+	foreach ($algo as $value) {
+		$spkac = openssl_spki_new($pkey, _uuid(), $value);
+		echo openssl_spki_export(preg_replace('/SPKAC=/', '', $spkac));
+	}
+}
+
+/* generate a random challenge */
+function _uuid() {
+	return sprintf('%04x%04x-%04x-%04x-%04x-%04x%04x%04x', mt_rand(0, 0xffff),
+		mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0x0fff) | 0x4000,
+		mt_rand(0, 0x3fff) | 0x8000, mt_rand(0, 0xffff),
+		mt_rand(0, 0xffff), mt_rand(0, 0xffff));
+}
+
+
+?>
+--EXPECTREGEX--
+\-\-\-\-\-BEGIN PUBLIC KEY\-\-\-\-\-.*\-\-\-\-\-END PUBLIC KEY\-\-\-\-\-
+\-\-\-\-\-BEGIN PUBLIC KEY\-\-\-\-\-.*\-\-\-\-\-END PUBLIC KEY\-\-\-\-\-
+\-\-\-\-\-BEGIN PUBLIC KEY\-\-\-\-\-.*\-\-\-\-\-END PUBLIC KEY\-\-\-\-\-
+\-\-\-\-\-BEGIN PUBLIC KEY\-\-\-\-\-.*\-\-\-\-\-END PUBLIC KEY\-\-\-\-\-
+\-\-\-\-\-BEGIN PUBLIC KEY\-\-\-\-\-.*\-\-\-\-\-END PUBLIC KEY\-\-\-\-\-
+\-\-\-\-\-BEGIN PUBLIC KEY\-\-\-\-\-.*\-\-\-\-\-END PUBLIC KEY\-\-\-\-\-
+\-\-\-\-\-BEGIN PUBLIC KEY\-\-\-\-\-.*\-\-\-\-\-END PUBLIC KEY\-\-\-\-\-
+\-\-\-\-\-BEGIN PUBLIC KEY\-\-\-\-\-.*\-\-\-\-\-END PUBLIC KEY\-\-\-\-\-
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_spki_export_challenge_basic.phpt php-5.3.29/ext/openssl/tests/openssl_spki_export_challenge_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_spki_export_challenge_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_spki_export_challenge_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,103 @@
+--TEST--
+openssl_spki_export_challenge() tests for exporting challenge
+--INI--
+error_reporting=0
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip");
+if (!@openssl_pkey_new()) die("skip cannot create private key");
+?>
+--FILE--
+<?php
+
+/* array of private key sizes to test */
+$key_sizes = array(1024, 2048, 4096);
+$pkeys = array();
+foreach ($key_sizes as $key_size) {
+	$key_file = "file://" . dirname(__FILE__) . "/private_rsa_" . $key_size . ".key";
+	$pkeys[] = openssl_pkey_get_private($key_file);
+}
+
+
+/* array of available hashings to test */
+$algo = array(
+	OPENSSL_ALGO_MD4,
+	OPENSSL_ALGO_MD5,
+	OPENSSL_ALGO_SHA1,
+	OPENSSL_ALGO_SHA224,
+	OPENSSL_ALGO_SHA256,
+	OPENSSL_ALGO_SHA384,
+	OPENSSL_ALGO_SHA512,
+	OPENSSL_ALGO_RMD160
+);
+
+/* loop over key sizes for test */
+foreach ($pkeys as $pkey) {
+
+	/* loop to create and verify results */
+	foreach ($algo as $value) {
+		$spkac = openssl_spki_new($pkey, _uuid(), $value);
+		var_dump(openssl_spki_export_challenge(preg_replace('/SPKAC=/', '', $spkac)));
+		var_dump(openssl_spki_export_challenge($spkac  . 'Make it fail'));
+	}
+}
+
+/* generate a random challenge */
+function _uuid() {
+	return sprintf('%04x%04x-%04x-%04x-%04x-%04x%04x%04x', mt_rand(0, 0xffff),
+		mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0x0fff) | 0x4000,
+		mt_rand(0, 0x3fff) | 0x8000, mt_rand(0, 0xffff),
+		mt_rand(0, 0xffff), mt_rand(0, 0xffff));
+}
+
+
+?>
+--EXPECTREGEX--
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
+string\(36\) \"[0-9a-f]{8}\-([0-9a-f]{4}\-){3}[0-9a-f]{12}\"
+bool\(false\)
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_spki_new_basic.phpt php-5.3.29/ext/openssl/tests/openssl_spki_new_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_spki_new_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_spki_new_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,73 @@
+--TEST--
+openssl_spki_new() test for creating SPKI string
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip");
+?>
+--FILE--
+<?php
+
+/* array of private key sizes to test */
+$key_sizes = array(1024, 2048, 4096);
+$pkeys = array();
+foreach ($key_sizes as $key_size) {
+	$key_file = "file://" . dirname(__FILE__) . "/private_rsa_" . $key_size . ".key";
+	$pkeys[] = openssl_pkey_get_private($key_file);
+}
+
+
+/* array of available hashings to test */
+$algo = array(
+	OPENSSL_ALGO_MD4,
+	OPENSSL_ALGO_MD5,
+	OPENSSL_ALGO_SHA1,
+	OPENSSL_ALGO_SHA224,
+	OPENSSL_ALGO_SHA256,
+	OPENSSL_ALGO_SHA384,
+	OPENSSL_ALGO_SHA512,
+	OPENSSL_ALGO_RMD160
+);
+
+/* loop over key sizes for test */
+foreach ($pkeys as $pkey) {
+
+	/* loop to create and verify results */
+	foreach ($algo as $value) {
+		var_dump(openssl_spki_new($pkey, _uuid(), $value));
+	}
+}
+
+/* generate a random challenge */
+function _uuid() {
+	return sprintf('%04x%04x-%04x-%04x-%04x-%04x%04x%04x', mt_rand(0, 0xffff),
+		mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0x0fff) | 0x4000,
+		mt_rand(0, 0x3fff) | 0x8000, mt_rand(0, 0xffff),
+		mt_rand(0, 0xffff), mt_rand(0, 0xffff));
+}
+
+?>
+--EXPECTF--
+string(478) "%s"
+string(478) "%s"
+string(478) "%s"
+string(478) "%s"
+string(478) "%s"
+string(478) "%s"
+string(478) "%s"
+string(474) "%s"
+string(830) "%s"
+string(830) "%s"
+string(830) "%s"
+string(830) "%s"
+string(830) "%s"
+string(830) "%s"
+string(830) "%s"
+string(826) "%s"
+string(1510) "%s"
+string(1510) "%s"
+string(1510) "%s"
+string(1510) "%s"
+string(1510) "%s"
+string(1510) "%s"
+string(1510) "%s"
+string(1506) "%s"
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_spki_verify_basic.phpt php-5.3.29/ext/openssl/tests/openssl_spki_verify_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_spki_verify_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_spki_verify_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,88 @@
+--TEST--
+openssl_spki_verify() tests for valid signature
+--INI--
+error_reporting=0
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip");
+?>
+--FILE--
+<?php
+
+/* array of private key sizes to test */
+$key_sizes = array(1024, 2048, 4096);
+$pkeys = array();
+foreach ($key_sizes as $key_size) {
+	$key_file = "file://" . dirname(__FILE__) . "/private_rsa_" . $key_size . ".key";
+	$pkeys[] = openssl_pkey_get_private($key_file);
+}
+
+
+/* array of available hashings to test */
+$algo = array(
+	OPENSSL_ALGO_SHA1,
+	OPENSSL_ALGO_SHA224,
+	OPENSSL_ALGO_SHA256,
+	OPENSSL_ALGO_SHA384,
+	OPENSSL_ALGO_SHA512,
+	OPENSSL_ALGO_RMD160
+);
+
+/* loop over key sizes for test */
+foreach ($pkeys as $pkey) {
+
+	/* loop to create and verify results */
+	foreach ($algo as $value) {
+		$spkac = openssl_spki_new($pkey, _uuid(), $value);
+		var_dump(openssl_spki_verify(preg_replace('/SPKAC=/', '', $spkac)));
+		var_dump(openssl_spki_verify($spkac . 'Make it fail'));
+	}
+}
+
+/* generate a random challenge */
+function _uuid() {
+	return sprintf('%04x%04x-%04x-%04x-%04x-%04x%04x%04x', mt_rand(0, 0xffff),
+		mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0x0fff) | 0x4000,
+		mt_rand(0, 0x3fff) | 0x8000, mt_rand(0, 0xffff),
+		mt_rand(0, 0xffff), mt_rand(0, 0xffff));
+}
+
+
+?>
+--EXPECT--
+bool(true)
+bool(false)
+bool(true)
+bool(false)
+bool(true)
+bool(false)
+bool(true)
+bool(false)
+bool(true)
+bool(false)
+bool(true)
+bool(false)
+bool(true)
+bool(false)
+bool(true)
+bool(false)
+bool(true)
+bool(false)
+bool(true)
+bool(false)
+bool(true)
+bool(false)
+bool(true)
+bool(false)
+bool(true)
+bool(false)
+bool(true)
+bool(false)
+bool(true)
+bool(false)
+bool(true)
+bool(false)
+bool(true)
+bool(false)
+bool(true)
+bool(false)
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_verify_basic.phpt php-5.3.29/ext/openssl/tests/openssl_verify_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_verify_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_verify_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,28 @@
+--TEST--
+openssl_verify() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+$data = "Testing openssl_verify()";
+$privkey = "file://" . dirname(__FILE__) . "/private_rsa_1024.key";
+$pubkey = "file://" . dirname(__FILE__) . "/public.key";
+$wrong = "wrong";
+
+openssl_sign($data, $sign, $privkey);
+var_dump(openssl_verify($data, $sign, $pubkey));
+var_dump(openssl_verify($data, $sign, $privkey));
+var_dump(openssl_verify($data, $sign, $wrong));
+var_dump(openssl_verify($data, $wrong, $pubkey));
+var_dump(openssl_verify($wrong, $sign, $pubkey));
+?>
+--EXPECTF--
+int(1)
+
+Warning: openssl_verify(): supplied key param cannot be coerced into a public key in %s on line %d
+bool(false)
+
+Warning: openssl_verify(): supplied key param cannot be coerced into a public key in %s on line %d
+bool(false)
+int(0)
+int(0)
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_x509_check_private_key_basic.phpt php-5.3.29/ext/openssl/tests/openssl_x509_check_private_key_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_x509_check_private_key_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_x509_check_private_key_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,29 @@
+--TEST--
+openssl_x509_check_private_key() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+$fp = fopen(dirname(__FILE__) . "/cert.crt","r");
+$a = fread($fp, 8192);
+fclose($fp);
+
+$fp = fopen(dirname(__FILE__) . "/private_rsa_1024.key","r");
+$b = fread($fp, 8192);
+fclose($fp);
+
+$cert = "file://" . dirname(__FILE__) . "/cert.crt";
+$key = "file://" . dirname(__FILE__) . "/private_rsa_1024.key";
+
+var_dump(openssl_x509_check_private_key($cert, $key));
+var_dump(openssl_x509_check_private_key("", $key));
+var_dump(openssl_x509_check_private_key($cert, ""));
+var_dump(openssl_x509_check_private_key("", ""));
+var_dump(openssl_x509_check_private_key($a, $b));
+?>
+--EXPECT--
+bool(true)
+bool(false)
+bool(false)
+bool(false)
+bool(true)
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_x509_export_basic.phpt php-5.3.29/ext/openssl/tests/openssl_x509_export_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_x509_export_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_x509_export_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,41 @@
+--TEST--
+openssl_x509_export() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+$cert_file = dirname(__FILE__) . "/cert.crt";
+
+$a = file_get_contents($cert_file);
+$b = "file://" . $cert_file;
+$c = "invalid cert";
+$d = openssl_x509_read($a);
+$e = array();
+
+var_dump(openssl_x509_export($a, $output));  // read cert as a binary string
+var_dump(openssl_x509_export($b, $output2)); // read cert from a filename string
+var_dump(openssl_x509_export($c, $output3)); // read an invalid cert, fails
+var_dump(openssl_x509_export($d, $output4)); // read cert from a resource
+var_dump(openssl_x509_export($e, $output5)); // read an array, fails
+
+var_dump(strcmp($output, $a));
+var_dump(strcmp($output, $output2));
+var_dump(strcmp($output, $output3));
+var_dump(strcmp($output, $output4)); // different
+var_dump(strcmp($output, $output5)); // different
+?>
+--EXPECTF--
+bool(true)
+bool(true)
+
+Warning: openssl_x509_export(): cannot get cert from parameter 1 in %s on line %d
+bool(false)
+bool(true)
+
+Warning: openssl_x509_export(): cannot get cert from parameter 1 in %s on line %d
+bool(false)
+int(0)
+int(0)
+int(%d)
+int(0)
+int(%d)
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_x509_export_to_file_basic.phpt php-5.3.29/ext/openssl/tests/openssl_x509_export_to_file_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_x509_export_to_file_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_x509_export_to_file_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,42 @@
+--TEST--
+openssl_x509_export_to_file() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+$outfilename = dirname(__FILE__) . "/openssl_x509_export_to_file__outfilename.tmp";
+$cert_file = dirname(__FILE__) . "/cert.crt";
+
+$a = file_get_contents($cert_file);
+$b = "file://" . $cert_file;
+$c = "invalid cert";
+$d = openssl_x509_read($a);
+$e = array();
+
+var_dump(openssl_x509_export_to_file($a, $outfilename)); // read cert as a binary string
+var_dump(openssl_x509_export_to_file($b, $outfilename)); // read cert from a filename string
+var_dump(openssl_x509_export_to_file($c, $outfilename)); // read an invalid cert, fails
+var_dump(openssl_x509_export_to_file($d, $outfilename)); // read cert from a resource
+var_dump(openssl_x509_export_to_file($e, $outfilename)); // read an array, fails
+echo "---\n";
+var_dump($exists = file_exists($outfilename));
+?>
+--CLEAN--
+<?php
+$outfilename = dirname(__FILE__) . "/openssl_x509_export_to_file__outfilename.tmp";
+if (file_exists($outfilename)) {
+	unlink($outfilename);
+}
+?>
+--EXPECTF--
+bool(true)
+bool(true)
+
+Warning: openssl_x509_export_to_file(): cannot get cert from parameter 1 in %s on line %d
+bool(false)
+bool(true)
+
+Warning: openssl_x509_export_to_file(): cannot get cert from parameter 1 in %s on line %d
+bool(false)
+---
+bool(true)
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_x509_fingerprint_basic.phpt php-5.3.29/ext/openssl/tests/openssl_x509_fingerprint_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_x509_fingerprint_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_x509_fingerprint_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,47 @@
+--TEST--
+openssl_x509_fingerprint() tests
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip");
+?>
+--FILE--
+<?php
+
+$cert = "file://" . dirname(__FILE__) . "/cert.crt";
+
+echo "** Testing with no parameters **\n";
+var_dump(openssl_x509_fingerprint());
+
+echo "** Testing default functionality **\n";
+var_dump(openssl_x509_fingerprint($cert));
+
+echo "** Testing hash method md5 **\n";
+var_dump(openssl_x509_fingerprint($cert, 'md5'));
+
+echo "**Testing raw output md5 **\n";
+var_dump(bin2hex(openssl_x509_fingerprint($cert, 'md5', true)));
+
+echo "** Testing bad certification **\n";
+var_dump(openssl_x509_fingerprint('123'));
+echo "** Testing bad hash method **\n";
+var_dump(openssl_x509_fingerprint($cert, 'xx45'));
+--EXPECTF--
+** Testing with no parameters **
+
+Warning: openssl_x509_fingerprint() expects at least 1 parameter, 0 given in %s on line %d
+NULL
+** Testing default functionality **
+string(40) "6e6fd1ea10a5a23071d61c728ee9b40df6dbc33c"
+** Testing hash method md5 **
+string(32) "ac77008e172897e06c0b065294487a67"
+**Testing raw output md5 **
+string(32) "ac77008e172897e06c0b065294487a67"
+** Testing bad certification **
+
+Warning: openssl_x509_fingerprint(): cannot get cert from parameter 1 in %s on line %d
+bool(false)
+** Testing bad hash method **
+
+Warning: openssl_x509_fingerprint(): Unknown signature algorithm in %s on line %d
+bool(false)
+
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_x509_free_basic.phpt php-5.3.29/ext/openssl/tests/openssl_x509_free_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_x509_free_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_x509_free_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,16 @@
+--TEST--
+openssl_x509_free() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+var_dump($res = openssl_x509_read("file://" . dirname(__FILE__) . "/cert.crt"));
+openssl_x509_free($res);
+var_dump($res);
+openssl_x509_free(false);
+?>
+--EXPECTF--
+resource(%d) of type (OpenSSL X.509)
+resource(%d) of type (Unknown)
+
+Warning: openssl_x509_free() expects parameter 1 to be resource, boolean given in %s on line %d
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_x509_parse_basic.phpt php-5.3.29/ext/openssl/tests/openssl_x509_parse_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_x509_parse_basic.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_x509_parse_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -1,5 +1,5 @@
 --TEST--
-openssl_x509_parse() basic test
+openssl_x509_parse() tests
 --SKIPIF--
 <?php if (!extension_loaded("openssl")) print "skip"; 
 if (OPENSSL_VERSION_NUMBER < 0x10000000) die("skip Output requires OpenSSL 1.0");
@@ -12,7 +12,7 @@
 var_dump(openssl_x509_parse($cert, false));
 ?>
 --EXPECTF--
-array(12) {
+array(15) {
   ["name"]=>
   string(96) "/C=BR/ST=Rio Grande do Sul/L=Porto Alegre/CN=Henrique do N. Angelo/emailAddress=hnangelo@php.net"
   ["subject"]=>
@@ -55,6 +55,12 @@
   int(1214821723)
   ["validTo_time_t"]=>
   int(1217413723)
+  ["signatureTypeSN"]=>
+  string(8) "RSA-SHA1"
+  ["signatureTypeLN"]=>
+  string(21) "sha1WithRSAEncryption"
+  ["signatureTypeNID"]=>
+  int(65)
   ["purposes"]=>
   array(9) {
     [1]=>
@@ -152,7 +158,7 @@
     string(7) "CA:TRUE"
   }
 }
-array(12) {
+array(15) {
   ["name"]=>
   string(96) "/C=BR/ST=Rio Grande do Sul/L=Porto Alegre/CN=Henrique do N. Angelo/emailAddress=hnangelo@php.net"
   ["subject"]=>
@@ -195,6 +201,12 @@
   int(1214821723)
   ["validTo_time_t"]=>
   int(1217413723)
+  ["signatureTypeSN"]=>
+  string(8) "RSA-SHA1"
+  ["signatureTypeLN"]=>
+  string(21) "sha1WithRSAEncryption"
+  ["signatureTypeNID"]=>
+  int(65)
   ["purposes"]=>
   array(9) {
     [1]=>
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_x509_parse_basic_v9.phpt php-5.3.29/ext/openssl/tests/openssl_x509_parse_basic_v9.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_x509_parse_basic_v9.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_x509_parse_basic_v9.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,276 +0,0 @@
---TEST--
-openssl_x509_parse() basic test for OpenSSL 0.9
---SKIPIF--
-<?php if (!extension_loaded("openssl")) print "skip"; 
-if (OPENSSL_VERSION_NUMBER > 0x10000000) die("skip Output requires OpenSSL 0.9");
-?>
---FILE--
-<?php
-$cert = "file://" . dirname(__FILE__) . "/cert.crt";
-
-var_dump(openssl_x509_parse($cert));
-var_dump(openssl_x509_parse($cert, false));
-?>
---EXPECTF--
-array(12) {
-  ["name"]=>
-  string(96) "/C=BR/ST=Rio Grande do Sul/L=Porto Alegre/CN=Henrique do N. Angelo/emailAddress=hnangelo@php.net"
-  ["subject"]=>
-  array(5) {
-    ["C"]=>
-    string(2) "BR"
-    ["ST"]=>
-    string(17) "Rio Grande do Sul"
-    ["L"]=>
-    string(12) "Porto Alegre"
-    ["CN"]=>
-    string(21) "Henrique do N. Angelo"
-    ["emailAddress"]=>
-    string(16) "hnangelo@php.net"
-  }
-  ["hash"]=>
-  string(8) "%s"
-  ["issuer"]=>
-  array(5) {
-    ["C"]=>
-    string(2) "BR"
-    ["ST"]=>
-    string(17) "Rio Grande do Sul"
-    ["L"]=>
-    string(12) "Porto Alegre"
-    ["CN"]=>
-    string(21) "Henrique do N. Angelo"
-    ["emailAddress"]=>
-    string(16) "hnangelo@php.net"
-  }
-  ["version"]=>
-  int(2)
-  ["serialNumber"]=>
-  string(20) "12593567369101004962"
-  ["validFrom"]=>
-  string(13) "080630102843Z"
-  ["validTo"]=>
-  string(13) "080730102843Z"
-  ["validFrom_time_t"]=>
-  int(1214821723)
-  ["validTo_time_t"]=>
-  int(1217413723)
-  ["purposes"]=>
-  array(8) {
-    [1]=>
-    array(3) {
-      [0]=>
-      bool(true)
-      [1]=>
-      bool(true)
-      [2]=>
-      string(9) "sslclient"
-    }
-    [2]=>
-    array(3) {
-      [0]=>
-      bool(true)
-      [1]=>
-      bool(true)
-      [2]=>
-      string(9) "sslserver"
-    }
-    [3]=>
-    array(3) {
-      [0]=>
-      bool(true)
-      [1]=>
-      bool(true)
-      [2]=>
-      string(11) "nssslserver"
-    }
-    [4]=>
-    array(3) {
-      [0]=>
-      bool(true)
-      [1]=>
-      bool(true)
-      [2]=>
-      string(9) "smimesign"
-    }
-    [5]=>
-    array(3) {
-      [0]=>
-      bool(true)
-      [1]=>
-      bool(true)
-      [2]=>
-      string(12) "smimeencrypt"
-    }
-    [6]=>
-    array(3) {
-      [0]=>
-      bool(true)
-      [1]=>
-      bool(true)
-      [2]=>
-      string(7) "crlsign"
-    }
-    [7]=>
-    array(3) {
-      [0]=>
-      bool(true)
-      [1]=>
-      bool(true)
-      [2]=>
-      string(3) "any"
-    }
-    [8]=>
-    array(3) {
-      [0]=>
-      bool(true)
-      [1]=>
-      bool(true)
-      [2]=>
-      string(10) "ocsphelper"
-    }
-  }
-  ["extensions"]=>
-  array(3) {
-    ["subjectKeyIdentifier"]=>
-    string(59) "DB:7E:40:72:BD:5C:35:85:EC:29:29:81:12:E8:62:68:6A:B7:3F:7D"
-    ["authorityKeyIdentifier"]=>
-    string(202) "keyid:DB:7E:40:72:BD:5C:35:85:EC:29:29:81:12:E8:62:68:6A:B7:3F:7D
-DirName:/C=BR/ST=Rio Grande do Sul/L=Porto Alegre/CN=Henrique do N. Angelo/emailAddress=hnangelo@php.net
-serial:AE:C5:56:CC:72:37:50:A2
-"
-    ["basicConstraints"]=>
-    string(7) "CA:TRUE"
-  }
-}
-array(12) {
-  ["name"]=>
-  string(96) "/C=BR/ST=Rio Grande do Sul/L=Porto Alegre/CN=Henrique do N. Angelo/emailAddress=hnangelo@php.net"
-  ["subject"]=>
-  array(5) {
-    ["countryName"]=>
-    string(2) "BR"
-    ["stateOrProvinceName"]=>
-    string(17) "Rio Grande do Sul"
-    ["localityName"]=>
-    string(12) "Porto Alegre"
-    ["commonName"]=>
-    string(21) "Henrique do N. Angelo"
-    ["emailAddress"]=>
-    string(16) "hnangelo@php.net"
-  }
-  ["hash"]=>
-  string(8) "%s"
-  ["issuer"]=>
-  array(5) {
-    ["countryName"]=>
-    string(2) "BR"
-    ["stateOrProvinceName"]=>
-    string(17) "Rio Grande do Sul"
-    ["localityName"]=>
-    string(12) "Porto Alegre"
-    ["commonName"]=>
-    string(21) "Henrique do N. Angelo"
-    ["emailAddress"]=>
-    string(16) "hnangelo@php.net"
-  }
-  ["version"]=>
-  int(2)
-  ["serialNumber"]=>
-  string(20) "12593567369101004962"
-  ["validFrom"]=>
-  string(13) "080630102843Z"
-  ["validTo"]=>
-  string(13) "080730102843Z"
-  ["validFrom_time_t"]=>
-  int(1214821723)
-  ["validTo_time_t"]=>
-  int(1217413723)
-  ["purposes"]=>
-  array(8) {
-    [1]=>
-    array(3) {
-      [0]=>
-      bool(true)
-      [1]=>
-      bool(true)
-      [2]=>
-      string(10) "SSL client"
-    }
-    [2]=>
-    array(3) {
-      [0]=>
-      bool(true)
-      [1]=>
-      bool(true)
-      [2]=>
-      string(10) "SSL server"
-    }
-    [3]=>
-    array(3) {
-      [0]=>
-      bool(true)
-      [1]=>
-      bool(true)
-      [2]=>
-      string(19) "Netscape SSL server"
-    }
-    [4]=>
-    array(3) {
-      [0]=>
-      bool(true)
-      [1]=>
-      bool(true)
-      [2]=>
-      string(14) "S/MIME signing"
-    }
-    [5]=>
-    array(3) {
-      [0]=>
-      bool(true)
-      [1]=>
-      bool(true)
-      [2]=>
-      string(17) "S/MIME encryption"
-    }
-    [6]=>
-    array(3) {
-      [0]=>
-      bool(true)
-      [1]=>
-      bool(true)
-      [2]=>
-      string(11) "CRL signing"
-    }
-    [7]=>
-    array(3) {
-      [0]=>
-      bool(true)
-      [1]=>
-      bool(true)
-      [2]=>
-      string(11) "Any Purpose"
-    }
-    [8]=>
-    array(3) {
-      [0]=>
-      bool(true)
-      [1]=>
-      bool(true)
-      [2]=>
-      string(11) "OCSP helper"
-    }
-  }
-  ["extensions"]=>
-  array(3) {
-    ["subjectKeyIdentifier"]=>
-    string(59) "DB:7E:40:72:BD:5C:35:85:EC:29:29:81:12:E8:62:68:6A:B7:3F:7D"
-    ["authorityKeyIdentifier"]=>
-    string(202) "keyid:DB:7E:40:72:BD:5C:35:85:EC:29:29:81:12:E8:62:68:6A:B7:3F:7D
-DirName:/C=BR/ST=Rio Grande do Sul/L=Porto Alegre/CN=Henrique do N. Angelo/emailAddress=hnangelo@php.net
-serial:AE:C5:56:CC:72:37:50:A2
-"
-    ["basicConstraints"]=>
-    string(7) "CA:TRUE"
-  }
-}
diff -uNr php-5.3.29-ori/ext/openssl/tests/openssl_x509_read_basic.phpt php-5.3.29/ext/openssl/tests/openssl_x509_read_basic.phpt
--- php-5.3.29-ori/ext/openssl/tests/openssl_x509_read_basic.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/openssl_x509_read_basic.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,37 @@
+--TEST--
+openssl_x509_read() tests
+--SKIPIF--
+<?php if (!extension_loaded("openssl")) print "skip"; ?>
+--FILE--
+<?php
+$fp = fopen(dirname(__FILE__) . "/cert.crt","r");
+$a = fread($fp,8192);
+fclose($fp); 
+
+$b = "file://" . dirname(__FILE__) . "/cert.crt";
+$c = "invalid cert";
+$d = openssl_x509_read($a);
+$e = array();
+$f = array($b);
+
+var_dump(openssl_x509_read($a)); // read cert as a string
+var_dump(openssl_x509_read($b)); // read cert as a filename string
+var_dump(openssl_x509_read($c)); // read an invalid cert, fails
+var_dump(openssl_x509_read($d)); // read cert from a resource
+var_dump(openssl_x509_read($e)); // read an array
+var_dump(openssl_x509_read($f)); // read an array with the filename
+?>
+--EXPECTF--
+resource(%d) of type (OpenSSL X.509)
+resource(%d) of type (OpenSSL X.509)
+
+Warning: openssl_x509_read(): supplied parameter cannot be coerced into an X509 certificate! in %s on line %d
+bool(false)
+resource(%d) of type (OpenSSL X.509)
+
+Warning: openssl_x509_read(): supplied parameter cannot be coerced into an X509 certificate! in %s on line %d
+bool(false)
+
+Warning: openssl_x509_read(): supplied parameter cannot be coerced into an X509 certificate! in %s on line %d
+bool(false)
+
Binary files php-5.3.29-ori/ext/openssl/tests/p12_with_extra_certs.p12 and php-5.3.29/ext/openssl/tests/p12_with_extra_certs.p12 differ
diff -uNr php-5.3.29-ori/ext/openssl/tests/peer_verification.phpt php-5.3.29/ext/openssl/tests/peer_verification.phpt
--- php-5.3.29-ori/ext/openssl/tests/peer_verification.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/peer_verification.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,61 @@
+--TEST--
+Peer verification enabled for client streams
+--SKIPIF--
+<?php 
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug54992.pem'
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    for ($i = 0; $i < 5; $i++) {
+        @stream_socket_accept($server, 1);
+    }
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $clientFlags = STREAM_CLIENT_CONNECT;
+    $caFile = __DIR__ . '/bug54992-ca.pem';
+
+    phpt_wait();
+
+    // Expected to fail -- untrusted server cert and no CA File present
+    var_dump(@stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags));
+
+    // Expected to fail -- untrusted server cert and no CA File present
+    $clientCtx = stream_context_create(['ssl' => [
+        'verify_peer' => true,
+    ]]);
+    var_dump(@stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx));
+
+    // Should succeed with peer verification disabled in context
+    $clientCtx = stream_context_create(['ssl' => [
+        'verify_peer' => false,
+        'verify_peer_name' => false,
+    ]]);
+    var_dump(stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx));
+
+    // Should succeed with CA file specified in context
+    $clientCtx = stream_context_create(['ssl' => [
+        'cafile'   => $caFile,
+        'peer_name' => 'bug54992.local',
+    ]]);
+    var_dump(stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx));
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+bool(false)
+bool(false)
+resource(%d) of type (stream)
+resource(%d) of type (stream)
diff -uNr php-5.3.29-ori/ext/openssl/tests/private.key php-5.3.29/ext/openssl/tests/private.key
--- php-5.3.29-ori/ext/openssl/tests/private.key	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/private.key	1970-01-01 08:00:00.000000000 +0800
@@ -1,15 +0,0 @@
------BEGIN RSA PRIVATE KEY-----
-MIICXAIBAAKBgQDLXp6PkCtbpV+P1gwFQWH6Ez0U83uEmS8IGnpeI8Fk8rY/vHOZ
-zZZaxRCw+loyc342qCDIQheMOCNm5Fkevz06q757/oooiLR3yryYGKiKG1IZIipl
-mtsC95oKrzUSKk60wuI1mbgpMUP5LKi/Tvxes5PmkUtXfimz2qgkeUcPpQIDAQAB
-AoGBAMcP/dp+fsI9FFYBaVC3mASlUjOwxKWdH3kqGb8N9p4uKRAoEWtp3hNJM7ZX
-x3P8sn0jgrsiXlRFGvn65/T9shp8hj+CdJKg2jKCs7S58v60TLfSvOQSIYsw9Qm9
-Bsx4hKfz+d52ptuJRbv8tDxsYP3D/KjQfpX1OysiP/WBfeg9AkEA+AGT0goqjWOM
-YgFtZGrefIegF31XSCQTaLIml6/2JwF+oBKjJUQFar2Rwn6qUwrsGtSPMM0Iz8ry
-9uvUbs8PPwJBANHsuTVWzLf8TJNGc+xIlhvzKFkF0nJIWx4ozhlMNDQMMF/3FRSo
-zvHIgUnpG9Vwa2GtjTDnD8jHtzTauAZmjBsCQCGDVQ5VAVsJ0LaNqtKe/mGlkiSa
-c2j0Nws2x7BHvuOWeB35ZsJqZrD93OyDYVDHcRBPGOpnSoGJ0zs6swImSNECQHSH
-0BgH4wSPDYMDrP4RHSLOzCr+zF+cQthvFll8r83kpkXfRth9DMOy5fI9cLH/Adzr
-FmF7Iov2MYEpmNYUvtkCQHfW0ntkVY9xS2/VTs57F5tUkfNG2hG74pJM6vSfTNWn
-R/oI5m2sDtRWQ88LCYJMEmIZhN00Ys4xOSoTs+SUakY=
------END RSA PRIVATE KEY-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/private_ec.key php-5.3.29/ext/openssl/tests/private_ec.key
--- php-5.3.29-ori/ext/openssl/tests/private_ec.key	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/private_ec.key	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,5 @@
+-----BEGIN EC PRIVATE KEY-----
+MHcCAQEEILPkqoeyM7XgwYkuSj3077lrsrfWJK5LqMolv+m2oOjZoAoGCCqGSM49
+AwEHoUQDQgAEPq4hbIWHvB51rdWr8ejrjWo4qVNWVugYFtPg/xLQw0mHkIPZ4DvK
+sqOTOnMoezkbSmVVMuwz9flvnqHGmQvmug==
+-----END EC PRIVATE KEY-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/private_rsa_1024.key php-5.3.29/ext/openssl/tests/private_rsa_1024.key
--- php-5.3.29-ori/ext/openssl/tests/private_rsa_1024.key	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/private_rsa_1024.key	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,15 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIICXAIBAAKBgQDLXp6PkCtbpV+P1gwFQWH6Ez0U83uEmS8IGnpeI8Fk8rY/vHOZ
+zZZaxRCw+loyc342qCDIQheMOCNm5Fkevz06q757/oooiLR3yryYGKiKG1IZIipl
+mtsC95oKrzUSKk60wuI1mbgpMUP5LKi/Tvxes5PmkUtXfimz2qgkeUcPpQIDAQAB
+AoGBAMcP/dp+fsI9FFYBaVC3mASlUjOwxKWdH3kqGb8N9p4uKRAoEWtp3hNJM7ZX
+x3P8sn0jgrsiXlRFGvn65/T9shp8hj+CdJKg2jKCs7S58v60TLfSvOQSIYsw9Qm9
+Bsx4hKfz+d52ptuJRbv8tDxsYP3D/KjQfpX1OysiP/WBfeg9AkEA+AGT0goqjWOM
+YgFtZGrefIegF31XSCQTaLIml6/2JwF+oBKjJUQFar2Rwn6qUwrsGtSPMM0Iz8ry
+9uvUbs8PPwJBANHsuTVWzLf8TJNGc+xIlhvzKFkF0nJIWx4ozhlMNDQMMF/3FRSo
+zvHIgUnpG9Vwa2GtjTDnD8jHtzTauAZmjBsCQCGDVQ5VAVsJ0LaNqtKe/mGlkiSa
+c2j0Nws2x7BHvuOWeB35ZsJqZrD93OyDYVDHcRBPGOpnSoGJ0zs6swImSNECQHSH
+0BgH4wSPDYMDrP4RHSLOzCr+zF+cQthvFll8r83kpkXfRth9DMOy5fI9cLH/Adzr
+FmF7Iov2MYEpmNYUvtkCQHfW0ntkVY9xS2/VTs57F5tUkfNG2hG74pJM6vSfTNWn
+R/oI5m2sDtRWQ88LCYJMEmIZhN00Ys4xOSoTs+SUakY=
+-----END RSA PRIVATE KEY-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/private_rsa_2048.key php-5.3.29/ext/openssl/tests/private_rsa_2048.key
--- php-5.3.29-ori/ext/openssl/tests/private_rsa_2048.key	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/private_rsa_2048.key	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,27 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIEpAIBAAKCAQEArbUmVW1Y+rJzZRC3DYB0kdIgvk7MAday78ybGPPDhVlbAb4C
+jWbaPs4nyUCTEt9KVG0H7pXHxDbWSsC2974zdvqlP0L2op1/M2SteTcGCBOdwGH2
+jORVAZL8/WbTOf9IpKAM77oN14scsyOlQBJqhh+xrLg8ksB2dOos54yDqo0Tq7R5
+tldV+alKZXWlJnqRCfFuxvqtfWI5nGTAedVZhvjQfLQQgujfXHoFWoGbXn2buzfw
+KGJEeqWPbQOZF/FeOJPlgOBhhDb3BAFNVCtM3k71Rblj54pNd3yvq152xsgFd0o3
+s15fuSwZgerUjeEuw/wTK9k7vyp+MrIQHQmPdQIDAQABAoIBABPDKDlP12+uHbLB
+1BGVK63rWg5MqKkM5A6kGIEeOoBRSilIlMHBkdLTYXNkBVeAT9SLEvvxzmhkVLzs
+b+R/nxtKKMKpu6WEhZQzQAkqWWVR1gCtJH+i+ojTUDUEHcPbZ0hTbSVY5XpAOWOo
+CoTfk37u3CfqTfnkK5XhjnpJYjFk60fLeTKKG90xb4WmPGCOxBZGeI9yk+gEgMVx
+4qYBQEgcaJEBXebvM0q8BCDh/rlYxwQ/q0RJ6W1D84SOeyYv/9LesFZSbnUN16tA
+/YezkhYVkVIrQFzh1al7NKvWEUZ3Yx3AEuggKtijlZyO9zOAOigSiFQjtqOl7S6e
+jbVfLYECgYEA51E5TNvN6IW6p58wOXTmINnsW3sDYS1CyPh3TkSvWU2OqMXJxQSA
+bASpXtqicAY32wkBOiazyY/+L7x1ReG/8z3tTm53AsYwkLKrgUfjdrOFhXWk8QI3
+0WS/1hS7qZ4Ycxi5B2X+rPPLnc2+mUvaEX6/B2Fjbqp4nIt+ZAE8SvcCgYEAwD47
+anMk8z68wdgzxY4J10sgCKfgHCe7J8ikpzloznX1HnbZTWf74FLlA/8ctfFJCVAy
+4dG1s0D+JSpxxMSkk4hvi10Ha6t5U+BreD9VPAQRspGSKhn8JfwvLfKPH65uazBP
+yvBtVIdagBf/msLfF33vkrQSjAEJM1njl6XMEfMCgYB1BddqNa0G3Figol0gRC6E
+Iht78FC2YdJun5yj4QWgtSbd5Sn9XRinDPiufwc8izjIu9Z+F8ROzWT3u2zMzLdy
+FDswuZvFsIQzP+CaB8dgbtO2v9yQ/OFGMqUGZfjGh6+w0qoQvx3HW5MAI20wWnpY
+7Xkw/6jw/JcGA2AOsb1R4wKBgQCFfnF54Q1GkEk4/m4tAA4bX4KWICUCyCAxZyXX
+LYl23PhiuDr7gnqockevt8ZzHWMPQY6juyFGoZoZqtinv7lc7YAvsWEGxmMQ+KUI
+Mkp4y4aSjn2GGNc8dVs5t9blNBZe/oRaMwxohzkz+/Y1vJ54TK5BHCRI7is6anAd
+jTchOwKBgQDP9yOdQTfUwJRUMERWmzXWU2oDXeEMdpbGPLGJ4/e/hu1CW7bdQRoc
+jBSEpn3hOodmdwdmoXtbJReMCE8qS6yVHNn4orpJf+uOBr5fVnHwttFfN8HID9js
+Lml8jAAQItMFw1CEPR75NVdFb7ksNKlxE9376tG63JhrTttRGwO3CA==
+-----END RSA PRIVATE KEY-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/private_rsa_2048_pass_php.key php-5.3.29/ext/openssl/tests/private_rsa_2048_pass_php.key
--- php-5.3.29-ori/ext/openssl/tests/private_rsa_2048_pass_php.key	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/private_rsa_2048_pass_php.key	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,30 @@
+-----BEGIN RSA PRIVATE KEY-----
+Proc-Type: 4,ENCRYPTED
+DEK-Info: AES-128-CBC,D839E12F98A22F4FA90401E31A896A03
+
+gVJ/972mKRrZ2+55rofbFXuLY03Umb7+m7OotGHkYa3dJpNuOLta+LDpSMRdgKcT
+7s+vZ7CERJsWolbdCSphwWs74FV4fJheuzrnEthmVazmIcDwWu1FiiD5XEmRQMFH
+AvwUKTN5PIyN67eCusbrV5/FJsVdxvRwLUM70UE+nhBW8rg6AhszDtSHhGG1KN9T
+TwT2m8xYOgzzPPseQN/VcKNJ+LZcUVN/8+12duy1Ej/HoFaE7wp5GH0mueeShf0R
+xFZ6mizZ3x+Ef4+PbTDnSXRheF9uvSdwmff4rUS4Szpk0aYpSrluJJjzI9Unjvqi
+129ZQsNUfLebJlaauTYYNsHHh64hRXelqKz5mNmcF/OV+pbCjYljgDsyndmrZ5jB
+xjfjp/1VGQAU26VnF0X9zv5q9Gz3/bkl3VFnS7gNyMCanyTuaXNNFNcbkY59Iq1l
+rWjGGMeujWttFhYsChtCb6Clsq4aCiXJ9lqFNTU+eqVD9F5C4v5ATM6VHqjxwvj3
+RB4P98pQsGLkHUKgAZrYqxhLjN6O7FvZuuSRSZl+Q6suYcie+hR4p2TRopRTttc2
+d/gdJCBEbboJH3XOFlHz08mhxgVobi5ACzAoSpCVT4NIahG+Gt7h8Rk6+A9/uiwj
+Jy6+MRiylhAOXAfOps7+FvBFi4nKByFXtWOHRL6DGpYWy20vCk0gsuICRpwL33A4
+e6YAJiuygQSWTExyGfeRk5VQRkZrWL1s3nTnA0MLqx1VdIbDeNPtIZ+dQHCN5vYt
+pP7zFSuF6fse8mSobzA9x4hKXUKWQ/V985arHYzYpJXfIRMyZDqKjRW5xKGYR0eH
+adhpbOCWx73+vVa8tABbvNIPjp/7KPaGPSp7uV9Afvvt5qjM/nho/VstyWscivM0
+c+oylG4cNBaJCVyb6nsiBYK2XE/Llfjsj/l2+SRfIZOwmvhL+CG7z7okPEiNp7EB
+DcefH7/N/Fg4R4PzWskHfb6ZU+nnPKV9JJdBitw/EQFAN8qO7b6O1HRsXUJziBsH
+cgQBDT0wOue49lDFratmWBx1K10paRuAl1DmO5WtstC/cthGYvKVGDWclLbIVRpv
+/DyXZMsXdt9IaP31vHs+W0Yj/1Pcj3iKFX/oh0e7Kb2MQziquQcMzJM2n3BVa2PQ
+dZ3FGKSoDtdT3RhEWGAY5zh7nwPUDqR2frCTGdRAASJbHmC/dn3Fs/m7kQHCUTw8
+EpDCCFZhp23DODk96Q0vtgtPU16qONMzVlzSH8REjS23GrbZ4wn/SW8Qm5QZiScH
+WbJ3Aj5iemcFnL5aDN81BNX9GtUvJFK2jvmmPcv1x5+x51RweMQYErgahI9YVFtM
+0cEN2cm27hZjktHxduJefc+WVu6vCyzSA0q/CbT58eIWBPyvyIM8AB65h4TFxX9N
+4g0/0Kh8gqe3EVg1x62LEAC6AaRZEm/GBeux41DlNDYbCik6VdLRHVozmf7PYm+X
+6miR4EfGE+kM7/V+shMQZni/Q64gzIn+/vpMiNV5JQsr1E2tqUp2/P6N0puUwWv2
+ORVWWk6gy8wnJ//LsDNEhSKfCrffuv2u2oVQWMcBwyqbR6ru/V3i9+9ngWd2D4E0
+-----END RSA PRIVATE KEY-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/private_rsa_4096.key php-5.3.29/ext/openssl/tests/private_rsa_4096.key
--- php-5.3.29-ori/ext/openssl/tests/private_rsa_4096.key	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/private_rsa_4096.key	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,51 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIJKAIBAAKCAgEAtlmPieG4yL/HQ1j98U+VqlAzO55+aSHKXOV9q5+uTevtzXVV
+s+rOPUAlPkUi7kcp3Yrum+Y0rNCnTNpSmpFB2f/Y1rHb6Rxn8SXzWSq8BM0BhbCm
+yE+PY3DyIBizX6isb13vJyvU7f8Ayv4xAQ/ve8ytFAnBXUdIhtQNygraxvr8aoZw
+81cBRQ8NhBkk/qDZWVkOiePC9voZ05sENhL4aUZw3Xew2JtZyw+lRxheczkYYc71
+OQuOKoU06j3ZpLhdhtdjpOVC6csIk9qyq8ki8t9m66a2BdiPaz1cWGZGqQg4SDrJ
+0XKG6/wdSWgdUKMp0wB2Kwph2SWwLm7BQEpdtMtXnNGB2dT+lffjtqRvyT4HKO03
+R9b7ZxUVA34Tzi+kX04g3e4qI4eD0bsHYwioUlkKf/q7E1+WjwaQ2LLbOUnWeKqb
+wGBsZYMWeWGTc/FO4oyDJBG9gnsqmSHasAsxsW6ojsGnz9IXywpwInlz+R4pB+ua
+dXHiUZEuT8lCdBUWKAtCIb/F9cNEJg/Vq0iVoWFaOYd5D4PHXV5aXjEx18ez7GvN
+98XPYNXQmVBmsIlOHQpytz0RdrlstksxBqWhaBUT3ZJU6czchNgYeFsEuYKkUNK+
+fwQLhA9aeT6RBdet2efhyaf4y3vQFb5kxx4JcljXjIYVR3yB9iZnD0WGQxkCAwEA
+AQKCAgBHrhkQmFxs/YY04SyhySkKFBCvpPQIG7JSphuqdVCtbMrD8xXHbcu4pBh/
+y+mZRPweDFkTi4C1VigNu9ywydza9wmkC7JohjQNxV9Nc9EJChVJGlHVeADjlCh5
+mXwZZFK0THaQLVi8XXtQUG+u/TaksaZvtA4Avt6xsXXiMDYj9dF3hnWsEk17ehlU
+DhZOyafmyW0/ovqm31V7qvoSz446w+fmBwDLhPXdLr9HnTqzjIQbHqGi1PoDmO1e
+DwYZDCgns0+GKGEPSjKK/HMzuBM26b6pb5Up4yEthKdiUIICPCrzqbhfzudeqHJS
+wsyTQDBWs13AOYqRM5F4Dy2EOjdvCgt2zElO0c3r/pOTplk3/v7VrsqiNN33xGfc
+4zGw3d0xLjQRhA9vhG5Kdtqqs1GqZDf3mNmPxv8gHJDdB6Twkk9iNlUnV5neew6R
+0KKklZvMApE+KMVrRKmez0+ab/ktpoAe9Xox9ChBfLaZQgJlDwNDktjRu8RT1da8
+L6SMy5+mP+aSKxWxgNGoM0BQiv3DBriyTuyhcu+2SIr4c0LrWqedZRI1eRREZjhG
+VLBpftvQH7AMTZuIHXYjtF8XcZneaa2/fI7SNH6RpPc7WJmLCF3ufjv6HVp3qA8B
+ahRCgsr4sBZDJqwMkbNJQfuF/zNOAGmO5VRBodb/P9UQeEVeAQKCAQEA6TkahKZq
+374hUnElMH3mmYPVxOKfqx4EMrS+MP8cjXXmiw7bWjQlufcmbMhxHaXkGiU9+/TB
+VdFPtLZvo7Aa+m2sHCySJ1pG2T4kkmV9cNVExKPllraH3/QvDK3o34aA2DxgOXAT
+33wxlxvmmaMmrjjP6BZduvS/W/vwL6+aA1erZbsBuA1CoeyiyE95zdcD43+TlZWi
+fwCqCZ27wrKHCPFcEN/ecpjKQTQQdogDNWdJJzaTH7y3iWNOsLdTNeLRYrvu94dS
+J9n7cCoLCEFzdylaXx/jGCNrnaNtqDj46JHW6XSQ6e3D0UpV2hx5V2+0q1gbEhWe
+wtBrhGsHj/jj+QKCAQEAyCiOlcE6a1tjIdMihAO1hqdUiFcIKzoiDQKNBEaY9ELz
+oWkuZj2fUnhjeAKhkQ4ZheH6+fk2Tt0+kU1Jl+Iym/ciE/m/N8RUyqq2FOnmwktz
+yGqD9fQeLix2b2txp+0dyi1niQ+S8ZKAJBbxKTb3CBefowrkz5JK7+jWqaUDNQ5h
+8KoGCcAB8kSkXGgqVOapXyGb31YdyM3X1mJGv95jO4A+OmFI2faPAOtZrg9EicSI
+7U84bfFMhfhrpxZuU7Bbyz6Kg9hleAv0q/3tBFSJvMTOiuM7OFtlUAByL+pWwZ9Y
+haQ4ojojsPaQ6pMmf0JNXwnp8Rhz2+QNDyFzRm/gIQKCAQEA3dmA/S/kuAL/ZZHV
+g4QvyFYdEdVVdwvtiGJgDPGPsoy1ig/O3sZ+IKEWPyKIX2B/U9ObW8Hd6wlZXZix
+J68Maq3Kq15GhQKeJGa1mUDLi3qDmN4jNjNZmtKHsvL3czFZ/Nep3NldPhjAf3J9
+8CW/VLkcJDSqYn4QTaqhNms/APDzTKkQIIkUmj0kN5FKV2CyBUVFGWSml1MFbHJL
+ug/i3cHiBvc9fhsTQeUJyAbnrnQapR+H4ge9OwZpQzaQA9FHxjjpPzLNFrWHNZH4
+vpisAm0m1xfZCQwggWqFlCDlvS2FlrtYYf3XaI3ijsDJOEA9R0RfM9u3Eq/5ppO9
+NNnX2QKCAQAJ63ilk14B1BWlp4EeadClS8W0vBt7iPYHDwlOHPGXqXnJlhzmlEdB
+HxZO7FJ1je1V5U069k7quaxQJzRugpdfg2/87XO8n85T/QHpJ254UqT6Wc0Qc3jL
+cQitnPWVDPtc+cMX193AezI+l6R8Fm1HyWPwAKo2X1m3aiK5ZaQzDPNtqf+CnDF8
+gEplCgSPEJ90R4YiG3J+cTUxOs2m1K62VDTBT/D8XGvZ79ASAE+1RDhFCpgRWtQg
+D5/GOCZfn23tNLxIrIDa4jzOCVelz0rEQDy8RWa59E2hGWSPW13RWsRYWzszTw5V
+xuKHvaM6y15qR2OAv2V+kF7VUSMVapYBAoIBAEyZDn9H+IMQBkRyZgxPLsE5cgd3
+DeR2Txn2RxQBpop9+lgniuq/NVHiUIRscynsJ01/bFifmFNkgD2cRORy7SU+wsNr
+zsWlLPO1e/axdfMsT0OIBOQ84jZ6FDGi5JnqnC8zVVPU7g2iNoDEtA7ltlXknUUX
+uigFoR1CXoNz8KdW+18MtYDjBLR1crfGa+zqPOpxfjoXBhehtCKG9ZxtrBSWq6mz
+lR9N5Tv9USiJW1r6+85aLsC5E9ARjAxMLhTKvD+NXbQDwZJgfM/vs1eZ6eIYMYE9
+lB7kMFfHKqsagNXdyhRFzfEfx+FkKTHaqC6V5rOp6q0t8AO41ZvZO/tKdi8=
+-----END RSA PRIVATE KEY-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/public_ec.key php-5.3.29/ext/openssl/tests/public_ec.key
--- php-5.3.29-ori/ext/openssl/tests/public_ec.key	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/public_ec.key	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,4 @@
+-----BEGIN PUBLIC KEY-----
+MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEPq4hbIWHvB51rdWr8ejrjWo4qVNW
+VugYFtPg/xLQw0mHkIPZ4DvKsqOTOnMoezkbSmVVMuwz9flvnqHGmQvmug==
+-----END PUBLIC KEY-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/san-ca.pem php-5.3.29/ext/openssl/tests/san-ca.pem
--- php-5.3.29-ori/ext/openssl/tests/san-ca.pem	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/san-ca.pem	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,15 @@
+-----BEGIN CERTIFICATE-----
+MIICYTCCAcqgAwIBAgIJAIaqxtY5dwjtMA0GCSqGSIb3DQEBBQUAMFMxCzAJBgNV
+BAYTAlVTMQswCQYDVQQIEwJNTjEUMBIGA1UEBxMLTWlubmVhcG9saXMxITAfBgNV
+BAsTGERvbWFpbiBDb250cm9sIFZhbGlkYXRlZDAeFw0xMzA5MjQwODA1NTFaFw0y
+MTEyMTEwODA1NTFaMFMxCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJNTjEUMBIGA1UE
+BxMLTWlubmVhcG9saXMxITAfBgNVBAsTGERvbWFpbiBDb250cm9sIFZhbGlkYXRl
+ZDCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAsFGqfbU/8D+KjroQl4XMyt9m
+dcSP7iZtqphOu9nVZxYAAqfaqj8FnC/pwYV3TU6ZHndLTQAllwYT3sQBQPPGmZQ9
+clSIMEL003t3pi4ZVXkttG6Vvr+Z9PBcHhlKLQ7WMHnn4qctllWXTSoyTQpkETF3
+Fc3mrG5G37BhoUno7NECAwEAAaM9MDswOQYDVR0RBDIwMIILZXhhbXBsZS5vcmeC
+D3d3dy5leGFtcGxlLm9yZ4IQdGVzdC5leGFtcGxlLm9yZzANBgkqhkiG9w0BAQUF
+AAOBgQBf/FZhzheIcQJ+dyTk8xQ/nJLvpmBhbd1LNtfwk/MsC9UHsz4QXs9sBw1k
+rH0FjoqgM6avj7zKHJFTj6q7Rd+OX5V4HynYPhX67sWbN3KWEHffL98nGGd/bo3X
+pSjNk5vnyKYiwdUUe11Ac9csh0HcSBbhOYjy0T/i9AlQcKbuCg==
+-----END CERTIFICATE-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/san-cert.pem php-5.3.29/ext/openssl/tests/san-cert.pem
--- php-5.3.29-ori/ext/openssl/tests/san-cert.pem	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/san-cert.pem	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,31 @@
+-----BEGIN CERTIFICATE-----
+MIICYTCCAcqgAwIBAgIJAIaqxtY5dwjtMA0GCSqGSIb3DQEBBQUAMFMxCzAJBgNV
+BAYTAlVTMQswCQYDVQQIEwJNTjEUMBIGA1UEBxMLTWlubmVhcG9saXMxITAfBgNV
+BAsTGERvbWFpbiBDb250cm9sIFZhbGlkYXRlZDAeFw0xMzA5MjQwODA1NTFaFw0y
+MTEyMTEwODA1NTFaMFMxCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJNTjEUMBIGA1UE
+BxMLTWlubmVhcG9saXMxITAfBgNVBAsTGERvbWFpbiBDb250cm9sIFZhbGlkYXRl
+ZDCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAsFGqfbU/8D+KjroQl4XMyt9m
+dcSP7iZtqphOu9nVZxYAAqfaqj8FnC/pwYV3TU6ZHndLTQAllwYT3sQBQPPGmZQ9
+clSIMEL003t3pi4ZVXkttG6Vvr+Z9PBcHhlKLQ7WMHnn4qctllWXTSoyTQpkETF3
+Fc3mrG5G37BhoUno7NECAwEAAaM9MDswOQYDVR0RBDIwMIILZXhhbXBsZS5vcmeC
+D3d3dy5leGFtcGxlLm9yZ4IQdGVzdC5leGFtcGxlLm9yZzANBgkqhkiG9w0BAQUF
+AAOBgQBf/FZhzheIcQJ+dyTk8xQ/nJLvpmBhbd1LNtfwk/MsC9UHsz4QXs9sBw1k
+rH0FjoqgM6avj7zKHJFTj6q7Rd+OX5V4HynYPhX67sWbN3KWEHffL98nGGd/bo3X
+pSjNk5vnyKYiwdUUe11Ac9csh0HcSBbhOYjy0T/i9AlQcKbuCg==
+-----END CERTIFICATE-----
+-----BEGIN PRIVATE KEY-----
+MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBALBRqn21P/A/io66
+EJeFzMrfZnXEj+4mbaqYTrvZ1WcWAAKn2qo/BZwv6cGFd01OmR53S00AJZcGE97E
+AUDzxpmUPXJUiDBC9NN7d6YuGVV5LbRulb6/mfTwXB4ZSi0O1jB55+KnLZZVl00q
+Mk0KZBExdxXN5qxuRt+wYaFJ6OzRAgMBAAECgYB11e5iWvqjPmQEZRdnnJU0VD8u
+n7ItT+Nk6qtb4gY8Abj6DWIW+01th5vqqJ8FvGyartFVYa69kuM+srG/zevAZWeu
+fGZtwiwZR4DRSyRcPp4rnNiksK3dkAZA6UewmRDPv8uyHJlXc5i+Ft1ILJ5Q5jgn
+UkC4z3EJP5Se9KZywQJBAOO4lRq42wLsYr2SDrQDSs4leie3FKc2bgvjF7Djosh1
+ZYbf55F5b9w1zgnccmni2HkqOnyFu4SKarmXyCsYxrkCQQDGNvnUh7/zZswrdWZ/
+PMp9zVDTh/5Oc2B4ByNLw1ERDwYhjchKgPRlQvn4cp3Pwf3UYPQ/8XGXzzEJey3A
+r0rZAkBf/tDEOgcBPXsGZQrTscuYCU5sbY5ESvqrAilbhSp7DJom+D5bIfEYyIm5
+uHd20Yzlzvpmwc1huyPwZt6X5FLpAkATDReoGMAXSesXxjnqwtIHk2NQYYLM0YQV
+JUJ8NrKk/Bevw+vbVVeoH+7ctU97t36JGiR/vNoZKD3jVmaIXZDJAkEA4wJbwzIo
+L32mu9VmZa7wjmfkraQEmXTPaA5D9lNC0AwRTgkj+x2Qe1vawNblNK9PPLBDdplQ
+L//53ADq/wv5rA==
+-----END PRIVATE KEY-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/san_peer_matching.phpt php-5.3.29/ext/openssl/tests/san_peer_matching.phpt
--- php-5.3.29-ori/ext/openssl/tests/san_peer_matching.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/san_peer_matching.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,50 @@
+--TEST--
+Peer verification matches SAN names
+--SKIPIF--
+<?php 
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/san-cert.pem',
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    @stream_socket_accept($server, 1);
+    @stream_socket_accept($server, 1);
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $clientFlags = STREAM_CLIENT_CONNECT;
+    $clientCtx = stream_context_create(['ssl' => [
+        'verify_peer' => false,
+        'cafile' => __DIR__ . '/san-ca.pem',
+    ]]);
+
+    phpt_wait();
+
+    stream_context_set_option($clientCtx, 'ssl', 'peer_name', 'example.org');
+    var_dump(stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx));
+
+    stream_context_set_option($clientCtx, 'ssl', 'peer_name', 'moar.example.org');
+    var_dump(stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx));
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+resource(%d) of type (stream)
+
+Warning: stream_socket_client(): Unable to locate peer certificate CN in %s on line %d
+
+Warning: stream_socket_client(): Failed to enable crypto in %s on line %d
+
+Warning: stream_socket_client(): unable to connect to ssl://127.0.0.1:64321 (Unknown error) in %s on line %d
+bool(false)
diff -uNr php-5.3.29-ori/ext/openssl/tests/session_meta_capture.phpt php-5.3.29/ext/openssl/tests/session_meta_capture.phpt
--- php-5.3.29-ori/ext/openssl/tests/session_meta_capture.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/session_meta_capture.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,59 @@
+--TEST--
+Capture SSL session meta array in stream context
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+if (OPENSSL_VERSION_NUMBER < 0x10001001) die("skip OpenSSLv1.0.1 required");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug54992.pem'
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    @stream_socket_accept($server, 1);
+    @stream_socket_accept($server, 1);
+    @stream_socket_accept($server, 1);
+    @stream_socket_accept($server, 1);
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $clientFlags = STREAM_CLIENT_CONNECT;
+    $clientCtx = stream_context_create(['ssl' => [
+        'verify_peer' => true,
+        'cafile' => __DIR__ . '/bug54992-ca.pem',
+        'peer_name' => 'bug54992.local',
+        'capture_session_meta' => true,
+    ]]);
+
+    phpt_wait();
+
+    stream_context_set_option($clientCtx, 'ssl', 'crypto_method', STREAM_CRYPTO_METHOD_TLSv1_0_CLIENT);
+    stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx);
+    $meta = stream_context_get_options($clientCtx)['ssl']['session_meta'];
+    var_dump($meta['protocol']);
+
+    stream_context_set_option($clientCtx, 'ssl', 'crypto_method', STREAM_CRYPTO_METHOD_TLSv1_1_CLIENT);
+    stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx);
+    $meta = stream_context_get_options($clientCtx)['ssl']['session_meta'];
+    var_dump($meta['protocol']);
+
+    stream_context_set_option($clientCtx, 'ssl', 'crypto_method', STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT);
+    stream_socket_client($serverUri, $errno, $errstr, 2, $clientFlags, $clientCtx);
+    $meta = stream_context_get_options($clientCtx)['ssl']['session_meta'];
+    var_dump($meta['protocol']);
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+string(5) "TLSv1"
+string(7) "TLSv1.1"
+string(7) "TLSv1.2"
diff -uNr php-5.3.29-ori/ext/openssl/tests/sni_001.phpt php-5.3.29/ext/openssl/tests/sni_001.phpt
--- php-5.3.29-ori/ext/openssl/tests/sni_001.phpt	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/tests/sni_001.phpt	1970-01-01 08:00:00.000000000 +0800
@@ -1,178 +0,0 @@
---TEST--
-SNI 001
---SKIPIF--
-<?php
-	if (!extension_loaded('openssl')) die("skip openssl extension not available");
-	if (!getenv('SNI_TESTS')) die("skip Set SNI_TESTS to enable this test (uses remote resources)");
-?>
---FILE--
-<?php
-/* Server Name Indication (SNI) tests
- * 
- * This test relies on https://sni.velox.ch/ and thus is disabled by default.
- *
- * sni.velox.ch uses 3 certificates :
- * - CN=alice.sni.velox.ch (sent in response to server_name = alice.sni.velox.ch or not set)
- * - CN=bob.sni.velox.ch (sent in response to server_name = bob.sni.velox.ch)
- * - CN=*.sni.velox.ch (sent in response to server_name = mallory.sni.velox.ch or *.sni.velox.ch or sni.velox.ch)
- *
- * The test sends requests to the server, sending different names, and checks which certificate
- * the server returned.
- */
-
-function context() {
-	return stream_context_create(array(
-		'ssl' => array(
-			'capture_peer_cert' => true,
-		),
-	));
-}
-
-function get_CN($context) {
-
-	$ary = stream_context_get_options($context);
-	assert($ary);
-
-	$cert = $ary['ssl']['peer_certificate'];
-	assert($cert);
-
-	$cert_ary = openssl_x509_parse($cert);
-	return $cert_ary['subject']['CN'];
-}
-
-function do_http_test($url, $context) {
-
-	$fh = fopen($url, 'r', false, $context);
-	assert($fh);
-
-	var_dump(get_CN($context));
-}
-
-function do_ssl_test($url, $context) {
-
-	$fh = stream_socket_client($url, $errno, $errstr, 
-			ini_get("default_socket_timeout"), STREAM_CLIENT_CONNECT, $context);
-	assert($fh);
-
-	var_dump(get_CN($context));
-}
-
-function do_enable_crypto_test($url, $context) {
-
-	$fh = stream_socket_client($url, $errno, $errstr,
-		ini_get("default_socket_timeout"), STREAM_CLIENT_CONNECT, $context);
-	assert($fh);
-
-	$r = stream_socket_enable_crypto($fh, true, STREAM_CRYPTO_METHOD_TLS_CLIENT);
-	assert($r);
-
-	var_dump(get_CN($context));
-}
-
-/* Test https:// streams */
-
-echo "-- auto host name (1) --\n";
-do_http_test('https://alice.sni.velox.ch/', context());
-
-echo "-- auto host name (2) --\n";
-do_http_test('https://bob.sni.velox.ch/', context());
-
-echo "-- auto host name (3) --\n";
-do_http_test('https://bob.sni.velox.ch./', context());
-
-echo "-- user supplied server name --\n";
-
-$context = context();
-stream_context_set_option($context, 'ssl', 'SNI_server_name', 'bob.sni.velox.ch');
-stream_context_set_option($context, 'http', 'header', b'Host: bob.sni.velox.ch');
-do_http_test('https://alice.sni.velox.ch/', $context);
-
-echo "-- sni disabled --\n";
-
-$context = context();
-stream_context_set_option($context, 'ssl', 'SNI_enabled', false);
-do_http_test('https://bob.sni.velox.ch/', $context);
-
-/* Test ssl:// socket streams */
-
-echo "-- raw SSL stream (1) --\n";
-do_ssl_test('ssl://bob.sni.velox.ch:443', context());
-
-echo "-- raw SSL stream (2) --\n";
-do_ssl_test('ssl://mallory.sni.velox.ch:443', context());
-
-echo "-- raw SSL stream with user supplied sni --\n";
-
-$context = context();
-stream_context_set_option($context, 'ssl', 'SNI_server_name', 'bob.sni.velox.ch');
-
-do_ssl_test('ssl://mallory.sni.velox.ch:443', $context);
-
-echo "-- raw SSL stream with sni disabled --\n";
-
-$context = context();
-stream_context_set_option($context, 'ssl', 'SNI_enabled', false);
-
-do_ssl_test('ssl://mallory.sni.velox.ch:443', $context);
-
-/* Test tcp:// socket streams with SSL enabled */
-
-echo "-- stream_socket_enable_crypto (1) --\n";
-
-do_enable_crypto_test('tcp://bob.sni.velox.ch:443', context());
-
-echo "-- stream_socket_enable_crypto (2) --\n";
-
-do_enable_crypto_test('tcp://mallory.sni.velox.ch:443', context());
-
-echo "-- stream_socket_enable_crypto with user supplied sni --\n";
-
-$context = context();
-stream_context_set_option($context, 'ssl', 'SNI_server_name', 'bob.sni.velox.ch');
-
-do_enable_crypto_test('tcp://mallory.sni.velox.ch:443', $context);
-
-echo "-- stream_socket_enable_crypto with sni disabled --\n";
-
-$context = context();
-stream_context_set_option($context, 'ssl', 'SNI_enabled', false);
-
-do_enable_crypto_test('tcp://mallory.sni.velox.ch:443', $context);
-
-echo "-- stream_socket_enable_crypto with long name --\n";
-
-$context = context();
-stream_context_set_option($context, 'ssl', 'SNI_server_name', str_repeat('a.', 500) . '.sni.velox.ch');
-
-do_enable_crypto_test('tcp://mallory.sni.velox.ch:443', $context);
-
-?>
---EXPECTF--
--- auto host name (1) --
-%unicode|string%(18) "alice.sni.velox.ch"
--- auto host name (2) --
-%unicode|string%(16) "bob.sni.velox.ch"
--- auto host name (3) --
-%unicode|string%(16) "bob.sni.velox.ch"
--- user supplied server name --
-%unicode|string%(16) "bob.sni.velox.ch"
--- sni disabled --
-%unicode|string%(18) "alice.sni.velox.ch"
--- raw SSL stream (1) --
-%unicode|string%(16) "bob.sni.velox.ch"
--- raw SSL stream (2) --
-%unicode|string%(14) "*.sni.velox.ch"
--- raw SSL stream with user supplied sni --
-%unicode|string%(16) "bob.sni.velox.ch"
--- raw SSL stream with sni disabled --
-%unicode|string%(18) "alice.sni.velox.ch"
--- stream_socket_enable_crypto (1) --
-%unicode|string%(16) "bob.sni.velox.ch"
--- stream_socket_enable_crypto (2) --
-%unicode|string%(14) "*.sni.velox.ch"
--- stream_socket_enable_crypto with user supplied sni --
-%unicode|string%(16) "bob.sni.velox.ch"
--- stream_socket_enable_crypto with sni disabled --
-%unicode|string%(18) "alice.sni.velox.ch"
--- stream_socket_enable_crypto with long name --
-%unicode|string%(18) "alice.sni.velox.ch"
diff -uNr php-5.3.29-ori/ext/openssl/tests/sni_server.phpt php-5.3.29/ext/openssl/tests/sni_server.phpt
--- php-5.3.29-ori/ext/openssl/tests/sni_server.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/sni_server.phpt	2019-01-26 11:29:19.967117841 +0800
@@ -0,0 +1,63 @@
+--TEST--
+sni_server
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $flags = STREAM_SERVER_BIND|STREAM_SERVER_LISTEN;
+    $ctx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/domain1.pem',
+        'SNI_server_certs' => [
+            "domain1.com" => __DIR__ . "/sni_server_domain1.pem",
+            "domain2.com" => __DIR__ . "/sni_server_domain2.pem",
+            "domain3.com" => __DIR__ . "/sni_server_domain3.pem"
+        ]
+    ]]);
+
+    $server = stream_socket_server('tls://127.0.0.1:64321', $errno, $errstr, $flags, $ctx);
+    phpt_notify();
+
+    for ($i=0; $i < 3; $i++) {
+        @stream_socket_accept($server, 3);
+    }
+CODE;
+
+$clientCode = <<<'CODE'
+    $flags = STREAM_CLIENT_CONNECT;
+    $ctxArr = [
+        'verify_peer'  => false,
+        'verify_peer_name' => false,
+        'allow_self_signed' => true,
+        'cafile' => __DIR__ . '/sni_server_ca.pem',
+        'capture_peer_cert' => true
+    ];
+
+    phpt_wait();
+
+    $ctxArr['peer_name'] = 'domain1.com';
+    $ctx = stream_context_create(['ssl' => $ctxArr]);
+    $client = stream_socket_client("tls://127.0.0.1:64321", $errno, $errstr, 1, $flags, $ctx);
+    $cert = stream_context_get_options($ctx)['ssl']['peer_certificate'];
+    var_dump(openssl_x509_parse($cert)['subject']['CN']);
+
+    $ctxArr['peer_name'] = 'domain2.com';
+    $ctx = stream_context_create(['ssl' => $ctxArr]);
+    $client = @stream_socket_client("tls://127.0.0.1:64321", $errno, $errstr, 1, $flags, $ctx);
+    $cert = stream_context_get_options($ctx)['ssl']['peer_certificate'];
+    var_dump(openssl_x509_parse($cert)['subject']['CN']);
+
+    $ctxArr['peer_name'] = 'domain3.com';
+    $ctx = stream_context_create(['ssl' => $ctxArr]);
+    $client = @stream_socket_client("tls://127.0.0.1:64321", $errno, $errstr, 1, $flags, $ctx);
+    $cert = stream_context_get_options($ctx)['ssl']['peer_certificate'];
+    var_dump(openssl_x509_parse($cert)['subject']['CN']);
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+string(%d) "domain1.com"
+string(%d) "domain2.com"
+string(%d) "domain3.com"
diff -uNr php-5.3.29-ori/ext/openssl/tests/sni_server_ca.pem php-5.3.29/ext/openssl/tests/sni_server_ca.pem
--- php-5.3.29-ori/ext/openssl/tests/sni_server_ca.pem	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/sni_server_ca.pem	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,63 @@
+-----BEGIN CERTIFICATE-----
+MIIFPjCCAyYCAQEwDQYJKoZIhvcNAQEFBQAwWTELMAkGA1UEBhMCVVMxCzAJBgNV
+BAgMAlNDMRUwEwYDVQQHDAxNeXJ0bGUgQmVhY2gxEjAQBgNVBAoMCXBocC50ZXN0
+czESMBAGA1UEAwwJcGhwLnRlc3RzMB4XDTE0MDMwNTE0MTg1M1oXDTI0MDMwMjE0
+MTg1M1owcTELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAlNDMRUwEwYDVQQHDAxNeXJ0
+bGUgQmVhY2gxHjAcBgNVBAoMFXBocC50ZXN0cyBzdWJvcmRpbmF0ZTEeMBwGA1UE
+AwwVcGhwLnRlc3RzLnN1Ym9yZGluYXRlMIICIjANBgkqhkiG9w0BAQEFAAOCAg8A
+MIICCgKCAgEA4rmcz5M0B2Td+0g8+pmGT0IBCxZTVL14xKA1yLeY+6eshdNiRAIR
+8m5sI21AirtAh7mJziA2Q4C/1bRvY9VI/0yxXRP20aicNmhEvFVAvQCxmAkg8hIm
+WwDiNLw+4HpAkQInpd8exjExhvanUgAz6tq8w6CL2BqquiwQPVIf5HHMHjomz1gz
+iZEs6CRE5YMdUd7ZSx+MHl6ww3WYwW/XHDPzAUIe8uhOT+yA8lVLFAac3+lyjA6g
+zMPYG5SrqE6/+yZYDVx2WhVMjJq8d+N6hnIkhZeJyZo2T0G7/pSGIwaVsceIJ/8/
+6km8p4Dn2Pq75F8RZW5iz0MnSqKqSH/ANP71UuinpcVfnyg0ajy7J+cNMDC3gNPC
+L0b13qRhRsjNYdyOR7Aj5uQgCegDVipMGLIa+5Vxnzinc059/81QttbsrF2Ll96y
+lQk46zhyMOOTnVuX/6k2iFnNUNouXiFlEYPdxRAOJtcOL650F7wTtWolNAyEsRyH
+sv3wDXAFXp8b+B/Be1i1yfomP6VnXQMls6RR00qBtc8qEVAMddYihAv5MWa6vXSc
++PA3dBJJBmBJeesqR2PC8kgs+CeGJfUS3VRcUmUKBWz+dMvHPSSiQebwg+Za3xz8
+l3WWPMVWwFUviyv8pw+AB30d5m/akB/r7a1f2FJjwg1P7atkZzz0/SUCAwEAATAN
+BgkqhkiG9w0BAQUFAAOCAgEATP38i4XRo2if8SZLqg/kdZQ/B7ER5PpOS0YkMgp+
+g1dLpUrjthIFJ96s9akxO4Bq1NUnt/Ms/8RgTHlM8xF3HuXBt6C6MjeIL9keg0rz
+D3dObstOGhqYrUpEhcCaG9mtWQ4G7n86e1/zKTIORAPBD1LPvp6nIzJGNU5DwPeR
+u+RK1/DCUBNk1YHrhxj6AevagVozTEeZ2F5AQK9B78MG1fXezN5q5ubLyJZG673q
+G1+rhigUrK2xoJzE+DDWlhrVt2nkdzK+rlP63Y9I/XUH76OT4kuLXqttnbWfuvCr
+mVt5st+nx24hGmd9yaiKPsUFPlbSfhwzstGreGlsdWIYKzCwnXX6niVMBdKwrRfa
+PBnmZbG3YYcMflWLcMUscCqvlPDn9fQS6uwKT6xcEDIou6a8KpQpEgo9k+KUpX2Z
+DpyFkDGEeYR2qENlblEoPpkBITWq68tY4jjkHETh1spgDisIzZFkFcupSIrcIaXb
+T05gv3POWqb8soejrxMBQHQwkHkZNHcaOBPTJMRG3UTkRbI/UN77oOjCk7/tWa0B
+GDEF2eMQ8bpTChQsr4pfIqaHjx4NVdLlZ4OfVoGlKISmMYjU+bVIYZibRNZg/GYP
+fUs9sB8ZSRTFvsOHtL5hoD/BYhPIQ5g2fkDsYdfQZIMPQidO+R9lOvMQUgPy/gGd
+JzA=
+-----END CERTIFICATE-----
+-----BEGIN CERTIFICATE-----
+MIIFhTCCA22gAwIBAgIJAMJT3RVinFnaMA0GCSqGSIb3DQEBBQUAMFkxCzAJBgNV
+BAYTAlVTMQswCQYDVQQIDAJTQzEVMBMGA1UEBwwMTXlydGxlIEJlYWNoMRIwEAYD
+VQQKDAlwaHAudGVzdHMxEjAQBgNVBAMMCXBocC50ZXN0czAeFw0xNDAzMDUxNDE1
+NDBaFw0yNDAzMDIxNDE1NDBaMFkxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJTQzEV
+MBMGA1UEBwwMTXlydGxlIEJlYWNoMRIwEAYDVQQKDAlwaHAudGVzdHMxEjAQBgNV
+BAMMCXBocC50ZXN0czCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAM1G
+jKhUktyuMjqqUSHW5pq+sR53S2E79fCqQq+Gom0NV/KdL5VAkwa3HBFzy+t0z6gE
+9wVP6h+AdVU0b9BEb9bEuaDVpW7kwclNLXtRVPw5BN3amLs0ukPoZqoBQVhjfg2p
+4qqYBpHBi6U7ltdEHApsBVxYsxGJz+g0NkF4oSlZt+M07jscNexXqpd1m08b9dp/
+nbIR6GLyQ6fSqIXJR7ImvBew2LE8WhFt9ldzzA0cEmr3NQcUXuS4fO8mRNIF+9dJ
+f/M9myn6NlCl/eO+YBVSLOp+J72wKLo2LT/C4zbSj2bhc24ui66olzVOCe/97V76
+xusTDKXwagcMxNJD6lZIjZsl5VS9/SYpECj63cGTu5OE6UP6ZyBKZsaX4ZpmklhH
+PTMfCTGOtK9MazStM7YtDLSTO3O0yGZXRd0uHcPXM+H2lHqpM90GfGNNdIzS8h7p
+hFmocpnHQLVN9SKbrgv9Rt+QbGpBwYH6NFtcwJRiNU9cabez2dcaXWs8+Okvxb7/
+Azvs0jv6d4Y05iIQ4uyJeBOfAuc0UyoG/y+XrGko/8omrTUnAUQtKD/1ymTs+yjb
+YNZ6dw5Q5w/FbgL6pMNNOcDgl37mGKFzpRqkUHbOhDZTEUlzYyvtn84t7rbC5g2u
+y+KFo3/S4qJheyRfl5FANFTUlxv4vMvMnuaHcJxvAgMBAAGjUDBOMB0GA1UdDgQW
+BBRQ95jPSVj20YO2Eq2+wnknOpCjqjAfBgNVHSMEGDAWgBRQ95jPSVj20YO2Eq2+
+wnknOpCjqjAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUAA4ICAQCaYxaA9H8O
+J55kLRzzgLV56yc+MhowAqOAOjD4J20aWbkRQIwUMIi6xnCwRRnwjuscPFOSF6P+
+Bn3kdVX+KhzFLNRhAk1qjEGjwSVLPKJSKJSdwOmrvCkSsIcbASxSXQkz714LkFAL
+hZ9cs4QD+/JVEPazgqjBwtlu3hwwuGAxwHNAKWeFaXpOJu9UerwfBmF090L0uBND
+QJAqDyCZRaQp4Re6qH3iQhxyERlAwCNIRSV2cWHJP0HmWye76Z2aehp96fKTo5Cd
+NXW3GKGSpmZeZgY8MZVyzUau1c83+nHJCYO0jhFyZjO4XMJ+cce0a2H8iIhox5fY
+ZBEuxYN6cPkdvDbFRQU+e+KO1jjyumNWentW57DDPihpgZ3f3Gf5xtUjnHTC5VKT
+chW9ujq18Hk4JWL5uyF+5am5Qm4YdjhhZ1TtGHNjoZGpHV0Tf4h5AcDG4Zr6TCmM
+3Rw952ytcMtZKZzBq2ZWC3lKpBPPzihAgwzgflVvi0BLP9Ek98oMxq22pymHEHY8
+ivfm+t4rRY6JMl7DxDcARvWoKujrJy2JUUm50vT5D2GG8xYwYr9XKgD8rP36qCjC
+B+1l+upz+37r9U12uWfjPsRjyphGbN8ZZAkjSSZQU2snogxaKOvWZb+2M/rajdek
+BSQ9sUZ6sNXnTkyYon6iH6WULvmSTgBGnQ==
+-----END CERTIFICATE-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/sni_server_domain1.pem php-5.3.29/ext/openssl/tests/sni_server_domain1.pem
--- php-5.3.29-ori/ext/openssl/tests/sni_server_domain1.pem	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/sni_server_domain1.pem	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,82 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIJKAIBAAKCAgEAnCaINvfTx7v+DUMD5zJLg+8lEJsxGt7OQjEmFkEUmwrXz1I5
+E29rckBS/lCNG6NvEG6uNtxgXoz6cLlOwL9cdHGSKPDOYHGa7JN+EGiMnScZLNc9
+ao1ouvLdBa5lv6zcoCu6YPw95AnZ6PHEHj8mFckWtmFjV16/diB1SR9wDpIwye7m
+nJlVRUAMzrABVNDaPUqqj8G+xr02Mo6pTX1wGHgQyTR/pNOHZGiDDBXeWNDuEBNv
+TYtBWXXXMrGC36HTSR+KMlDjFfmCTb+y0s8ILT7Pagx6LFoun99SbhXQtrwC/0sU
+R5tyqOrgVj1dbuKSWuSaiWYMJZXaFKkndkCTQLiPCDltHOd7ppYmRt848WqKTbjO
+Vhpjxjhu4rfHw3ynhQNC50N/jiViKBcpptQhX4cMNltXsJXI0hr6dWI2/6r7op9j
+2uxOHthznLejsHcGmW62F8wpUZxAT8yuvTcEMzx+HjdLyBu+N/t7BHKk4+nIAN8G
+266mT4BjSLHcdny4J8UrVoBvDeW7oQkdvhluIomabGJg3wknnjY9/QbsiCAcR05H
+Z2IEremU9Vm3uogAwBBWk2YTEuIuNbm8TAHqfTj1PkxXRE6YTL907fFZMcw/+3nO
+YERqS4FV5OvNqoNILWxl0dBYaBrtRwhMEYZFDK5jDc1OtolpF07s45JwbakCAwEA
+AQKCAgASxm9KbLICKhB597zYZ6u8yVxjisV0vaV/P/mcY2be3YblXrWOKK96pVFV
+UsoksJoCF8zKu+S6eakDNMTLWDb9qUoxsgKehgpit7lIr8l4e+MDCT5ROX+GOv1o
+WXfSfC5q89cNIkcuzCBvaeJy4JTruaoJc9xF/RZ4VZ7ElAsdNWa4YQlJewZNtU3U
+7ES8tgAHrpqjfmA59TY3DgA9WP/JcWZTSwSuBOEaqZZYNajudPCq7itL35qT7x9Y
+8Q8TZJnLCQfM1Pz4/28zegE+Z7ZL+mlmDuoBuzYv8uIuamEWF7UkjRp7Ia2/sb4X
+oHlDg+qlEyehrat4OXRnV49vIIST64cxQw3v9mGZr1mCxyrfGbRvPw99CSwjdCju
+LSuzYlr5w/ZVKsVGKB1mvowxzKJ89Njhdv+QlHpqrodSgCTFzm2A6dwoEQ9bQFd/
+OH7pG9YOu5jf66MFnV60AiImGBZCP7B3thJgmCBhjSau2cmDSUGFLwZswoue2y7u
+Goh5sCOq8MAcFkm5CyXkAQbDIptGs7XGipJBbpZEXBo1fnVPQnz/Ien9Mv8ZxeAW
+busJD5aPMZZ9GwLuRfoGEa7PEO4409zHc07hA22kxv6yb1nNyuTNcXG2myIP5MdO
+rHLFuDcQ+2adBmpmJGYXmak73eamYzCZOMEOLYSLAwYNFpOIgQKCAQEAytAdhSFa
+goKLWCR5NcXvMSjAblWqMn5qAG0KroIISrOIgWamiDE6Xsqrg6H/aRETyelO5Xyi
+TxHnhYzge0VUAXJK3megyKbXCWwIJyym14gKXppvgNmvKs7hM6tp00+UYYUGWj1u
+2Mw3ae6oCyQIx2GYGUVTRyIbtz/u0Nfc0cJJ/OB91Q7Ab/GEVv70hvN3QBLab4OK
+37BtXE26dorHLAAC2SWwDbaD6A7NxHW5M9JpQHdtYvhNwS6lBVxSlFjmA7jBXrxH
+vT/8TJG4b5f9d85JGvURwX3DW1bUO/vVMEdp5RE1gHLo5q+IKQSH7OeVfJQeavyA
+OXC2+UIcsOdMPQKCAQEAxRm5xTchHfhTFusfggVjRwp0fKxCGw7LL4xLO6G3nqTX
+5WX2XWc/VB7uSJVq1b4dwiUJxVnmYWL/FcC3OeAQZh2BnkEJoPF4re7neN/8BOHB
+sHpn8+O8a5XF5XumvodSgwoBj0dPTdRRvK8OreyMjhoMwC5OrOWeYgfCkg4UUeax
+Mjta7j3B/wzu/SQcLOkVW9Y/B6FsC5ZIbNPhFJQ/h9q4aFw421AWnJ98FRSGDT22
+cynII9nA8OhNh8YXEJz4FRYs4GelbUNBe98BEh7cVOEuqK/7L7wXpmmC64yhP1ro
+37WJ9LDZbYqLriGsMZV23/knvPOk0Mqd8dTgderh3QKCAQB3zXHyp14ow+Z+HaWA
+DzkZB+KMCoxsIWKKd98ccHFndyAGmFV9E99QCVZBfps6PD09Q1U4mGPkY0YpDKu6
+BZz28cWqFPrULEHQLgGu6mBv5suBUKbXLT+dAPHkrLfpfBPBe2viOHHXHOMK71BS
+rGmHJW5MVzg3R72phNmUgj7NpYBBIXcTORCRz9AF97sIUJ87uSdRQhnxwu0G3l9s
+ENRQeH02Ol4B67OFi+Ee0Q+ivgMwcpuqH9UGbYBLZ1rciJruzd9kD8Is17Q4oseZ
+G+Y9NBzZELT5YEnbFbJu8Hbhev3hs0WwZ7COPFgpKqUEW1Rhb7l8J0WzKJLdMKF0
+Gl1dAoIBAD3mVGdRZv8oi7+4285TrtgSun6lAqXIwZsPLllt8mLKVlte6D5xPHxI
+soDtG/5AlMvyId1u3GFdW8sTGPf+HGhVf+2Zc1KuQz4st1lIzrchx1iLOLZpoTUQ
+dnQZn0Za7Vjl/ZNny8ofkgP13mBU19eQ6sw4PtEh09npofuInG0UTDYAWhBUKObW
+wv+RJaAdG24aHPVihrIk4l37NMbnwAQEdsGfpOOLhW5uz+M27NqftPr59jb8HhIK
+gr7PQVMgWPEWY8WeB2AHLTufz5BHTN8DUUn86qAVLEBBBrK/Gazx+gy30LmeCMrU
+JgXr4U45KHoyn35B7lL8LxpRxqSBvakCggEBAJBaYCI/2uWAF+sGQLt0rg25jnLo
+iuY45pshPCoxjONwYh0vnjsr00nyyN56ipPRITETMnQh/thGYJmj0O+5dO+0fkfB
+iHP9MxOxqVpMYff9Q4As+mtmC1/9UPSN8hRxyUuNwL0rNt/tq7u3muo5XT0rRWwV
+SjnMMjfK98i4b3xBpFPn8wrenhK3EVsx0hCyWg3NgmhTNh2OaK31FPiQAwOM7XXS
+55sQLO2XTPa663GNavzECmzZxYiRrk6TCEYp8jDofBw0aT+Mq8fp7kwgwX7l2lfK
+XQzGJ+CxJCdMyWhLlXGkIhG8G2W4/3tqyIp2+JlXk6/3CD6ovOqy0rhnpA8=
+-----END RSA PRIVATE KEY-----
+-----BEGIN CERTIFICATE-----
+MIIFSDCCAzACAQEwDQYJKoZIhvcNAQEFBQAwcTELMAkGA1UEBhMCVVMxCzAJBgNV
+BAgMAlNDMRUwEwYDVQQHDAxNeXJ0bGUgQmVhY2gxHjAcBgNVBAoMFXBocC50ZXN0
+cyBzdWJvcmRpbmF0ZTEeMBwGA1UEAwwVcGhwLnRlc3RzLnN1Ym9yZGluYXRlMB4X
+DTE0MDMwNTE0MjgwOFoXDTI0MDMwMjE0MjgwOFowYzELMAkGA1UEBhMCVVMxFTAT
+BgNVBAgMDE15cnRsZSBCZWFjaDELMAkGA1UEBwwCU0MxGjAYBgNVBAoMEWRvbWFp
+bjEgdGVzdCBjZXJ0MRQwEgYDVQQDDAtkb21haW4xLmNvbTCCAiIwDQYJKoZIhvcN
+AQEBBQADggIPADCCAgoCggIBAJwmiDb308e7/g1DA+cyS4PvJRCbMRrezkIxJhZB
+FJsK189SORNva3JAUv5QjRujbxBurjbcYF6M+nC5TsC/XHRxkijwzmBxmuyTfhBo
+jJ0nGSzXPWqNaLry3QWuZb+s3KArumD8PeQJ2ejxxB4/JhXJFrZhY1dev3YgdUkf
+cA6SMMnu5pyZVUVADM6wAVTQ2j1Kqo/Bvsa9NjKOqU19cBh4EMk0f6TTh2RogwwV
+3ljQ7hATb02LQVl11zKxgt+h00kfijJQ4xX5gk2/stLPCC0+z2oMeixaLp/fUm4V
+0La8Av9LFEebcqjq4FY9XW7iklrkmolmDCWV2hSpJ3ZAk0C4jwg5bRzne6aWJkbf
+OPFqik24zlYaY8Y4buK3x8N8p4UDQudDf44lYigXKabUIV+HDDZbV7CVyNIa+nVi
+Nv+q+6KfY9rsTh7Yc5y3o7B3BpluthfMKVGcQE/Mrr03BDM8fh43S8gbvjf7ewRy
+pOPpyADfBtuupk+AY0ix3HZ8uCfFK1aAbw3lu6EJHb4ZbiKJmmxiYN8JJ542Pf0G
+7IggHEdOR2diBK3plPVZt7qIAMAQVpNmExLiLjW5vEwB6n049T5MV0ROmEy/dO3x
+WTHMP/t5zmBEakuBVeTrzaqDSC1sZdHQWGga7UcITBGGRQyuYw3NTraJaRdO7OOS
+cG2pAgMBAAEwDQYJKoZIhvcNAQEFBQADggIBAJ3pMaMcWaW5TJ1QV58npS/F7Ao7
+mciFMQ+KiQ6E5TJ/S37EfR/r5+mqQodM6Zvs07x4k2HdwcuI0cdpddLKfIH2znDW
+pJY1nEKI9W/pz9pEj3TBu9M3QAPzWVwYyBaJzVJGIll1yYVQVNGneHF8YpWQo+Ow
+yg97x1220oUSAlJ9zUwwls6QjJCo95PcClV9ZK6A+H17v+kwzBco7DwGhoxy3s+n
+D9+LjDa5Z6yk7Y1h+I4kIExenjuXT1wgQatruR8MBl8MX+KKeAi4neRdCBiDceHs
+zzO0f+IBNiF1J8THokV81i7DMbsHRGv28r3rcQpalDK9/rcBRVXUl0Kw8ZDQJLaS
+C1EuAcqw8TgvZOAhw431EpZW7Beek4xvrwTSzrF1XhlbD/1Jm8YAjGQyO138qzq2
+p40NRXgGL3rT6LEDcUVjL9D2z/7Tu7G9g17vleEzBC13ILnAOg/UFsZ4BuGNCnxa
+3PiJ7QaDBL0UA4uUuXjVgGTFzeDaTJbNCybcTKI7rD4zAa/4d05364gA3S1XJU66
+tH24Z3ncMBrh1GrsX4z6vLkNyb7m2wBqWBuyuVidm7rPcMGoggbrAsIP5vPjIMdg
+GR+ghPgzhJsbEg/WoSxv8+oljAJT2I1A53ulJaL4w6S/Ku1yEQ01Xk4vZEBJHAAw
+TJxrq625wwS0cKQd
+-----END CERTIFICATE-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/sni_server_domain2.pem php-5.3.29/ext/openssl/tests/sni_server_domain2.pem
--- php-5.3.29-ori/ext/openssl/tests/sni_server_domain2.pem	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/sni_server_domain2.pem	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,82 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIJKgIBAAKCAgEA52uBJ1tv4osh3GUqdiBS01FjnOnzdkNB/jAk+m0BH6DiKJT0
+jR6vspzutuPIn0FrVE7V112o4XOhYixjGfAl6qA/s5/mE0Jgw2BjIngvezFeqdsl
+1g2Z0B5CnCKZMy/DuByss3EXjA9uuOrEBanAwE+LrUEfmTQBtPZngl9Fn1TAqkYA
+4UBr/dOtSMSmam/dz6mkrlEWNUZqwuFCgQR2GMrTX0zD9bvXlD5Mvyi61DUc5YRR
+GYziMK0KySDowga5jIqrUt5svLaHIdOXHfMJjjctD+m3FNrfiC5uXN9WbDZ9LInK
+Cma/nZjhRHkwUETHksL8L/hzCNY3lk9Y4pMIChN7KdMMYvanADbVOeRp7RGA9+0W
+nKy3u2ECygCDJ+4w+IZYGeGp035HN4WnD6WbbaCq7GvdQ84EbnWus3T/9QlA1uGr
+EbmyrFLsQNiiVQUbhWJDAnQ17LcY9rn0TrQjD4hTXguJ/o1XNhiVPd1zNmm3+5H3
+twp4JkMc7byjRcKyl2bzPh1PVZNY1W4IsCtvvOb34g67jttQlr/L03wCmo+OvBY9
+dbB1CrxWJQJJ7BNJBr0Z4HYychUpAKM24uY8IMOSaYlhxWnKLCWOTBvb0i2KB6jt
+MyBUF5p03duJkZhKAh5i9/8yM6PEwq3hsJygo2yJ4iwI0eP372UdsitSukMCAwEA
+AQKCAgEA2IEiPrDz1u01y5y2AfexpVPSrt3NUUoRNn7SSZurXmzEyRS6SkB4PdFG
+H8KxUhUBFcn/k9JjCjGEvXUrbfvXbU9o6WLh/AiwwHivpnLscQO6PYzyM/VbfnKg
+/LP9wf6gy+G/zM00K2vQuZ2hsG6lDwYcdgWkS091fVi9dCIv36WJ7oM5lYMQxVLB
+HoAj9RYdXYensxHXhhYQEaxu7IdA+WbgI5uNBZwsTtuOL5UqXRgnpa6JtS6x+roZ
+ihuIxuVFuG+PYyMGdfMKL6JmEbXrrap/NREBoLg4Qo6135tuniTILN/oLpz8DbQW
+pFoA0kfWsr5K85IsBQtsy+oGDUtjS0pfhSPiB6ZxK3y4gZrtSnN+WvdBXU9A86HY
+f7kdJyKJh7KndJ6WE95EhJhJ8KJYHcSAXMxGctODTiZS55LSuwWed6zdw6bxn2+1
+KHPz/Bghd7JB2naVyLYC1eOtc2zhIdSlnnUOwrApKo5U96VryzfcySf1iul755k9
+chwTYPJc3JtuJXNLX+oEVUmZq+P57i1hf6xrGfMDdlRPkTS6ik4ybRw3ltVtNFGu
+XMrmASWE/tVdb4dsqSsklZXztF9CYeBwqzf2ChQIywwxNtKrr79o0vdaHnnRLT6a
+Nf904Wrig8jWSBFKN2UTJXLy129SBdnP5XXUrSePUin4d3QbNQECggEBAPoQj2sk
+1HIaXKyxUv10pJzz7/eYWMpondiKxsdg/yQsTkxGIj4A8mE5/zh3eERvC2d7U3bI
+p8eF0C1F4N25bkZRLNT680Gas8lRsrSiS9YXaIBB5Pw4OVmnlfGL9Vs2k/t8joU/
+9nQ9f9ZlLdtIcCUzrrp45RKv05rYfYX2tcpqVie9J0NK/Dj6iVbb+S9QgKuGK/Xi
+YcBJG+XX4YNmsgKxCU6UJkqO/YRfKlhfs/Armo8wPxx6CfP0gEvKJLDebXxb8SCW
+YQQo1ckNkocMOAJuTfAeFMcaGV3Rj+urxQZZGLxA3I0ynDa27SbE7IFQSORibL2X
+fWto8uGYA1FpGsMCggEBAOzpp8G9UCDl9yaAP/SNp52JU1/zC76b8gtFn2siFUiP
+c2q8n4T8K6MNUQhYdZ8BovNP0Sd4nJF9XOlpshiA/ELfpHUbK+XpQYueL+QkLVMV
+iGszy8kZbGLErglGC1n3GxSxa6C0k/MweQE+NFCyy24D2vyV9/RjhcMn8/eSHa9I
+Ot2oEBcJF1+R2j9FLQFZqNnsUZXh+vjpQOQOvGWLKC7RjRdMTiDxhbFwIbwts0O1
+/IjZdsaKUk936aLWeQLrzUMEvFJ1sr3xRegT53KJuQLLHZk0tEm0SHug84SkH0AT
+h8nY6zfeZSEPtfZOw3zydog2sXgakCwqUjTS1Rci6oECggEAZdjA0N6bOC3MePlv
+15LeSJ6BqdH+t9GMGFnNQ/8Za14wNZiK8b3o+fhpHlJqRVUEzAzKnaJz0yuI8id3
+wlZ3t2PwYn4i/SFJAEGqCy/euz+lbDdqT9+GXCGJTGu4boH4G4FLerHmaslxe5yR
+5LHIGx7Fl2UNx2KdSH/L//fParWMiXrctuefeoVv0lSdVMvw2+s1lFuzfGFKX35h
+ducosTfxlnN4dP1v+63WzU+NNdBMju0Th0GdNCLs7fFSqEavSOsZdjBJKyyGhfBl
+MWOknDjYvWdDByR2GGP1vgKjqEY5cNLqAQgP36j5RcUGnlRYm8wKhd1hU5HW+lKz
+Z0DriQKCAQEAiEMDp9z4/1MFSfGt1zy6UVOwzpj+Ak2zc2RCAt6Bm1BWs+d1YImh
+l5CLMN+gFypbzNH1nFw0wUF3dRDDzHAzp0r2ThyorP3yIxmCthdQsl7KLc6GwU2M
+F2rEJrVQxhfoTYiWPMJf7hnNHzfl4xxTAR3akDi5eqjbQJn0KkqyJCTJJsAJMRab
+iO5cttNUxVgKU/0mF6z4Kr4OAp2vIkBdhkAkhGfw7+W6XYn+/TrTxngfnZ5mQF9C
+ZE615GCzDUkOsCNDJbJocfMZoBgCoNAxxzeH+JxlrZaxsdmq9nlnN/WDvkazU1jo
+lZFxuQ8oRO832bSLcmbk0WIuEg/JXBtLAQKCAQEA5izB8Br8wNUNSp39OG/xDH3f
+s/u4WpEYaKTXGo9lAxFSxXUwN0vwW5h2LsInhyG9LC016BD/I4hsREYBfnSBZfHR
+QgnZZkvXiAL90fucoV2TakQqSK8TYDPrpXyq+AsZ8avA+H9XwWQTk7Bu/RjO7u1B
+MszCiYVi3zb9RSa3cCLKSlTAUQACGZGaqT2Y1hDbvWOtd7O9kCz8hURqPXianutm
+o7OqYpOh+4xvm1HsMm5cEH6u3pO43njcDGVd9Jq0cL5cKXkm4Q8Q6mEZd692PU89
+BMD3XwjysI/pYDf6+gAL75bSEQUyYDFk04gIkVr1fII+9DHEdTn+tvoTSsunLw==
+-----END RSA PRIVATE KEY-----
+-----BEGIN CERTIFICATE-----
+MIIFSDCCAzACAQIwDQYJKoZIhvcNAQEFBQAwcTELMAkGA1UEBhMCVVMxCzAJBgNV
+BAgMAlNDMRUwEwYDVQQHDAxNeXJ0bGUgQmVhY2gxHjAcBgNVBAoMFXBocC50ZXN0
+cyBzdWJvcmRpbmF0ZTEeMBwGA1UEAwwVcGhwLnRlc3RzLnN1Ym9yZGluYXRlMB4X
+DTE0MDMwNTE0MzAzMVoXDTI0MDMwMjE0MzAzMVowYzELMAkGA1UEBhMCVVMxCzAJ
+BgNVBAgMAlNDMRUwEwYDVQQHDAxNeXJ0bGUgQmVhY2gxGjAYBgNVBAoMEWRvbWFp
+bjIgdGVzdCBjZXJ0MRQwEgYDVQQDDAtkb21haW4yLmNvbTCCAiIwDQYJKoZIhvcN
+AQEBBQADggIPADCCAgoCggIBAOdrgSdbb+KLIdxlKnYgUtNRY5zp83ZDQf4wJPpt
+AR+g4iiU9I0er7Kc7rbjyJ9Ba1RO1dddqOFzoWIsYxnwJeqgP7Of5hNCYMNgYyJ4
+L3sxXqnbJdYNmdAeQpwimTMvw7gcrLNxF4wPbrjqxAWpwMBPi61BH5k0AbT2Z4Jf
+RZ9UwKpGAOFAa/3TrUjEpmpv3c+ppK5RFjVGasLhQoEEdhjK019Mw/W715Q+TL8o
+utQ1HOWEURmM4jCtCskg6MIGuYyKq1LebLy2hyHTlx3zCY43LQ/ptxTa34gublzf
+Vmw2fSyJygpmv52Y4UR5MFBEx5LC/C/4cwjWN5ZPWOKTCAoTeynTDGL2pwA21Tnk
+ae0RgPftFpyst7thAsoAgyfuMPiGWBnhqdN+RzeFpw+lm22gquxr3UPOBG51rrN0
+//UJQNbhqxG5sqxS7EDYolUFG4ViQwJ0Ney3GPa59E60Iw+IU14Lif6NVzYYlT3d
+czZpt/uR97cKeCZDHO28o0XCspdm8z4dT1WTWNVuCLArb7zm9+IOu47bUJa/y9N8
+ApqPjrwWPXWwdQq8ViUCSewTSQa9GeB2MnIVKQCjNuLmPCDDkmmJYcVpyiwljkwb
+29Itigeo7TMgVBeadN3biZGYSgIeYvf/MjOjxMKt4bCcoKNsieIsCNHj9+9lHbIr
+UrpDAgMBAAEwDQYJKoZIhvcNAQEFBQADggIBAAzy1BUPLBK3+230sILn9iJV+7DJ
+1pFOTBdChTn8UrCzP8NrhQ7TNyNuwETcjxOMZ0IYc9SBUZgQV2RZrGM4Ek2dV2so
+Z+HzQ9UsAl31t8bL1uSBH4lspAeSAIq8HyLK52JxZ4yBK8ID2e7oHzbqY58Xcfzn
+4WlA54XYNI1+gj6bBTP7lXLz40H9lcPTHDsed3usYYWtfH/ncIW0rw9/fK1P6aTO
+680lOaLFB26Z3ygGiJXbfmcnIjEmbpgWLfcPOoIBFrDmkiHqo31UT1WBxQ16c4yw
+DwO+DY5KK6adI1j5PWUmT/8vwlsO2CEtq4DOKfB51ggG9NyciCw+vJXP4Ec30IiX
+5TNWNwpg+ex44ICScSF6ew4hS2tO59VFBvDaa/2nFhEOG0iECN0537v10vOxgaVr
+kHlCgJtgCwUbKrfVTA2FogXRDIBJ1aOZiA7kIPPSqdTH49HwieH55Q5kfi7xak5y
+tSijrFw70vZOf3ORErmXEAZFqQgPuK4KlvTMom7z9QnNq4L579DeGUdBhLYGXJzP
+8WcMXRlQ7XUT6TQaSTDwDYlWcxcZ584seK4rVCLT2jyChEWSLR2K29hZ0eNVQt43
+3Xxz9hExGS/oELv53zPqp10w/0ZKlFQc5Wa4kEkjBz5R8VzzWuelxarqNAH6m9Du
+i3jyxtHS869PHMU3
+-----END CERTIFICATE-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/sni_server_domain3.pem php-5.3.29/ext/openssl/tests/sni_server_domain3.pem
--- php-5.3.29-ori/ext/openssl/tests/sni_server_domain3.pem	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/sni_server_domain3.pem	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,82 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIJKAIBAAKCAgEAruR9tBqYBDvB1DfMEhcFScRbKELR+ALF4a0EG/ferOfFyc4H
+gWS7pcTuzqtpqGNIZxQkR+ycosCN3ZaX2guubhDatLCGEIgnhFeyzjtLFwOyXZDb
+1sokz+LbeqdbecZl+m+9jyyD33/jit+WtTdyFam6Ng91j5uAC0zCB8K8la2TuZ33
+gVtiM51R0izKH2KSnoP6TIENUCNtBW6p1PxTfCmbxmU59sKSkX4M/7QjmW3VtzWA
+9Ev3+c6OFvdha24ChKmFbs6kZt9TtObopVriMOe3OnKfGOA8deIyVLoGgbOdCyVb
+ZIWImAh+dVECnxp5nGMHLRXzbGwcTy2C8y135qYd5d5RQec2V3+vLk0IY+jar8pL
+o9PCsqgyj0veajA5CL8cOvL1WaRRLUVJCxkjnIvn+9FbZeZfMO0yfszz7Sj3uQ7k
+EkWw8FPHvTXYam25YmLuh9aTShurR3WReUDa2QsaJvI3540yrTN+vVYVBFImdVn9
+fQ22Oyui1aZM7vAdIbA/KA1NqBD7EuYiwB87/JG2z5GFnBnyrJ/lQVpu2l/c7/yU
+9hRAEDolc0nugYvMGpVyfahCOaed1r358tG5oK4TA722zeUEcgX01rNko7BIHVCR
+Yu0IW2Z9SVQMEnDJwF/zXtrktLjHXBKlOfRWH4VvIxyNbxGOQQ/HrcWk9+ECAwEA
+AQKCAgB6QGgKJGjM1MSpxpMUthjRNruNyh+hoLaYCOwNbNevv5fHeAhRD4wH1UAl
+ITcLKNNskmzGBgR70+OW2HSvS2kTsR5gHeCo37PX08G+XT4hCUl+FAtH+id/VZGc
+DC5qUh/ozoEP+sr3yRrScXaUl/xcXjc3INlJmCYKQA6FhD901U+k+WIQf0OG1tph
+80MaazoYKiMlpTQcJ5dGq9N1eSgWa7NjHFFHRz1TDGyjtVUJI/i3R2Qr4IqniRZT
+wXrMsKp790+5ZCMRcdy+YIaRR5VDIEY5SfQiXGSG9qW+CgcQVPBa4TMgciNIOu/C
+q+0MMGJ/yc0zW9u7l1q2khauS8M6RAWXW+wLGelbezvidsO6I5sTfINoPbrEbQo4
+OpsiM5B+bncvXMnt0fbTiDFnjH51WbIFUSRFKNaMoDbvDThmfi5SAfTXDtXZHYa/
+9WBGTEDNO555S2+YPxwKdV6kd3irBDHzsnMtwsPyFxAmm2tvolp7MC1XD6G8mMpy
+PjXcsIz63fadO6DLEtJKTBorjZSbE13Edy+cpw9/EPQ8pyc1Nc7Z1dQlF7CR54UE
+jvvIF2K/PsSH+1sCNgvcKliImg55VGL8VyiqSvaxKhll59y0jaM1YOKYIcnP1Wq3
+Lwsu3htYZD4zVIhwM3Zi+jdr2fzJm8V2ZL1fsUM8ILyFgD98zQKCAQEA3ncyGBpH
+eCJajPbLAbbEjfghlWHVNdTInKENkVoIwehEv6e9tMjNr1ete4UdelxBiAQ/1O02
+Seka0JH8oXnl2v9oKGQHGKUYp7FNiaJ4duYtSzOU6U8scU9UyGolWY6P4l3Ac1cn
+VIoPuFRYG4jYZqto03yqueKCSg6oIC6jtXgzPxQlH+0jU7/f8WnbT7E/q5lpqpqg
+vY0m5XuQmhm6Ca6Ka8+UA7SpZqx892GkYu7lDdCw6ecF78EiO8u9bm9jntBTpND0
++uPIXDtBG+2t8QzYQwziI5D8wNVSQrhLBtuRT51YLrlEJlo99WBvooIOZawxA0jD
+uP/88TtLL9YqNwKCAQEAyUF7QKkguW6K1CJV9+ct7g9CqZQKhulexDtQLd8whl5j
+veKwZa5ItZtNVRcTfeuSyMrjo4wTUVAmtzLMxWljd5YQSdBpqaV5EV/F0y5uTzC5
+C0JUH1vvOUlQVPoqPjXNQ7AZ9StOoXje3kr+PENLvAlQuEedNNYNGm1W/Xbmi2l7
+Z3bY9WyBvv69aXqgbIp4uSiov4EJWZcpVKrOWvPcr6Lt0ubRTFhzcCYPp1Z32cI+
+HEGmp7rS4WBVXPFMNlaY74SUYQv5Ei2asBYz6Kst3I9CjHyZ7n/cOpsdUfJnzGdx
+y2cOPYwjmGtIQcpyrY9yQp7C5lsMLJ8zoPecFr0CpwKCAQAW3mfu5Fyuc9GdJg2O
+WoxwD67cHVd+liYdO80aQQgfbtIKZaLxv6atPLUfunpiRrOR2OX67HulM2pHQIqY
+yuAfGBxL8qRsGySisG5JFMOPbXAAiAfpx/LInyAXDhpSz33pBjwvXyky3pJpH3qD
+MhkUzNAU1X7zZt5/4GvWCxVXJUkXVenPE2CLTnEl7vzVf2INMNMU75pQgf8ang4q
+WTSvpBqkpI0RqHO1k0uxXn84kFhJiEd3dAE/OTpcrUAG5zp1a/L9QWG9nMbO/GRg
+C5nS6sAcfGmOwGvLIuK26x0DUnTom0MiYncn/iTaYZR4PyhduUq8jLFaBi6pWbAL
+9dcXAoIBAGwmZid/O3iqcKxCr1QCxWnShY4/YdDSA/0LqrCb6aWrf4oBEa3ylFwT
+UuFQ/0aBm2WPsfinQ5JEsilsgSHs2mjfGW2xM7bYl1DA2Lv9jYW8txPX1wDrFIkC
+XsrrjFvV6bJgJfLcDOs02v816Z1UxJQNpXUB9vb3uB7ldwPKK2Xrj0cwVLK+VpLe
+rcbLAP6TAwDtWpFetDmSw8Ed8LprpcI0mfzl0L9oINC5g1v3WXyJp3rjxL0J5lz6
+uaSyfrQMoS7FXj8wge5E14WcyNRVeNW3npmEM+w4hY5w4LayvxjW1g3qGXr1ngNA
+U5oXQr0GAu7OBgpoDwjDnKj5psWJWK0CggEBAIlWMA1dX0sBQLD0ZOJ61jg+5POQ
+tK/f8WI2+Bnn5DIPg2c29lNqPRR+xHEukzUBx9a7GiHYzMsxlBHHenQUQ6pF5ZPc
+nL7FcYrZKWlz3uT3eavFd+PPrlWTIguTJUXfwNHeDPSMHGm/b8tExq8SnzOGa2k9
+Mpn6iTxZ8fWWkso9NLGC6SyWVRTGinvNA5uNDJ7xKgpeWqrD4byjd/0rvQNVioxD
+HkWzHq+tVCoharJdxrjKlb0udhwFsCdhE2QV0I33sMaKZZtueeUsc57db+X/tjip
+E67ORm17t003JNkcC3nmSsCPUqq9LzDQGrFzHFWi7l4JRigC86xsEnpsA+c=
+-----END RSA PRIVATE KEY-----
+-----BEGIN CERTIFICATE-----
+MIIFTzCCAzcCAQIwDQYJKoZIhvcNAQEFBQAwcTELMAkGA1UEBhMCVVMxCzAJBgNV
+BAgMAlNDMRUwEwYDVQQHDAxNeXJ0bGUgQmVhY2gxHjAcBgNVBAoMFXBocC50ZXN0
+cyBzdWJvcmRpbmF0ZTEeMBwGA1UEAwwVcGhwLnRlc3RzLnN1Ym9yZGluYXRlMB4X
+DTE0MDMwNTE0MzA0M1oXDTI0MDMwMjE0MzA0M1owajELMAkGA1UEBhMCVVMxCzAJ
+BgNVBAgMAlNDMRUwEwYDVQQHDAxNeXJ0bGUgQmVhY2gxITAfBgNVBAoMGEludGVy
+bmV0IFdpZGdpdHMgUHR5IEx0ZDEUMBIGA1UEAwwLZG9tYWluMy5jb20wggIiMA0G
+CSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCu5H20GpgEO8HUN8wSFwVJxFsoQtH4
+AsXhrQQb996s58XJzgeBZLulxO7Oq2moY0hnFCRH7JyiwI3dlpfaC65uENq0sIYQ
+iCeEV7LOO0sXA7JdkNvWyiTP4tt6p1t5xmX6b72PLIPff+OK35a1N3IVqbo2D3WP
+m4ALTMIHwryVrZO5nfeBW2IznVHSLMofYpKeg/pMgQ1QI20FbqnU/FN8KZvGZTn2
+wpKRfgz/tCOZbdW3NYD0S/f5zo4W92FrbgKEqYVuzqRm31O05uilWuIw57c6cp8Y
+4Dx14jJUugaBs50LJVtkhYiYCH51UQKfGnmcYwctFfNsbBxPLYLzLXfmph3l3lFB
+5zZXf68uTQhj6Nqvykuj08KyqDKPS95qMDkIvxw68vVZpFEtRUkLGSOci+f70Vtl
+5l8w7TJ+zPPtKPe5DuQSRbDwU8e9NdhqbbliYu6H1pNKG6tHdZF5QNrZCxom8jfn
+jTKtM369VhUEUiZ1Wf19DbY7K6LVpkzu8B0hsD8oDU2oEPsS5iLAHzv8kbbPkYWc
+GfKsn+VBWm7aX9zv/JT2FEAQOiVzSe6Bi8walXJ9qEI5p53Wvfny0bmgrhMDvbbN
+5QRyBfTWs2SjsEgdUJFi7QhbZn1JVAwScMnAX/Ne2uS0uMdcEqU59FYfhW8jHI1v
+EY5BD8etxaT34QIDAQABMA0GCSqGSIb3DQEBBQUAA4ICAQDUel0pS4vCng3sQ2ab
+U4bSTDiiyR09TUlX54eaHrQFnnJAXxnHdu9S2xlizaGgkUHqQ7P6HXiMn5rl2GTw
+7uLcV2CoapceuX3HK+Iiy5r4phXtylmkUT737jR32Rib/jH7swkdPLDcnbI2J2Cs
+I1LIlCiuaJagu0q2liRnJOkdZQd1Rz3w9I/WHECxS9SAnaQsF4LbXabXObVeRrtq
+qiNoDbC0Q9c4RquVtbdjm4vP6eCjnqck/0Tq8ceq7Hg5hu3Q0scg3mEK+7cyp19X
+Y+/nCg8SZe+7LxewJ7GgqRgnDiHgfO5Nu4jhuZh72LA1mtIS+dU/cDVf8kxLiusG
+UlJKDwJ14Jh7LAKdRorqGFqNi8R5zEaCIcuSWvUfNl9TzOXlRj6c4lP8eixWG4FD
+CiHkv7jXsz8AYZcKy7IqsXVdnem+8PoKmBzhtngNX86W9JgQ65vLwsT4kdWHMfU0
+zEZrHZ3+qcmL5GUXI7r3uQQmp0RcNQV57X6bLRG4PaCMxuTv6JJ3Bi+qqX4vVWPL
+K1Au3W5UiJ3XPVllxSynA6lcUvVw/PoNLaV21sskxwJDtLwbSAH3DS0JQQSZzesj
+hGayf3SOVU1n84lTuc84KEgM+zaxGzqfShUadlLMKBS+w+8j8N+qBjUi08UOUKa7
+OAES8tCv7DK0Mi21rLXMadYwlw==
+-----END CERTIFICATE-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/stream_crypto_flags_001.phpt php-5.3.29/ext/openssl/tests/stream_crypto_flags_001.phpt
--- php-5.3.29-ori/ext/openssl/tests/stream_crypto_flags_001.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/stream_crypto_flags_001.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,46 @@
+--TEST--
+Basic bitwise stream crypto context flag assignment
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug54992.pem'
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    @stream_socket_accept($server, 1);
+    @stream_socket_accept($server, 1);
+    @stream_socket_accept($server, 1);
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $clientFlags = STREAM_CLIENT_CONNECT;
+    $clientCtx = stream_context_create(['ssl' => [
+        'verify_peer' => true,
+        'cafile' => __DIR__ . '/bug54992-ca.pem',
+        'peer_name' => 'bug54992.local',
+    ]]);
+
+    phpt_wait();
+
+    stream_context_set_option($clientCtx, 'ssl', 'crypto_method', STREAM_CRYPTO_METHOD_TLSv1_0_CLIENT);
+    var_dump(stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx));
+
+    stream_context_set_option($clientCtx, 'ssl', 'crypto_method', STREAM_CRYPTO_METHOD_TLS_CLIENT);
+    var_dump(stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx));
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+resource(%d) of type (stream)
+resource(%d) of type (stream)
diff -uNr php-5.3.29-ori/ext/openssl/tests/stream_crypto_flags_002.phpt php-5.3.29/ext/openssl/tests/stream_crypto_flags_002.phpt
--- php-5.3.29-ori/ext/openssl/tests/stream_crypto_flags_002.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/stream_crypto_flags_002.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,57 @@
+--TEST--
+TLSv1.1 and TLSv1.2 bitwise stream crypto flag assignment
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+if (OPENSSL_VERSION_NUMBER < 0x10001001) die("skip OpenSSLv1.0.1 required");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug54992.pem'
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    @stream_socket_accept($server, 1);
+    @stream_socket_accept($server, 1);
+    @stream_socket_accept($server, 1);
+    @stream_socket_accept($server, 1);
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $clientFlags = STREAM_CLIENT_CONNECT;
+    $clientCtx = stream_context_create(['ssl' => [
+        'verify_peer' => true,
+        'cafile' => __DIR__ . '/bug54992-ca.pem',
+        'peer_name' => 'bug54992.local',
+    ]]);
+
+    phpt_wait();
+
+    stream_context_set_option($clientCtx, 'ssl', 'crypto_method', STREAM_CRYPTO_METHOD_TLSv1_0_CLIENT);
+    var_dump(stream_socket_client($serverUri, $errno, $errstr, 2, $clientFlags, $clientCtx));
+
+    stream_context_set_option($clientCtx, 'ssl', 'crypto_method', STREAM_CRYPTO_METHOD_TLSv1_1_CLIENT);
+    var_dump(stream_socket_client($serverUri, $errno, $errstr, 2, $clientFlags, $clientCtx));
+
+    stream_context_set_option($clientCtx, 'ssl', 'crypto_method', STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT);
+    var_dump(stream_socket_client($serverUri, $errno, $errstr, 2, $clientFlags, $clientCtx));
+
+    stream_context_set_option($clientCtx, 'ssl', 'crypto_method', STREAM_CRYPTO_METHOD_TLS_CLIENT);
+    var_dump(stream_socket_client($serverUri, $errno, $errstr, 2, $clientFlags, $clientCtx));
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+resource(%d) of type (stream)
+resource(%d) of type (stream)
+resource(%d) of type (stream)
+resource(%d) of type (stream)
+
diff -uNr php-5.3.29-ori/ext/openssl/tests/stream_crypto_flags_003.phpt php-5.3.29/ext/openssl/tests/stream_crypto_flags_003.phpt
--- php-5.3.29-ori/ext/openssl/tests/stream_crypto_flags_003.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/stream_crypto_flags_003.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,56 @@
+--TEST--
+Server bitwise stream crypto flag assignment
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+if (OPENSSL_VERSION_NUMBER < 0x10001001) die("skip OpenSSLv1.0.1 required");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug54992.pem',
+
+        // Only accept TLSv1.2 connections
+        'crypto_method' => STREAM_CRYPTO_METHOD_SSLv3_SERVER  | STREAM_CRYPTO_METHOD_TLSv1_2_SERVER,
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    @stream_socket_accept($server, 1);
+    @stream_socket_accept($server, 1);
+    @stream_socket_accept($server, 1);
+    @stream_socket_accept($server, 1);
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $clientFlags = STREAM_CLIENT_CONNECT;
+    $clientCtx = stream_context_create(['ssl' => [
+        'verify_peer' => true,
+        'cafile' => __DIR__ . '/bug54992-ca.pem',
+        'peer_name' => 'bug54992.local',
+    ]]);
+
+    phpt_wait();
+
+    stream_context_set_option($clientCtx, 'ssl', 'crypto_method', STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT);
+    var_dump(stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx));
+
+    stream_context_set_option($clientCtx, 'ssl', 'crypto_method', STREAM_CRYPTO_METHOD_TLSv1_0_CLIENT);
+    var_dump(@stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx));
+
+    stream_context_set_option($clientCtx, 'ssl', 'crypto_method', STREAM_CRYPTO_METHOD_TLSv1_1_CLIENT);
+    var_dump(@stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx));
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+resource(%d) of type (stream)
+bool(false)
+bool(false)
+
diff -uNr php-5.3.29-ori/ext/openssl/tests/stream_crypto_flags_004.phpt php-5.3.29/ext/openssl/tests/stream_crypto_flags_004.phpt
--- php-5.3.29-ori/ext/openssl/tests/stream_crypto_flags_004.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/stream_crypto_flags_004.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,60 @@
+--TEST--
+Specific protocol method specification
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug54992.pem',
+        'crypto_method' => STREAM_CRYPTO_METHOD_TLSv1_0_SERVER,
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    @stream_socket_accept($server, 1);
+    @stream_socket_accept($server, 1);
+    @stream_socket_accept($server, 1);
+    @stream_socket_accept($server, 1);
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $clientFlags = STREAM_CLIENT_CONNECT;
+    $clientCtx = stream_context_create(['ssl' => [
+        'verify_peer' => true,
+        'cafile' => __DIR__ . '/bug54992-ca.pem',
+        'peer_name' => 'bug54992.local',
+    ]]);
+
+    phpt_wait();
+
+    // Should succeed because the SSLv23 handshake here is compatible with the
+    // TLSv1 hello method employed in the server
+    var_dump(@stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx));
+
+    // Should fail because the TLSv1.1 hello method is not supported
+    stream_context_set_option($clientCtx, 'ssl', 'crypto_method', STREAM_CRYPTO_METHOD_TLSv1_1_CLIENT);
+    var_dump(@stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx));
+
+    // Should fail because the TLSv1.2 hello method is not supported
+    stream_context_set_option($clientCtx, 'ssl', 'crypto_method', STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT);
+    var_dump(@stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx));
+
+    // Should succeed because we use the same TLSv1 hello
+    stream_context_set_option($clientCtx, 'ssl', 'crypto_method', STREAM_CRYPTO_METHOD_TLSv1_0_CLIENT);
+    var_dump(stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx));
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+resource(%d) of type (stream)
+bool(false)
+bool(false)
+resource(%d) of type (stream)
diff -uNr php-5.3.29-ori/ext/openssl/tests/stream_server_reneg_limit.phpt php-5.3.29/ext/openssl/tests/stream_server_reneg_limit.phpt
--- php-5.3.29-ori/ext/openssl/tests/stream_server_reneg_limit.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/stream_server_reneg_limit.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,89 @@
+--TEST--
+TLS server rate-limits client-initiated renegotiation
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+exec('openssl help', $out, $code);
+if ($code > 0) die("skip couldn't locate openssl binary");
+if(substr(PHP_OS, 0, 3) == 'WIN') {
+   die('skip not suitable for Windows');
+}
+?>
+--FILE--
+<?php
+
+/**
+ * This test uses the openssl binary directly to initiate renegotiation. At this time it's not
+ * possible renegotiate the TLS handshake in PHP userland, so using the openssl s_client binary
+ * command is the only feasible way to test renegotiation limiting functionality. It's not an ideal
+ * solution, but it's really the only way to get test coverage on the rate-limiting functionality
+ * given current limitations.
+ */
+
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug54992.pem',
+        'reneg_limit' => 0,
+        'reneg_window' => 30,
+        'reneg_limit_callback' => function($stream) {
+            var_dump($stream);
+        }
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    $clients = [];
+    while (1) {
+        $r = array_merge([$server], $clients);
+        $w = $e = [];
+
+        stream_select($r, $w, $e, $timeout=42);
+
+        foreach ($r as $sock) {
+            if ($sock === $server && ($client = stream_socket_accept($server, $timeout = 42))) {
+                $clientId = (int) $client;
+                $clients[$clientId] = $client;
+            } elseif ($sock !== $server) {
+                $clientId = (int) $sock;
+                $buffer = fread($sock, 1024);
+                if (strlen($buffer)) {
+                    continue;
+                } elseif (!is_resource($sock) || feof($sock)) {
+                    unset($clients[$clientId]);
+                    break 2;
+                }
+            }
+        }
+    }
+CODE;
+
+$clientCode = <<<'CODE'
+    $cmd = 'openssl s_client -connect 127.0.0.1:64321';
+    $descriptorSpec = [["pipe", "r"], ["pipe", "w"], ["pipe", "w"]];
+    $process = proc_open($cmd, $descriptorSpec, $pipes);
+
+    list($stdin, $stdout, $stderr) = $pipes;
+
+    // Trigger renegotiation twice
+    // Server settings only allow one per second (should result in disconnection)
+    fwrite($stdin, "R\nR\nR\nR\n");
+
+    $lines = [];
+    while(!feof($stderr)) {
+        fgets($stderr);
+    }
+
+    fclose($stdin);
+    fclose($stdout);
+    fclose($stderr);
+    proc_terminate($process);
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($serverCode, $clientCode);
+--EXPECTF--
+resource(%d) of type (stream)
diff -uNr php-5.3.29-ori/ext/openssl/tests/stream_verify_peer_name_001.phpt php-5.3.29/ext/openssl/tests/stream_verify_peer_name_001.phpt
--- php-5.3.29-ori/ext/openssl/tests/stream_verify_peer_name_001.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/stream_verify_peer_name_001.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,39 @@
+--TEST--
+Verify host name by default in client transfers
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug54992.pem'
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    @stream_socket_accept($server, 1);
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $clientFlags = STREAM_CLIENT_CONNECT;
+    $clientCtx = stream_context_create(['ssl' => [
+        'verify_peer' => false,
+        'peer_name' => 'bug54992.local'
+    ]]);
+
+    phpt_wait();
+    $client = stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx);
+
+    var_dump($client);
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+resource(%d) of type (stream)
diff -uNr php-5.3.29-ori/ext/openssl/tests/stream_verify_peer_name_002.phpt php-5.3.29/ext/openssl/tests/stream_verify_peer_name_002.phpt
--- php-5.3.29-ori/ext/openssl/tests/stream_verify_peer_name_002.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/stream_verify_peer_name_002.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,40 @@
+--TEST--
+Allow host name mismatch when "verify_host" disabled
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug54992.pem'
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    @stream_socket_accept($server, 1);
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $clientFlags = STREAM_CLIENT_CONNECT;
+    $clientCtx = stream_context_create(['ssl' => [
+        'verify_peer' => true,
+        'cafile' => __DIR__ . '/bug54992-ca.pem',
+        'verify_peer_name' => false
+    ]]);
+
+    phpt_wait();
+    $client = stream_socket_client($serverUri, $errno, $errstr, 2, $clientFlags, $clientCtx);
+
+    var_dump($client);
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+resource(%d) of type (stream)
diff -uNr php-5.3.29-ori/ext/openssl/tests/stream_verify_peer_name_003.phpt php-5.3.29/ext/openssl/tests/stream_verify_peer_name_003.phpt
--- php-5.3.29-ori/ext/openssl/tests/stream_verify_peer_name_003.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/stream_verify_peer_name_003.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,44 @@
+--TEST--
+Host name mismatch triggers error
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/bug54992.pem'
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    @stream_socket_accept($server, 1);
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $clientFlags = STREAM_CLIENT_CONNECT;
+    $clientCtx = stream_context_create(['ssl' => [
+        'verify_peer' => true,
+        'cafile' => __DIR__ . '/bug54992-ca.pem'
+    ]]);
+
+    phpt_wait();
+    $client = stream_socket_client($serverUri, $errno, $errstr, 1, $clientFlags, $clientCtx);
+
+    var_dump($client);
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+Warning: stream_socket_client(): Peer certificate CN=`bug54992.local' did not match expected CN=`127.0.0.1' in %s on line %d
+
+Warning: stream_socket_client(): Failed to enable crypto in %s on line %d
+
+Warning: stream_socket_client(): unable to connect to ssl://127.0.0.1:64321 (Unknown error) in %s on line %d
+bool(false)
diff -uNr php-5.3.29-ori/ext/openssl/tests/streams_crypto_method.pem php-5.3.29/ext/openssl/tests/streams_crypto_method.pem
--- php-5.3.29-ori/ext/openssl/tests/streams_crypto_method.pem	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/streams_crypto_method.pem	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,33 @@
+-----BEGIN CERTIFICATE-----
+MIIC5jCCAk+gAwIBAgIBADANBgkqhkiG9w0BAQQFADBcMQswCQYDVQQGEwJBVTET
+MBEGA1UECBMKUXVlZW5zbGFuZDEaMBgGA1UEChMRQ3J5cHRTb2Z0IFB0eSBMdGQx
+HDAaBgNVBAMTE1Rlc3QgUENBICgxMDI0IGJpdCkwHhcNOTkxMjAyMjEzNTQ4WhcN
+MDUwNzExMjEzNTQ4WjBcMQswCQYDVQQGEwJBVTETMBEGA1UECBMKUXVlZW5zbGFu
+ZDEaMBgGA1UEChMRQ3J5cHRTb2Z0IFB0eSBMdGQxHDAaBgNVBAMTE1Rlc3QgUENB
+ICgxMDI0IGJpdCkwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAJ2haT/f5Zwy
+V+MiuSDjSR62adBoSiBB7Usty44lXqsp9RICw+DCCxpsn/CfxPEDXLLd4olsWXc6
+JRcxGynbYmnzk+Z6aIPPJQhK3CTvaqGnWKZsA1m+WaUIUqJCuNTK4N+7hMAGaf6S
+S3e9HVgEQ4a34gXJ7VQFVIBNV1EnZRWHAgMBAAGjgbcwgbQwHQYDVR0OBBYEFE0R
+aEcrj18q1dw+G6nJbsTWR213MIGEBgNVHSMEfTB7gBRNEWhHK49fKtXcPhupyW7E
+1kdtd6FgpF4wXDELMAkGA1UEBhMCQVUxEzARBgNVBAgTClF1ZWVuc2xhbmQxGjAY
+BgNVBAoTEUNyeXB0U29mdCBQdHkgTHRkMRwwGgYDVQQDExNUZXN0IFBDQSAoMTAy
+NCBiaXQpggEAMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEEBQADgYEAUa8B3pho
++Mvxeq9HsEzJxHIFQla05S5J/e/V+DQTYoKiRFchKPrDAdrzYSEvP3h4QJEtsNqQ
+JfOxg5M42uLFq7aPGWkF6ZZqZsYS+zA9IVT14g7gNA6Ne+5QtJqQtH9HA24st0T0
+Tga/lZ9M2ovImovaxSL/kRHbpCWcqWVxpOw=
+-----END CERTIFICATE-----
+-----BEGIN RSA PRIVATE KEY-----
+MIICXAIBAAKBgQCdoWk/3+WcMlfjIrkg40ketmnQaEogQe1LLcuOJV6rKfUSAsPg
+wgsabJ/wn8TxA1yy3eKJbFl3OiUXMRsp22Jp85PmemiDzyUIStwk72qhp1imbANZ
+vlmlCFKiQrjUyuDfu4TABmn+kkt3vR1YBEOGt+IFye1UBVSATVdRJ2UVhwIDAQAB
+AoGAba4fTtuap5l7/8ZsbE7Z1O32KJY4ZcOZukLOLUUhXxXduT+FTgGWujc0/rgc
+z9qYCLlNZHOouMYTgtSfYvuMuLZ11VIt0GYH+nRioLShE59Yy+zCRyC+gPigS1kz
+xvo14AsOIPYV14Tk/SsHyq6E0eTk7VzaIE197giiINUERPECQQDSKmtPTh/lRKw7
+HSZSM0I1mFWn/1zqrAbontRQY5w98QWIOe5qmzYyFbPXYT3d9BzlsMyhgiRNoBbD
+yvohSHXJAkEAwAHx6ezAZeWWzD5yXD36nyjpkVCw7Tk7TSmOceLJMWt1QcrCfqlS
+xA5jjpQ6Z8suU5DdtWAryM2sAir1WisYzwJAd6Zcx56jvAQ3xcPXsE6scBTVFzrj
+7FqZ6E+cclPzfLQ+QQsyOBE7bpI6e/FJppY26XGZXo3YGzV8IGXrt40oOQJALETG
+h86EFXo3qGOFbmsDy4pdP5nBERCu8X1xUCSfintiD4c2DInxgS5oGclnJeMcjTvL
+QjQoJCX3UJCi/OUO1QJBAKgcDHWjMvt+l1pjJBsSEZ0HX9AAIIVx0RQmbFGS+F2Q
+hhu5l77WnnZOQ9vvhV5u7NPCUF9nhU3jh60qWWO8mkc=
+-----END RSA PRIVATE KEY-----
diff -uNr php-5.3.29-ori/ext/openssl/tests/streams_crypto_method.phpt php-5.3.29/ext/openssl/tests/streams_crypto_method.phpt
--- php-5.3.29-ori/ext/openssl/tests/streams_crypto_method.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/streams_crypto_method.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,53 @@
+--TEST--
+Specific crypto method for ssl:// transports.
+--SKIPIF--
+<?php
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+if (OPENSSL_VERSION_NUMBER < 0x10001001) die("skip OpenSSLv1.0.1 required");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $serverUri = "ssl://127.0.0.1:64321";
+    $serverFlags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN;
+    $serverCtx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/streams_crypto_method.pem',
+    ]]);
+
+    $server = stream_socket_server($serverUri, $errno, $errstr, $serverFlags, $serverCtx);
+    phpt_notify();
+
+    $client = @stream_socket_accept($server);
+    if ($client) {
+        $in = '';
+        while (!preg_match('/\r?\n\r?\n/', $in)) {
+            $in .= fread($client, 2048);
+        }
+        $response = "HTTP/1.0 200 OK\r\n"
+                  . "Content-Type: text/plain\r\n"
+                  . "Content-Length: 12\r\n"
+                  . "Connection: close\r\n"
+                  . "\r\n"
+                  . "Hello World!";
+        fwrite($client, $response);
+        fclose($client);
+    }
+CODE;
+
+$clientCode = <<<'CODE'
+    $serverUri = "https://127.0.0.1:64321/";
+    $clientFlags = STREAM_CLIENT_CONNECT;
+    $clientCtx = stream_context_create(['ssl' => [
+        'crypto_method' => STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT,
+        'verify_peer' => false,
+        'verify_peer_name' => false
+    ]]);
+
+    phpt_wait();
+    echo file_get_contents($serverUri, false, $clientCtx);
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+Hello World!
diff -uNr php-5.3.29-ori/ext/openssl/tests/tlsv1.0_wrapper.phpt php-5.3.29/ext/openssl/tests/tlsv1.0_wrapper.phpt
--- php-5.3.29-ori/ext/openssl/tests/tlsv1.0_wrapper.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/tlsv1.0_wrapper.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,47 @@
+--TEST--
+tlsv1.0 stream wrapper
+--SKIPIF--
+<?php 
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $flags = STREAM_SERVER_BIND|STREAM_SERVER_LISTEN;
+    $ctx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/streams_crypto_method.pem',
+    ]]);
+
+    $server = stream_socket_server('tlsv1.0://127.0.0.1:64321', $errno, $errstr, $flags, $ctx);
+    phpt_notify();
+
+    for ($i=0; $i < 3; $i++) {
+        @stream_socket_accept($server, 3);
+    }
+CODE;
+
+$clientCode = <<<'CODE'
+    $flags = STREAM_CLIENT_CONNECT;
+    $ctx = stream_context_create(['ssl' => [
+        'verify_peer' => false,
+        'verify_peer_name' => false,
+    ]]);
+
+    phpt_wait();
+
+    $client = stream_socket_client("tlsv1.0://127.0.0.1:64321", $errno, $errstr, 3, $flags, $ctx);
+    var_dump($client);
+
+    $client = @stream_socket_client("sslv3://127.0.0.1:64321", $errno, $errstr, 3, $flags, $ctx);
+    var_dump($client);
+
+    $client = @stream_socket_client("tlsv1.2://127.0.0.1:64321", $errno, $errstr, 3, $flags, $ctx);
+    var_dump($client);
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+resource(%d) of type (stream)
+bool(false)
+bool(false)
diff -uNr php-5.3.29-ori/ext/openssl/tests/tlsv1.1_wrapper.phpt php-5.3.29/ext/openssl/tests/tlsv1.1_wrapper.phpt
--- php-5.3.29-ori/ext/openssl/tests/tlsv1.1_wrapper.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/tlsv1.1_wrapper.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,48 @@
+--TEST--
+tlsv1.1 stream wrapper
+--SKIPIF--
+<?php 
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+if (OPENSSL_VERSION_NUMBER < 0x10001001) die("skip OpenSSL 1.0.1 required");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $flags = STREAM_SERVER_BIND|STREAM_SERVER_LISTEN;
+    $ctx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/streams_crypto_method.pem',
+    ]]);
+
+    $server = stream_socket_server('tlsv1.1://127.0.0.1:64321', $errno, $errstr, $flags, $ctx);
+    phpt_notify();
+
+    for ($i=0; $i < 3; $i++) {
+        @stream_socket_accept($server, 3);
+    }
+CODE;
+
+$clientCode = <<<'CODE'
+    $flags = STREAM_CLIENT_CONNECT;
+    $ctx = stream_context_create(['ssl' => [
+        'verify_peer' => false,
+        'verify_peer_name' => false,
+    ]]);
+
+    phpt_wait();
+
+    $client = stream_socket_client("tlsv1.1://127.0.0.1:64321", $errno, $errstr, 3, $flags, $ctx);
+    var_dump($client);
+    
+    $client = @stream_socket_client("sslv3://127.0.0.1:64321", $errno, $errstr, 3, $flags, $ctx);
+    var_dump($client);
+    
+    $client = @stream_socket_client("tlsv1.2://127.0.0.1:64321", $errno, $errstr, 3, $flags, $ctx);
+    var_dump($client);
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+resource(%d) of type (stream)
+bool(false)
+bool(false)
diff -uNr php-5.3.29-ori/ext/openssl/tests/tlsv1.2_wrapper.phpt php-5.3.29/ext/openssl/tests/tlsv1.2_wrapper.phpt
--- php-5.3.29-ori/ext/openssl/tests/tlsv1.2_wrapper.phpt	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/openssl/tests/tlsv1.2_wrapper.phpt	2019-01-26 02:28:51.216128000 +0800
@@ -0,0 +1,48 @@
+--TEST--
+tlsv1.2 stream wrapper
+--SKIPIF--
+<?php 
+if (!extension_loaded("openssl")) die("skip openssl not loaded");
+if (!function_exists("proc_open")) die("skip no proc_open");
+if (OPENSSL_VERSION_NUMBER < 0x10001001) die("skip OpenSSL 1.0.1 required");
+--FILE--
+<?php
+$serverCode = <<<'CODE'
+    $flags = STREAM_SERVER_BIND|STREAM_SERVER_LISTEN;
+    $ctx = stream_context_create(['ssl' => [
+        'local_cert' => __DIR__ . '/streams_crypto_method.pem',
+    ]]);
+
+    $server = stream_socket_server('tlsv1.2://127.0.0.1:64321', $errno, $errstr, $flags, $ctx);
+    phpt_notify();
+
+    for ($i=0; $i < 3; $i++) {
+        @stream_socket_accept($server, 3);
+    }
+CODE;
+
+$clientCode = <<<'CODE'
+    $flags = STREAM_CLIENT_CONNECT;
+    $ctx = stream_context_create(['ssl' => [
+        'verify_peer' => false,
+        'verify_peer_name' => false,
+    ]]);
+
+    phpt_wait();
+
+    $client = stream_socket_client("tlsv1.2://127.0.0.1:64321", $errno, $errstr, 3, $flags, $ctx);
+    var_dump($client);
+    
+    $client = @stream_socket_client("sslv3://127.0.0.1:64321", $errno, $errstr, 3, $flags, $ctx);
+    var_dump($client);
+    
+    $client = @stream_socket_client("tlsv1.1://127.0.0.1:64321", $errno, $errstr, 3, $flags, $ctx);
+    var_dump($client);
+CODE;
+
+include 'ServerClientTestCase.inc';
+ServerClientTestCase::getInstance()->run($clientCode, $serverCode);
+--EXPECTF--
+resource(%d) of type (stream)
+bool(false)
+bool(false)
diff -uNr php-5.3.29-ori/ext/openssl/xp_ssl.c php-5.3.29/ext/openssl/xp_ssl.c
--- php-5.3.29-ori/ext/openssl/xp_ssl.c	2019-01-25 02:38:50.304556249 +0800
+++ php-5.3.29/ext/openssl/xp_ssl.c	2019-01-26 12:03:40.432141695 +0800
@@ -2,7 +2,7 @@
   +----------------------------------------------------------------------+
   | PHP Version 5                                                        |
   +----------------------------------------------------------------------+
-  | Copyright (c) 1997-2013 The PHP Group                                |
+  | Copyright (c) 1997-2016 The PHP Group                                |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
@@ -12,40 +12,97 @@
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
-  | Author: Wez Furlong <wez@thebrainroom.com>                           |
+  | Authors: Wez Furlong <wez@thebrainroom.com>                          |
+  |          Daniel Lowrey <rdlowrey@php.net>                            |
+  |          Chris Wright <daverandom@php.net>                           |
   +----------------------------------------------------------------------+
 */
 
 /* $Id$ */
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include "php.h"
 #include "ext/standard/file.h"
 #include "ext/standard/url.h"
 #include "streams/php_streams_int.h"
 #include "ext/standard/php_smart_str.h"
-#include "php_network.h"
 #include "php_openssl.h"
+#include "php_network.h"
 #include <openssl/ssl.h>
 #include <openssl/x509.h>
+#include <openssl/x509v3.h>
 #include <openssl/err.h>
 
 #ifdef PHP_WIN32
+#include "win32/winutil.h"
 #include "win32/time.h"
+#include <Wincrypt.h>
+/* These are from Wincrypt.h, they conflict with OpenSSL */
+#undef X509_NAME
+#undef X509_CERT_PAIR
+#undef X509_EXTENSIONS
 #endif
 
 #ifdef NETWARE
 #include <sys/select.h>
 #endif
 
-int php_openssl_apply_verification_policy(SSL *ssl, X509 *peer, php_stream *stream TSRMLS_DC);
-SSL *php_SSL_new_from_context(SSL_CTX *ctx, php_stream *stream TSRMLS_DC);
-int php_openssl_get_x509_list_id(void);
+#if !defined(OPENSSL_NO_ECDH) && OPENSSL_VERSION_NUMBER >= 0x0090800fL
+#define HAVE_ECDH 1
+#endif
+
+#if OPENSSL_VERSION_NUMBER >= 0x00908070L && !defined(OPENSSL_NO_TLSEXT)
+#define HAVE_SNI 1 
+#endif
+
+/* Flags for determining allowed stream crypto methods */
+#define STREAM_CRYPTO_IS_CLIENT            (1<<0)
+#define STREAM_CRYPTO_METHOD_SSLv2         (1<<1)
+#define STREAM_CRYPTO_METHOD_SSLv3         (1<<2)
+#define STREAM_CRYPTO_METHOD_TLSv1_0       (1<<3)
+#define STREAM_CRYPTO_METHOD_TLSv1_1       (1<<4)
+#define STREAM_CRYPTO_METHOD_TLSv1_2       (1<<5)
+
+/* Simplify ssl context option retrieval */
+#define GET_VER_OPT(name)               (stream->context && SUCCESS == php_stream_context_get_option(stream->context, "ssl", name, &val))
+#define GET_VER_OPT_STRING(name, str)   if (GET_VER_OPT(name)) { convert_to_string_ex(val); str = Z_STRVAL_PP(val); }
+#define GET_VER_OPT_LONG(name, num)     if (GET_VER_OPT(name)) { convert_to_long_ex(val); num = Z_LVAL_PP(val); }
+
+/* Used for peer verification in windows */
+#define PHP_X509_NAME_ENTRY_TO_UTF8(ne, i, out) ASN1_STRING_to_UTF8(&out, X509_NAME_ENTRY_get_data(X509_NAME_get_entry(ne, i)))
+
+extern php_stream* php_openssl_get_stream_from_ssl_handle(const SSL *ssl);
+extern int php_openssl_x509_fingerprint(X509 *peer, const char *method, zend_bool raw, char **out, int *out_len TSRMLS_DC);
+extern int php_openssl_get_ssl_stream_data_index();
+extern int php_openssl_get_x509_list_id(void);
+static struct timeval subtract_timeval( struct timeval a, struct timeval b );
+static int compare_timeval( struct timeval a, struct timeval b );
+static size_t php_openssl_sockop_io(int read, php_stream *stream, char *buf, size_t count TSRMLS_DC);
+
+php_stream_ops php_openssl_socket_ops;
+
+/* Certificate contexts used for server-side SNI selection */
+typedef struct _php_openssl_sni_cert_t {
+	char *name;
+	SSL_CTX *ctx;
+} php_openssl_sni_cert_t;
+
+/* Provides leaky bucket handhsake renegotiation rate-limiting  */
+typedef struct _php_openssl_handshake_bucket_t {
+	long prev_handshake;
+	long limit;
+	long window;
+	float tokens;
+	unsigned should_close;
+} php_openssl_handshake_bucket_t;
 
 /* This implementation is very closely tied to the that of the native
  * sockets implemented in the core.
  * Don't try this technique in other extensions!
  * */
-
 typedef struct _php_openssl_netstream_data_t {
 	php_netstream_data_t s;
 	SSL *ssl_handle;
@@ -55,16 +112,17 @@
 	int is_client;
 	int ssl_active;
 	php_stream_xport_crypt_method_t method;
-	char *sni;
+	php_openssl_handshake_bucket_t *reneg;
+	php_openssl_sni_cert_t *sni_certs;
+	unsigned sni_cert_count;
+	char *url_name;
 	unsigned state_set:1;
 	unsigned _spare:31;
 } php_openssl_netstream_data_t;
 
-php_stream_ops php_openssl_socket_ops;
-
 /* it doesn't matter that we do some hash traversal here, since it is done only
  * in an error condition arising from a network connection problem */
-static int is_http_stream_talking_to_iis(php_stream *stream TSRMLS_DC)
+static int is_http_stream_talking_to_iis(php_stream *stream TSRMLS_DC) /* {{{ */
 {
 	if (stream->wrapperdata && stream->wrapper && strcasecmp(stream->wrapper->wops->label, "HTTP") == 0) {
 		/* the wrapperdata is an array zval containing the headers */
@@ -87,8 +145,9 @@
 	}
 	return 0;
 }
+/* }}} */
 
-static int handle_ssl_error(php_stream *stream, int nr_bytes, zend_bool is_init TSRMLS_DC)
+static int handle_ssl_error(php_stream *stream, int nr_bytes, zend_bool is_init TSRMLS_DC) /* {{{ */
 {
 	php_openssl_netstream_data_t *sslsock = (php_openssl_netstream_data_t*)stream->abstract;
 	int err = SSL_get_error(sslsock->ssl_handle, nr_bytes);
@@ -170,257 +229,1467 @@
 	}
 	return retry;
 }
+/* }}} */
 
+static int verify_callback(int preverify_ok, X509_STORE_CTX *ctx) /* {{{ */
+{
+	php_stream *stream;
+	SSL *ssl;
+	int err, depth, ret;
+	zval **val;
+	unsigned long allowed_depth = OPENSSL_DEFAULT_STREAM_VERIFY_DEPTH;
+
+	ret = preverify_ok;
+
+	/* determine the status for the current cert */
+	err = X509_STORE_CTX_get_error(ctx);
+	depth = X509_STORE_CTX_get_error_depth(ctx);
+
+	/* conjure the stream & context to use */
+	ssl = X509_STORE_CTX_get_ex_data(ctx, SSL_get_ex_data_X509_STORE_CTX_idx());
+	stream = (php_stream*)SSL_get_ex_data(ssl, php_openssl_get_ssl_stream_data_index());
+
+	/* if allow_self_signed is set, make sure that verification succeeds */
+	if (err == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT &&
+		GET_VER_OPT("allow_self_signed") &&
+		zend_is_true(*val)
+	) {
+		ret = 1;
+	}
+
+	/* check the depth */
+	GET_VER_OPT_LONG("verify_depth", allowed_depth);
+	if ((unsigned long)depth > allowed_depth) {
+		ret = 0;
+		X509_STORE_CTX_set_error(ctx, X509_V_ERR_CERT_CHAIN_TOO_LONG);
+	}
 
-static size_t php_openssl_sockop_write(php_stream *stream, const char *buf, size_t count TSRMLS_DC)
+	return ret;
+}
+/* }}} */
+
+static int php_x509_fingerprint_cmp(X509 *peer, const char *method, const char *expected TSRMLS_DC)
 {
-	php_openssl_netstream_data_t *sslsock = (php_openssl_netstream_data_t*)stream->abstract;
-	int didwrite;
-	
-	if (sslsock->ssl_active) {
-		int retry = 1;
+	char *fingerprint;
+	int fingerprint_len;
+	int result = -1;
 
-		do {
-			didwrite = SSL_write(sslsock->ssl_handle, buf, count);
+	if (php_openssl_x509_fingerprint(peer, method, 0, &fingerprint, &fingerprint_len TSRMLS_CC) == SUCCESS) {
+		result = strcasecmp(expected, fingerprint);
+		efree(fingerprint);
+	}
 
-			if (didwrite <= 0) {
-				retry = handle_ssl_error(stream, didwrite, 0 TSRMLS_CC);
-			} else {
+	return result;
+}
+
+static zend_bool php_x509_fingerprint_match(X509 *peer, zval *val TSRMLS_DC)
+{
+	if (Z_TYPE_P(val) == IS_STRING) {
+		const char *method = NULL;
+
+		switch (Z_STRLEN_P(val)) {
+			case 32:
+				method = "md5";
 				break;
-			}
-		} while(retry);
 
-		if (didwrite > 0) {
-			php_stream_notify_progress_increment(stream->context, didwrite, 0);
+			case 40:
+				method = "sha1";
+				break;
+		}
+
+		return method && php_x509_fingerprint_cmp(peer, method, Z_STRVAL_P(val) TSRMLS_CC) == 0;
+
+	} else if (Z_TYPE_P(val) == IS_ARRAY) {
+		HashPosition pos;
+		zval **current;
+		char *key;
+		uint key_len;
+		ulong key_index;
+
+		if (!zend_hash_num_elements(Z_ARRVAL_P(val))) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid peer_fingerprint array; [algo => fingerprint] form required");
+			return 0;
 		}
+
+		for (zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(val), &pos);
+			zend_hash_get_current_data_ex(Z_ARRVAL_P(val), (void **)&current, &pos) == SUCCESS;
+			zend_hash_move_forward_ex(Z_ARRVAL_P(val), &pos)
+		) {
+			int key_type = zend_hash_get_current_key_ex(Z_ARRVAL_P(val), &key, &key_len, &key_index, 0, &pos);
+
+			if (!(key_type == HASH_KEY_IS_STRING && Z_TYPE_PP(current) == IS_STRING)) {
+				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid peer_fingerprint array; [algo => fingerprint] form required");
+				return 0;
+			}
+			if (php_x509_fingerprint_cmp(peer, key, Z_STRVAL_PP(current) TSRMLS_CC) != 0) {
+				return 0;
+			}
+		}
+
+		return 1;
+
 	} else {
-		didwrite = php_stream_socket_ops.write(stream, buf, count TSRMLS_CC);
+		php_error_docref(NULL TSRMLS_CC, E_WARNING,
+			"Invalid peer_fingerprint value; fingerprint string or array of the form [algo => fingerprint] required");
 	}
 
-	if (didwrite < 0) {
-		didwrite = 0;
+	return 0;
+}
+
+static zend_bool matches_wildcard_name(const char *subjectname, const char *certname) /* {{{ */
+{
+	char *wildcard = NULL;
+	int prefix_len, suffix_len, subject_len;
+
+	if (strcasecmp(subjectname, certname) == 0) {
+		return 1;
 	}
-	
-	return didwrite;
+
+	/* wildcard, if present, must only be present in the left-most component */
+	if (!(wildcard = strchr(certname, '*')) || memchr(certname, '.', wildcard - certname)) {
+		return 0;
+	}
+
+	/* 1) prefix, if not empty, must match subject */
+	prefix_len = wildcard - certname;
+	if (prefix_len && strncasecmp(subjectname, certname, prefix_len) != 0) {
+		return 0;
+	}
+
+	suffix_len = strlen(wildcard + 1);
+	subject_len = strlen(subjectname);
+	if (suffix_len <= subject_len) {
+		/* 2) suffix must match
+		 * 3) no . between prefix and suffix
+		 **/
+		return strcasecmp(wildcard + 1, subjectname + subject_len - suffix_len) == 0 &&
+			memchr(subjectname + prefix_len, '.', subject_len - suffix_len - prefix_len) == NULL;
+	}
+
+	return 0;
+}
+/* }}} */
+
+static zend_bool matches_san_list(X509 *peer, const char *subject_name) /* {{{ */
+{
+	int i, len;
+	unsigned char *cert_name = NULL;
+	char ipbuffer[64];
+
+	GENERAL_NAMES *alt_names = X509_get_ext_d2i(peer, NID_subject_alt_name, 0, 0);
+	int alt_name_count = sk_GENERAL_NAME_num(alt_names);
+
+	for (i = 0; i < alt_name_count; i++) {
+		GENERAL_NAME *san = sk_GENERAL_NAME_value(alt_names, i);
+
+		if (san->type == GEN_DNS) {
+			ASN1_STRING_to_UTF8(&cert_name, san->d.dNSName);
+			if (ASN1_STRING_length(san->d.dNSName) != strlen((const char*)cert_name)) {
+				OPENSSL_free(cert_name);
+				/* prevent null-byte poisoning*/
+				continue;
+			}
+
+			/* accommodate valid FQDN entries ending in "." */
+			len = strlen((const char*)cert_name);
+			if (len && strcmp((const char *)&cert_name[len-1], ".") == 0) {
+				cert_name[len-1] = '\0';
+			}
+
+			if (matches_wildcard_name(subject_name, (const char *)cert_name)) {
+				OPENSSL_free(cert_name);
+				return 1;
+			}
+			OPENSSL_free(cert_name);
+		} else if (san->type == GEN_IPADD) {
+			if (san->d.iPAddress->length == 4) {
+				sprintf(ipbuffer, "%d.%d.%d.%d",
+					san->d.iPAddress->data[0],
+					san->d.iPAddress->data[1],
+					san->d.iPAddress->data[2],
+					san->d.iPAddress->data[3]
+				);
+				if (strcasecmp(subject_name, (const char*)ipbuffer) == 0) {
+					return 1;
+				}
+			}
+			/* No, we aren't bothering to check IPv6 addresses. Why?
+			 * Because IP SAN names are officially deprecated and are
+			 * not allowed by CAs starting in 2015. Deal with it.
+			 */
+		}
+	}
+
+	return 0;
+}
+/* }}} */
+
+static zend_bool matches_common_name(X509 *peer, const char *subject_name TSRMLS_DC) /* {{{ */
+{
+	char buf[1024];
+	X509_NAME *cert_name;
+	zend_bool is_match = 0;
+	int cert_name_len;
+
+	cert_name = X509_get_subject_name(peer);
+	cert_name_len = X509_NAME_get_text_by_NID(cert_name, NID_commonName, buf, sizeof(buf));
+
+	if (cert_name_len == -1) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to locate peer certificate CN");
+	} else if (cert_name_len != strlen(buf)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Peer certificate CN=`%.*s' is malformed", cert_name_len, buf);
+	} else if (matches_wildcard_name(subject_name, buf)) {
+		is_match = 1;
+	} else {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Peer certificate CN=`%.*s' did not match expected CN=`%s'", cert_name_len, buf, subject_name);
+	}
+
+	return is_match;
 }
+/* }}} */
 
-static size_t php_openssl_sockop_read(php_stream *stream, char *buf, size_t count TSRMLS_DC)
+static int apply_peer_verification_policy(SSL *ssl, X509 *peer, php_stream *stream TSRMLS_DC) /* {{{ */
 {
+	zval **val = NULL;
+	char *peer_name = NULL;
+	int err,
+		must_verify_peer,
+		must_verify_peer_name,
+		must_verify_fingerprint,
+		has_cnmatch_ctx_opt;
+
 	php_openssl_netstream_data_t *sslsock = (php_openssl_netstream_data_t*)stream->abstract;
-	int nr_bytes = 0;
 
-	if (sslsock->ssl_active) {
-		int retry = 1;
+	must_verify_peer = GET_VER_OPT("verify_peer")
+		? zend_is_true(*val)
+		: sslsock->is_client;
+
+	has_cnmatch_ctx_opt = GET_VER_OPT("CN_match");
+	must_verify_peer_name = (has_cnmatch_ctx_opt || GET_VER_OPT("verify_peer_name"))
+		? zend_is_true(*val)
+		: sslsock->is_client;
+
+	must_verify_fingerprint = GET_VER_OPT("peer_fingerprint");
+
+	if ((must_verify_peer || must_verify_peer_name || must_verify_fingerprint) && peer == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not get peer certificate");
+		return FAILURE;
+	}
+
+	/* Verify the peer against using CA file/path settings */
+	if (must_verify_peer) {
+		err = SSL_get_verify_result(ssl);
+		switch (err) {
+			case X509_V_OK:
+				/* fine */
+				break;
+			case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
+				if (GET_VER_OPT("allow_self_signed") && zend_is_true(*val)) {
+					/* allowed */
+					break;
+				}
+				/* not allowed, so fall through */
+			default:
+				php_error_docref(NULL TSRMLS_CC, E_WARNING,
+						"Could not verify peer: code:%d %s",
+						err,
+						X509_verify_cert_error_string(err)
+				);
+				return FAILURE;
+		}
+	}
 
-		do {
-			nr_bytes = SSL_read(sslsock->ssl_handle, buf, count);
+	/* If a peer_fingerprint match is required this trumps peer and peer_name verification */
+	if (must_verify_fingerprint) {
+		if (Z_TYPE_PP(val) == IS_STRING || Z_TYPE_PP(val) == IS_ARRAY) {
+			if (!php_x509_fingerprint_match(peer, *val TSRMLS_CC)) {
+				php_error_docref(NULL TSRMLS_CC, E_WARNING,
+					"peer_fingerprint match failure"
+				);
+				return FAILURE;
+			}
+		} else {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING,
+				"Expected peer fingerprint must be a string or an array"
+			);
+			return FAILURE;
+		}
+	}
 
-			if (nr_bytes <= 0) {
-				retry = handle_ssl_error(stream, nr_bytes, 0 TSRMLS_CC);
-				stream->eof = (retry == 0 && errno != EAGAIN && !SSL_pending(sslsock->ssl_handle));
-				
+	/* verify the host name presented in the peer certificate */
+	if (must_verify_peer_name) {
+		GET_VER_OPT_STRING("peer_name", peer_name);
+
+		if (has_cnmatch_ctx_opt) {
+			GET_VER_OPT_STRING("CN_match", peer_name);
+			php_error(E_DEPRECATED,
+				"the 'CN_match' SSL context option is deprecated in favor of 'peer_name'"
+			);
+		}
+		/* If no peer name was specified we use the autodetected url name in client environments */
+		if (peer_name == NULL && sslsock->is_client) {
+			peer_name = sslsock->url_name;
+		}
+
+		if (peer_name) {
+			if (matches_san_list(peer, peer_name)) {
+				return SUCCESS;
+			} else if (matches_common_name(peer, peer_name TSRMLS_CC)) {
+				return SUCCESS;
 			} else {
-				/* we got the data */
-				break;
+				return FAILURE;
 			}
-		} while (retry);
+		} else {
+			return FAILURE;
+		}
+	}
 
-		if (nr_bytes > 0) {
-			php_stream_notify_progress_increment(stream->context, nr_bytes, 0);
+	return SUCCESS;
+}
+/* }}} */
+
+static int passwd_callback(char *buf, int num, int verify, void *data) /* {{{ */
+{
+	php_stream *stream = (php_stream *)data;
+	zval **val = NULL;
+	char *passphrase = NULL;
+	/* TODO: could expand this to make a callback into PHP user-space */
+
+	GET_VER_OPT_STRING("passphrase", passphrase);
+
+	if (passphrase) {
+		if (Z_STRLEN_PP(val) < num - 1) {
+			memcpy(buf, Z_STRVAL_PP(val), Z_STRLEN_PP(val)+1);
+			return Z_STRLEN_PP(val);
 		}
 	}
-	else
-	{
-		nr_bytes = php_stream_socket_ops.read(stream, buf, count TSRMLS_CC);
+	return 0;
+}
+/* }}} */
+
+#if defined(PHP_WIN32) && OPENSSL_VERSION_NUMBER >= 0x00907000L
+#define RETURN_CERT_VERIFY_FAILURE(code) X509_STORE_CTX_set_error(x509_store_ctx, code); return 0;
+static int win_cert_verify_callback(X509_STORE_CTX *x509_store_ctx, void *arg) /* {{{ */
+{
+	PCCERT_CONTEXT cert_ctx = NULL;
+	PCCERT_CHAIN_CONTEXT cert_chain_ctx = NULL;
+
+	php_stream *stream;
+	php_openssl_netstream_data_t *sslsock;
+	zval **val;
+	zend_bool is_self_signed = 0;
+
+	TSRMLS_FETCH();
+
+	stream = (php_stream*)arg;
+	sslsock = (php_openssl_netstream_data_t*)stream->abstract;
+
+	{ /* First convert the x509 struct back to a DER encoded buffer and let Windows decode it into a form it can work with */
+		unsigned char *der_buf = NULL;
+		int der_len;
+
+		der_len = i2d_X509(x509_store_ctx->cert, &der_buf);
+		if (der_len < 0) {
+			unsigned long err_code, e;
+			char err_buf[512];
+
+			while ((e = ERR_get_error()) != 0) {
+				err_code = e;
+			}
+
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error encoding X509 certificate: %d: %s", err_code, ERR_error_string(err_code, err_buf));
+			RETURN_CERT_VERIFY_FAILURE(SSL_R_CERTIFICATE_VERIFY_FAILED);
+		}
+
+		cert_ctx = CertCreateCertificateContext(X509_ASN_ENCODING, der_buf, der_len);
+		OPENSSL_free(der_buf);
+
+		if (cert_ctx == NULL) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error creating certificate context: %s", php_win_err());
+			RETURN_CERT_VERIFY_FAILURE(SSL_R_CERTIFICATE_VERIFY_FAILED);
+		}
 	}
 
-	if (nr_bytes < 0) {
-		nr_bytes = 0;
+	{ /* Next fetch the relevant cert chain from the store */
+		CERT_ENHKEY_USAGE enhkey_usage = {0};
+		CERT_USAGE_MATCH cert_usage = {0};
+		CERT_CHAIN_PARA chain_params = {sizeof(CERT_CHAIN_PARA)};
+		LPSTR usages[] = {szOID_PKIX_KP_SERVER_AUTH, szOID_SERVER_GATED_CRYPTO, szOID_SGC_NETSCAPE};
+		DWORD chain_flags = 0;
+		unsigned long allowed_depth = OPENSSL_DEFAULT_STREAM_VERIFY_DEPTH;
+		unsigned int i;
+
+		enhkey_usage.cUsageIdentifier = 3;
+		enhkey_usage.rgpszUsageIdentifier = usages;
+		cert_usage.dwType = USAGE_MATCH_TYPE_OR;
+		cert_usage.Usage = enhkey_usage;
+		chain_params.RequestedUsage = cert_usage;
+		chain_flags = CERT_CHAIN_CACHE_END_CERT | CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
+
+		if (!CertGetCertificateChain(NULL, cert_ctx, NULL, NULL, &chain_params, chain_flags, NULL, &cert_chain_ctx)) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error getting certificate chain: %s", php_win_err());
+			CertFreeCertificateContext(cert_ctx);
+			RETURN_CERT_VERIFY_FAILURE(SSL_R_CERTIFICATE_VERIFY_FAILED);
+		}
+
+		/* check if the cert is self-signed */
+		if (cert_chain_ctx->cChain > 0 && cert_chain_ctx->rgpChain[0]->cElement > 0
+			&& (cert_chain_ctx->rgpChain[0]->rgpElement[0]->TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED) != 0) {
+			is_self_signed = 1;
+		}
+
+		/* check the depth */
+		GET_VER_OPT_LONG("verify_depth", allowed_depth);
+
+		for (i = 0; i < cert_chain_ctx->cChain; i++) {
+			if (cert_chain_ctx->rgpChain[i]->cElement > allowed_depth) {
+				CertFreeCertificateChain(cert_chain_ctx);
+				CertFreeCertificateContext(cert_ctx);
+				RETURN_CERT_VERIFY_FAILURE(X509_V_ERR_CERT_CHAIN_TOO_LONG);
+			}
+		}
 	}
 
-	return nr_bytes;
+	{ /* Then verify it against a policy */
+		SSL_EXTRA_CERT_CHAIN_POLICY_PARA ssl_policy_params = {sizeof(SSL_EXTRA_CERT_CHAIN_POLICY_PARA)};
+		CERT_CHAIN_POLICY_PARA chain_policy_params = {sizeof(CERT_CHAIN_POLICY_PARA)};
+		CERT_CHAIN_POLICY_STATUS chain_policy_status = {sizeof(CERT_CHAIN_POLICY_STATUS)};
+		LPWSTR server_name = NULL;
+		BOOL verify_result;
+
+		{ /* This looks ridiculous and it is - but we validate the name ourselves using the peer_name
+		     ctx option, so just use the CN from the cert here */
+
+			X509_NAME *cert_name;
+			unsigned char *cert_name_utf8;
+			int index, cert_name_utf8_len;
+			DWORD num_wchars;
+
+			cert_name = X509_get_subject_name(x509_store_ctx->cert);
+			index = X509_NAME_get_index_by_NID(cert_name, NID_commonName, -1);
+			if (index < 0) {
+				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to locate certificate CN");
+				CertFreeCertificateChain(cert_chain_ctx);
+				CertFreeCertificateContext(cert_ctx);
+				RETURN_CERT_VERIFY_FAILURE(SSL_R_CERTIFICATE_VERIFY_FAILED);
+			}
+
+			cert_name_utf8_len = PHP_X509_NAME_ENTRY_TO_UTF8(cert_name, index, cert_name_utf8);
+
+			num_wchars = MultiByteToWideChar(CP_UTF8, 0, (char*)cert_name_utf8, -1, NULL, 0);
+			if (num_wchars == 0) {
+				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to convert %s to wide character string", cert_name_utf8);
+				OPENSSL_free(cert_name_utf8);
+				CertFreeCertificateChain(cert_chain_ctx);
+				CertFreeCertificateContext(cert_ctx);
+				RETURN_CERT_VERIFY_FAILURE(SSL_R_CERTIFICATE_VERIFY_FAILED);
+			}
+
+			server_name = emalloc((num_wchars * sizeof(WCHAR)) + sizeof(WCHAR));
+
+			num_wchars = MultiByteToWideChar(CP_UTF8, 0, (char*)cert_name_utf8, -1, server_name, num_wchars);
+			if (num_wchars == 0) {
+				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to convert %s to wide character string", cert_name_utf8);
+				efree(server_name);
+				OPENSSL_free(cert_name_utf8);
+				CertFreeCertificateChain(cert_chain_ctx);
+				CertFreeCertificateContext(cert_ctx);
+				RETURN_CERT_VERIFY_FAILURE(SSL_R_CERTIFICATE_VERIFY_FAILED);
+			}
+
+			OPENSSL_free(cert_name_utf8);
+		}
+
+		ssl_policy_params.dwAuthType = (sslsock->is_client) ? AUTHTYPE_SERVER : AUTHTYPE_CLIENT;
+		ssl_policy_params.pwszServerName = server_name;
+		chain_policy_params.pvExtraPolicyPara = &ssl_policy_params;
+
+		verify_result = CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_SSL, cert_chain_ctx, &chain_policy_params, &chain_policy_status);
+
+		efree(server_name);
+		CertFreeCertificateChain(cert_chain_ctx);
+		CertFreeCertificateContext(cert_ctx);
+
+		if (!verify_result) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Error verifying certificate chain policy: %s", php_win_err());
+			RETURN_CERT_VERIFY_FAILURE(SSL_R_CERTIFICATE_VERIFY_FAILED);
+		}
+
+		if (chain_policy_status.dwError != 0) {
+			/* The chain does not match the policy */
+			if (is_self_signed && chain_policy_status.dwError == CERT_E_UNTRUSTEDROOT
+				&& GET_VER_OPT("allow_self_signed") && zend_is_true(*val)) {
+				/* allow self-signed certs */
+				X509_STORE_CTX_set_error(x509_store_ctx, X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT);
+			} else {
+				RETURN_CERT_VERIFY_FAILURE(SSL_R_CERTIFICATE_VERIFY_FAILED);
+			}
+		}
+	}
+
+	return 1;
 }
+/* }}} */
+#endif
 
+static long load_stream_cafile(X509_STORE *cert_store, const char *cafile TSRMLS_DC) /* {{{ */
+{
+	php_stream *stream;
+	X509 *cert;
+	BIO *buffer;
+	int buffer_active = 0;
+	char *line = NULL;
+	size_t line_len;
+	long certs_added = 0;
+
+	stream = php_stream_open_wrapper(cafile, "rb", 0, NULL);
+
+	if (stream == NULL) {
+		php_error(E_WARNING, "failed loading cafile stream: `%s'", cafile);
+		return 0;
+	} else if (stream->wrapper->is_url) {
+		php_stream_close(stream);
+		php_error(E_WARNING, "remote cafile streams are disabled for security purposes");
+		return 0;
+	}
+
+	cert_start: {
+		line = php_stream_get_line(stream, NULL, 0, &line_len);
+		if (line == NULL) {
+			goto stream_complete;
+		} else if (!strcmp(line, "-----BEGIN CERTIFICATE-----\n") ||
+			!strcmp(line, "-----BEGIN CERTIFICATE-----\r\n")
+		) {
+			buffer = BIO_new(BIO_s_mem());
+			buffer_active = 1;
+			goto cert_line;
+		} else {
+			efree(line);
+			goto cert_start;
+		}
+	}
 
-static int php_openssl_sockop_close(php_stream *stream, int close_handle TSRMLS_DC)
+	cert_line: {
+		BIO_puts(buffer, line);
+		efree(line);
+		line = php_stream_get_line(stream, NULL, 0, &line_len);
+		if (line == NULL) {
+			goto stream_complete;
+		} else if (!strcmp(line, "-----END CERTIFICATE-----") ||
+			!strcmp(line, "-----END CERTIFICATE-----\n") ||
+			!strcmp(line, "-----END CERTIFICATE-----\r\n")
+		) {
+			goto add_cert;
+		} else {
+			goto cert_line;
+		}
+	}
+
+	add_cert: {
+		BIO_puts(buffer, line);
+		efree(line);
+		cert = PEM_read_bio_X509(buffer, NULL, 0, NULL);
+		BIO_free(buffer);
+		buffer_active = 0;
+		if (cert && X509_STORE_add_cert(cert_store, cert)) {
+			++certs_added;
+		}
+		goto cert_start;
+	}
+
+	stream_complete: {
+		php_stream_close(stream);
+		if (buffer_active == 1) {
+			BIO_free(buffer);
+		}
+	}
+
+	if (certs_added == 0) {
+		php_error(E_WARNING, "no valid certs found cafile stream: `%s'", cafile);
+	}
+
+	return certs_added;
+}
+/* }}} */
+
+static int enable_peer_verification(SSL_CTX *ctx, php_stream *stream TSRMLS_DC) /* {{{ */
 {
+	zval **val = NULL;
+	char *cafile = NULL;
+	char *capath = NULL;
 	php_openssl_netstream_data_t *sslsock = (php_openssl_netstream_data_t*)stream->abstract;
-#ifdef PHP_WIN32
-	int n;
-#endif
-	if (close_handle) {
-		if (sslsock->ssl_active) {
-			SSL_shutdown(sslsock->ssl_handle);
-			sslsock->ssl_active = 0;
+
+	GET_VER_OPT_STRING("cafile", cafile);
+	GET_VER_OPT_STRING("capath", capath);
+
+	if (cafile == NULL) {
+		cafile = zend_ini_string("openssl.cafile", sizeof("openssl.cafile"), 0);
+		cafile = strlen(cafile) ? cafile : NULL;
+	} else if (!sslsock->is_client) {
+		/* Servers need to load and assign CA names from the cafile */
+		STACK_OF(X509_NAME) *cert_names = SSL_load_client_CA_file(cafile);
+		if (cert_names != NULL) {
+			SSL_CTX_set_client_CA_list(ctx, cert_names);
+		} else {
+			php_error(E_WARNING, "SSL: failed loading CA names from cafile");
+			return FAILURE;
 		}
-		if (sslsock->ssl_handle) {
-			SSL_free(sslsock->ssl_handle);
-			sslsock->ssl_handle = NULL;
+	}
+
+	if (capath == NULL) {
+		capath = zend_ini_string("openssl.capath", sizeof("openssl.capath"), 0);
+		capath = strlen(capath) ? capath : NULL;
+	}
+
+	if (cafile || capath) {
+		if (!SSL_CTX_load_verify_locations(ctx, cafile, capath)) {
+			if (cafile && !load_stream_cafile(SSL_CTX_get_cert_store(ctx), cafile TSRMLS_CC)) {
+				return FAILURE;
+			}
 		}
-		if (sslsock->ctx) {
-			SSL_CTX_free(sslsock->ctx);
-			sslsock->ctx = NULL;
+	} else {
+#if defined(PHP_WIN32) && OPENSSL_VERSION_NUMBER >= 0x00907000L
+		SSL_CTX_set_cert_verify_callback(ctx, win_cert_verify_callback, (void *)stream);
+		SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, NULL);
+#else
+		if (sslsock->is_client && !SSL_CTX_set_default_verify_paths(ctx)) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING,
+				"Unable to set default verify locations and no CA settings specified");
+			return FAILURE;
 		}
-#ifdef PHP_WIN32
-		if (sslsock->s.socket == -1)
-			sslsock->s.socket = SOCK_ERR;
 #endif
-		if (sslsock->s.socket != SOCK_ERR) {
-#ifdef PHP_WIN32
-			/* prevent more data from coming in */
-			shutdown(sslsock->s.socket, SHUT_RD);
+	}
 
-			/* try to make sure that the OS sends all data before we close the connection.
-			 * Essentially, we are waiting for the socket to become writeable, which means
-			 * that all pending data has been sent.
-			 * We use a small timeout which should encourage the OS to send the data,
-			 * but at the same time avoid hanging indefintely.
-			 * */
+	SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, verify_callback);
+
+	return SUCCESS;
+}
+/* }}} */
+
+static void disable_peer_verification(SSL_CTX *ctx, php_stream *stream TSRMLS_DC) /* {{{ */
+{
+	SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);
+}
+/* }}} */
+
+static int set_local_cert(SSL_CTX *ctx, php_stream *stream TSRMLS_DC) /* {{{ */
+{
+	zval **val = NULL;
+	char *certfile = NULL;
+
+	GET_VER_OPT_STRING("local_cert", certfile);
+
+	if (certfile) {
+		char resolved_path_buff[MAXPATHLEN];
+		const char * private_key = NULL;
+
+		if (VCWD_REALPATH(certfile, resolved_path_buff)) {
+			/* a certificate to use for authentication */
+			if (SSL_CTX_use_certificate_chain_file(ctx, resolved_path_buff) != 1) {
+				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to set local cert chain file `%s'; Check that your cafile/capath settings include details of your certificate and its issuer", certfile);
+				return FAILURE;
+			}
+			GET_VER_OPT_STRING("local_pk", private_key);
+
+			if (private_key) {
+				char resolved_path_buff_pk[MAXPATHLEN];
+				if (VCWD_REALPATH(private_key, resolved_path_buff_pk)) {
+					if (SSL_CTX_use_PrivateKey_file(ctx, resolved_path_buff_pk, SSL_FILETYPE_PEM) != 1) {
+						php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to set private key file `%s'", resolved_path_buff_pk);
+						return FAILURE;
+					}
+				}
+			} else {
+				if (SSL_CTX_use_PrivateKey_file(ctx, resolved_path_buff, SSL_FILETYPE_PEM) != 1) {
+					php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to set private key file `%s'", resolved_path_buff);
+					return FAILURE;
+				}		
+			}
+
+#if OPENSSL_VERSION_NUMBER < 0x10001001L
 			do {
-				n = php_pollfd_for_ms(sslsock->s.socket, POLLOUT, 500);
-			} while (n == -1 && php_socket_errno() == EINTR);
+				/* Unnecessary as of OpenSSLv1.0.1 (will segfault if used with >= 10001001 ) */
+				X509 *cert = NULL;
+				EVP_PKEY *key = NULL;
+				SSL *tmpssl = SSL_new(ctx);
+				cert = SSL_get_certificate(tmpssl);
+
+				if (cert) {
+					key = X509_get_pubkey(cert);
+					EVP_PKEY_copy_parameters(key, SSL_get_privatekey(tmpssl));
+					EVP_PKEY_free(key);
+				}
+				SSL_free(tmpssl);
+			} while (0);
 #endif
-			closesocket(sslsock->s.socket);
-			sslsock->s.socket = SOCK_ERR;
+			if (!SSL_CTX_check_private_key(ctx)) {
+				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Private key does not match certificate!");
+			}
 		}
 	}
 
-	if (sslsock->sni) {
-		pefree(sslsock->sni, php_stream_is_persistent(stream));
+	return SUCCESS;
+}
+/* }}} */
+
+static const SSL_METHOD *php_select_crypto_method(long method_value, int is_client TSRMLS_DC) /* {{{ */
+{
+	if (method_value == STREAM_CRYPTO_METHOD_SSLv2) {
+#if !defined(OPENSSL_NO_SSL2) && OPENSSL_VERSION_NUMBER < 0x10100000L
+		return is_client ? SSLv2_client_method() : SSLv2_server_method();
+#else
+		php_error_docref(NULL TSRMLS_CC, E_WARNING,
+				"SSLv2 support is not compiled into the OpenSSL library PHP is linked against");
+		return NULL;
+#endif
+	} else if (method_value == STREAM_CRYPTO_METHOD_SSLv3) {
+#ifndef OPENSSL_NO_SSL3
+		return is_client ? SSLv3_client_method() : SSLv3_server_method();
+#else
+		php_error_docref(NULL TSRMLS_CC, E_WARNING,
+				"SSLv3 support is not compiled into the OpenSSL library PHP is linked against");
+		return NULL;
+#endif
+	} else if (method_value == STREAM_CRYPTO_METHOD_TLSv1_0) {
+		return is_client ? TLSv1_client_method() : TLSv1_server_method();
+	} else if (method_value == STREAM_CRYPTO_METHOD_TLSv1_1) {
+#if OPENSSL_VERSION_NUMBER >= 0x10001001L
+		return is_client ? TLSv1_1_client_method() : TLSv1_1_server_method();
+#else
+		php_error_docref(NULL TSRMLS_CC, E_WARNING,
+				"TLSv1.1 support is not compiled into the OpenSSL library PHP is linked against");
+		return NULL;
+#endif
+	} else if (method_value == STREAM_CRYPTO_METHOD_TLSv1_2) {
+#if OPENSSL_VERSION_NUMBER >= 0x10001001L
+		return is_client ? TLSv1_2_client_method() : TLSv1_2_server_method();
+#else
+		php_error_docref(NULL TSRMLS_CC, E_WARNING,
+				"TLSv1.2 support is not compiled into the OpenSSL library PHP is linked against");
+		return NULL;
+#endif
+	} else {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING,
+				"Invalid crypto method");
+		return NULL;
 	}
-	pefree(sslsock, php_stream_is_persistent(stream));
-	
-	return 0;
 }
+/* }}} */
 
-static int php_openssl_sockop_flush(php_stream *stream TSRMLS_DC)
+static long php_get_crypto_method_ctx_flags(long method_flags TSRMLS_DC) /* {{{ */
 {
-	return php_stream_socket_ops.flush(stream TSRMLS_CC);
+	long ssl_ctx_options = SSL_OP_ALL;
+
+#ifndef OPENSSL_NO_SSL2
+	if (!(method_flags & STREAM_CRYPTO_METHOD_SSLv2)) {
+		ssl_ctx_options |= SSL_OP_NO_SSLv2;
+	}
+#endif
+#ifndef OPENSSL_NO_SSL3
+	if (!(method_flags & STREAM_CRYPTO_METHOD_SSLv3)) {
+		ssl_ctx_options |= SSL_OP_NO_SSLv3;
+	}
+#endif
+#ifndef OPENSSL_NO_TLS1
+	if (!(method_flags & STREAM_CRYPTO_METHOD_TLSv1_0)) {
+		ssl_ctx_options |= SSL_OP_NO_TLSv1;
+	}
+#endif
+#if OPENSSL_VERSION_NUMBER >= 0x10001001L
+	if (!(method_flags & STREAM_CRYPTO_METHOD_TLSv1_1)) {
+		ssl_ctx_options |= SSL_OP_NO_TLSv1_1;
+	}
+
+	if (!(method_flags & STREAM_CRYPTO_METHOD_TLSv1_2)) {
+		ssl_ctx_options |= SSL_OP_NO_TLSv1_2;
+	}
+#endif
+
+	return ssl_ctx_options;
 }
+/* }}} */
 
-static int php_openssl_sockop_stat(php_stream *stream, php_stream_statbuf *ssb TSRMLS_DC)
+static void limit_handshake_reneg(const SSL *ssl) /* {{{ */
 {
-	return php_stream_socket_ops.stat(stream, ssb TSRMLS_CC);
+	php_stream *stream;
+	php_openssl_netstream_data_t *sslsock;
+	struct timeval now;
+	long elapsed_time;
+
+	stream = php_openssl_get_stream_from_ssl_handle(ssl);
+	sslsock = (php_openssl_netstream_data_t*)stream->abstract;
+	gettimeofday(&now, NULL);
+
+	/* The initial handshake is never rate-limited */
+	if (sslsock->reneg->prev_handshake == 0) {
+		sslsock->reneg->prev_handshake = now.tv_sec;
+		return;
+	}
+
+	elapsed_time = (now.tv_sec - sslsock->reneg->prev_handshake);
+	sslsock->reneg->prev_handshake = now.tv_sec;
+	sslsock->reneg->tokens -= (elapsed_time * (sslsock->reneg->limit / sslsock->reneg->window));
+
+	if (sslsock->reneg->tokens < 0) {
+		sslsock->reneg->tokens = 0;
+	}
+	++sslsock->reneg->tokens;
+
+	/* The token level exceeds our allowed limit */
+	if (sslsock->reneg->tokens > sslsock->reneg->limit) {
+		zval **val;
+
+		TSRMLS_FETCH();
+
+		sslsock->reneg->should_close = 1;
+
+		if (stream->context && SUCCESS == php_stream_context_get_option(stream->context,
+				"ssl", "reneg_limit_callback", &val)
+		) {
+			zval *param, **params[1], *retval;
+
+			MAKE_STD_ZVAL(param);
+			php_stream_to_zval(stream, param);
+			params[0] = &param;
+
+			/* Closing the stream inside this callback would segfault! */
+			stream->flags |= PHP_STREAM_FLAG_NO_FCLOSE;
+			if (FAILURE == call_user_function_ex(EG(function_table), NULL, *val, &retval, 1, params, 0, NULL TSRMLS_CC)) {
+				php_error(E_WARNING, "SSL: failed invoking reneg limit notification callback");
+			}
+			stream->flags ^= PHP_STREAM_FLAG_NO_FCLOSE;
+
+			/* If the reneg_limit_callback returned true don't auto-close */
+			if (retval != NULL && Z_TYPE_P(retval) == IS_BOOL && Z_BVAL_P(retval) == 1) {
+				sslsock->reneg->should_close = 0;
+			}
+
+			FREE_ZVAL(param);
+			if (retval != NULL) {
+				zval_ptr_dtor(&retval);
+			}
+		} else {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING,
+				"SSL: client-initiated handshake rate limit exceeded by peer");
+		}
+	}
+}
+/* }}} */
+
+static void info_callback(const SSL *ssl, int where, int ret) /* {{{ */
+{
+	/* Rate-limit client-initiated handshake renegotiation to prevent DoS */
+	if (where & SSL_CB_HANDSHAKE_START) {
+		limit_handshake_reneg(ssl);
+	}
+}
+/* }}} */
+
+static void init_server_reneg_limit(php_stream *stream, php_openssl_netstream_data_t *sslsock) /* {{{ */
+{
+	zval **val;
+	long limit = OPENSSL_DEFAULT_RENEG_LIMIT;
+	long window = OPENSSL_DEFAULT_RENEG_WINDOW;
+
+	if (stream->context &&
+		SUCCESS == php_stream_context_get_option(stream->context,
+				"ssl", "reneg_limit", &val)
+	) {
+		convert_to_long(*val);
+		limit = Z_LVAL_PP(val);
+	}
+
+	/* No renegotiation rate-limiting */
+	if (limit < 0) {
+		return;
+	}
+
+	if (stream->context &&
+		SUCCESS == php_stream_context_get_option(stream->context,
+				"ssl", "reneg_window", &val)
+	) {
+		convert_to_long(*val);
+		window = Z_LVAL_PP(val);
+	}
+
+	sslsock->reneg = (void*)pemalloc(sizeof(php_openssl_handshake_bucket_t),
+		php_stream_is_persistent(stream)
+	);
+
+	sslsock->reneg->limit = limit;
+	sslsock->reneg->window = window;
+	sslsock->reneg->prev_handshake = 0;
+	sslsock->reneg->tokens = 0;
+	sslsock->reneg->should_close = 0;
+
+	SSL_set_info_callback(sslsock->ssl_handle, info_callback);
+}
+/* }}} */
+
+static int set_server_rsa_key(php_stream *stream, SSL_CTX *ctx TSRMLS_DC) /* {{{ */
+{
+	zval ** val;
+	int rsa_key_size;
+	RSA* rsa;
+
+	if (php_stream_context_get_option(stream->context, "ssl", "rsa_key_size", &val) == SUCCESS) {
+		rsa_key_size = (int) Z_LVAL_PP(val);
+		if ((rsa_key_size != 1) && (rsa_key_size & (rsa_key_size - 1))) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "RSA key size requires a power of 2: %d", rsa_key_size);
+			rsa_key_size = 2048;
+		}
+	} else {
+		rsa_key_size = 2048;
+	}
+
+	rsa = RSA_generate_key(rsa_key_size, RSA_F4, NULL, NULL);
+
+	if (!SSL_CTX_set_tmp_rsa(ctx, rsa)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Failed setting RSA key");
+		RSA_free(rsa);
+		return FAILURE;
+	}
+
+	RSA_free(rsa);
+
+	return SUCCESS;
+}
+/* }}} */
+
+static int set_server_dh_param(SSL_CTX *ctx, char *dh_path TSRMLS_DC) /* {{{ */
+{
+	DH *dh;
+	BIO* bio;
+
+	bio = BIO_new_file(dh_path, "r");
+
+	if (bio == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid dh_param file: %s", dh_path);
+		return FAILURE;
+	}
+
+	dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);
+	BIO_free(bio);
+
+	if (dh == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Failed reading DH params from file: %s", dh_path);
+		return FAILURE;
+	}
+
+	if (SSL_CTX_set_tmp_dh(ctx, dh) < 0) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "DH param assignment failed");
+		DH_free(dh);
+		return FAILURE;
+	}
+
+	DH_free(dh);
+
+	return SUCCESS;
+}
+/* }}} */
+
+#ifdef HAVE_ECDH
+static int set_server_ecdh_curve(php_stream *stream, SSL_CTX *ctx TSRMLS_DC) /* {{{ */
+{
+	zval **val;
+	int curve_nid;
+	char *curve_str;
+	EC_KEY *ecdh;
+
+	if (php_stream_context_get_option(stream->context, "ssl", "ecdh_curve", &val) == SUCCESS) {
+		convert_to_string_ex(val);
+		curve_str = Z_STRVAL_PP(val);
+		curve_nid = OBJ_sn2nid(curve_str);
+		if (curve_nid == NID_undef) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Invalid ECDH curve: %s", curve_str);
+			return FAILURE;
+		}
+	} else {
+		curve_nid = NID_X9_62_prime256v1;
+	}
+
+	ecdh = EC_KEY_new_by_curve_name(curve_nid);
+	if (ecdh == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING,
+			"Failed generating ECDH curve");
+
+		return FAILURE;
+	}
+
+	SSL_CTX_set_tmp_ecdh(ctx, ecdh);
+	EC_KEY_free(ecdh);
+
+	return SUCCESS;
+}
+/* }}} */
+#endif
+
+static int set_server_specific_opts(php_stream *stream, SSL_CTX *ctx TSRMLS_DC) /* {{{ */
+{
+	zval **val;
+	long ssl_ctx_options = SSL_CTX_get_options(ctx);
+
+#ifdef HAVE_ECDH
+	if (FAILURE == set_server_ecdh_curve(stream, ctx TSRMLS_CC)) {
+		return FAILURE;
+	}
+#else
+	if (SUCCESS == php_stream_context_get_option(stream->context, "ssl", "ecdh_curve", &val)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING,
+			"ECDH curve support not compiled into the OpenSSL lib against which PHP is linked");
+
+		return FAILURE;
+	}
+#endif
+
+	if (php_stream_context_get_option(stream->context, "ssl", "dh_param", &val) == SUCCESS) {
+		convert_to_string_ex(val);
+		if (FAILURE == set_server_dh_param(ctx,  Z_STRVAL_PP(val) TSRMLS_CC)) {
+			return FAILURE;
+		}
+	}
+
+	if (FAILURE == set_server_rsa_key(stream, ctx TSRMLS_CC)) {
+		return FAILURE;
+	}
+
+	if (SUCCESS == php_stream_context_get_option(
+				stream->context, "ssl", "honor_cipher_order", &val) &&
+			zend_is_true(*val)
+	) {
+		ssl_ctx_options |= SSL_OP_CIPHER_SERVER_PREFERENCE;
+	}
+
+	if (SUCCESS == php_stream_context_get_option(
+				stream->context, "ssl", "single_dh_use", &val) &&
+			zend_is_true(*val)
+	) {
+		ssl_ctx_options |= SSL_OP_SINGLE_DH_USE;
+	}
+
+#ifdef HAVE_ECDH
+	if (SUCCESS == php_stream_context_get_option(
+				stream->context, "ssl", "single_ecdh_use", &val) &&
+			zend_is_true(*val)
+	) {
+		ssl_ctx_options |= SSL_OP_SINGLE_ECDH_USE;
+	}
+#endif
+
+	SSL_CTX_set_options(ctx, ssl_ctx_options);
+
+	return SUCCESS;
 }
+/* }}} */
+
+#ifdef HAVE_SNI
+static int server_sni_callback(SSL *ssl_handle, int *al, void *arg) /* {{{ */
+{
+	php_stream *stream;
+	php_openssl_netstream_data_t *sslsock;
+	unsigned i;
+	const char *server_name;
+
+	server_name = SSL_get_servername(ssl_handle, TLSEXT_NAMETYPE_host_name);
 
+	if (!server_name) {
+		return SSL_TLSEXT_ERR_NOACK;
+	}
 
-static inline int php_openssl_setup_crypto(php_stream *stream,
+	stream = (php_stream*)SSL_get_ex_data(ssl_handle, php_openssl_get_ssl_stream_data_index());
+	sslsock = (php_openssl_netstream_data_t*)stream->abstract;
+
+	if (!(sslsock->sni_cert_count && sslsock->sni_certs)) {
+		return SSL_TLSEXT_ERR_NOACK;
+	}
+
+	for (i=0; i < sslsock->sni_cert_count; i++) {
+		if (matches_wildcard_name(server_name, sslsock->sni_certs[i].name)) {
+			SSL_set_SSL_CTX(ssl_handle, sslsock->sni_certs[i].ctx);
+			return SSL_TLSEXT_ERR_OK;
+		}
+	}
+
+	return SSL_TLSEXT_ERR_NOACK;
+}
+/* }}} */
+
+static int enable_server_sni(php_stream *stream, php_openssl_netstream_data_t *sslsock TSRMLS_DC)
+{
+	zval **val;
+	zval **current;
+	char *key;
+	uint key_len;
+	ulong key_index;
+	int key_type;
+	HashPosition pos;
+	int i = 0;
+	char resolved_path_buff[MAXPATHLEN];
+	SSL_CTX *ctx;
+
+	/* If the stream ctx disables SNI we're finished here */
+	if (GET_VER_OPT("SNI_enabled") && !zend_is_true(*val)) {
+		return SUCCESS;
+	}
+
+	/* If no SNI cert array is specified we're finished here */
+	if (!GET_VER_OPT("SNI_server_certs")) {
+		return SUCCESS;
+	}
+
+	if (Z_TYPE_PP(val) != IS_ARRAY) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING,
+			"SNI_server_certs requires an array mapping host names to cert paths"
+		);
+		return FAILURE;
+	}
+
+	sslsock->sni_cert_count = zend_hash_num_elements(Z_ARRVAL_PP(val));
+	if (sslsock->sni_cert_count == 0) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING,
+			"SNI_server_certs host cert array must not be empty"
+		);
+		return FAILURE;
+	}
+
+	sslsock->sni_certs = (php_openssl_sni_cert_t*)safe_pemalloc(sslsock->sni_cert_count,
+		sizeof(php_openssl_sni_cert_t), 0, php_stream_is_persistent(stream)
+	);
+	memset(sslsock->sni_certs, 0, sslsock->sni_cert_count * sizeof(php_openssl_sni_cert_t));
+
+	for (zend_hash_internal_pointer_reset_ex(Z_ARRVAL_PP(val), &pos);
+		zend_hash_get_current_data_ex(Z_ARRVAL_PP(val), (void **)&current, &pos) == SUCCESS;
+		zend_hash_move_forward_ex(Z_ARRVAL_PP(val), &pos)
+	) {
+		key_type = zend_hash_get_current_key_ex(Z_ARRVAL_PP(val), &key, &key_len, &key_index, 0, &pos);
+		if (key_type != HASH_KEY_IS_STRING) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING,
+				"SNI_server_certs array requires string host name keys"
+			);
+			return FAILURE;
+		}
+
+		if (VCWD_REALPATH(Z_STRVAL_PP(current), resolved_path_buff)) {
+			/* The hello method is not inherited by SSL structs when assigning a new context
+			 * inside the SNI callback, so the just use SSLv23 */
+			ctx = SSL_CTX_new(SSLv23_server_method());
+
+			if (SSL_CTX_use_certificate_chain_file(ctx, resolved_path_buff) != 1) {
+				php_error_docref(NULL TSRMLS_CC, E_WARNING,
+					"failed setting local cert chain file `%s'; " \
+					"check that your cafile/capath settings include " \
+					"details of your certificate and its issuer",
+					resolved_path_buff
+				);
+				SSL_CTX_free(ctx);
+				return FAILURE;
+			} else if (SSL_CTX_use_PrivateKey_file(ctx, resolved_path_buff, SSL_FILETYPE_PEM) != 1) {
+				php_error_docref(NULL TSRMLS_CC, E_WARNING,
+					"failed setting private key from file `%s'",
+					resolved_path_buff
+				);
+				SSL_CTX_free(ctx);
+				return FAILURE;
+			} else {
+				sslsock->sni_certs[i].name = pestrdup(key, php_stream_is_persistent(stream));
+				sslsock->sni_certs[i].ctx = ctx;
+				++i;
+			}
+		} else {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING,
+				"failed setting local cert chain file `%s'; file not found",
+				Z_STRVAL_PP(current)
+			);
+			return FAILURE;
+		}
+	}
+
+	SSL_CTX_set_tlsext_servername_callback(sslsock->ctx, server_sni_callback);
+
+	return SUCCESS;
+}
+
+static void enable_client_sni(php_stream *stream, php_openssl_netstream_data_t *sslsock) /* {{{ */
+{
+	zval **val;
+	char *sni_server_name;
+
+	/* If SNI is explicitly disabled we're finished here */
+	if (GET_VER_OPT("SNI_enabled") && !zend_is_true(*val)) {
+		return;
+	}
+
+	sni_server_name = sslsock->url_name;
+
+	GET_VER_OPT_STRING("peer_name", sni_server_name);
+
+	if (GET_VER_OPT("SNI_server_name")) {
+		GET_VER_OPT_STRING("SNI_server_name", sni_server_name);
+		php_error(E_DEPRECATED, "SNI_server_name is deprecated in favor of peer_name");
+	}
+
+	if (sni_server_name) {
+		SSL_set_tlsext_host_name(sslsock->ssl_handle, sni_server_name);
+	}
+}
+/* }}} */
+#endif
+
+int php_openssl_setup_crypto(php_stream *stream,
 		php_openssl_netstream_data_t *sslsock,
 		php_stream_xport_crypto_param *cparam
-		TSRMLS_DC)
+		TSRMLS_DC) /* {{{ */
 {
-	SSL_METHOD *method;
-	
+	const SSL_METHOD *method;
+	long ssl_ctx_options;
+	long method_flags;
+	char *cipherlist = NULL;
+	zval **val;
+
 	if (sslsock->ssl_handle) {
 		if (sslsock->s.is_blocked) {
 			php_error_docref(NULL TSRMLS_CC, E_WARNING, "SSL/TLS already set-up for this stream");
-			return -1;
+			return FAILURE;
 		} else {
-			return 0;
+			return SUCCESS;
 		}
 	}
 
-	/* need to do slightly different things, based on client/server method,
+	ERR_clear_error();
+
+	/* We need to do slightly different things based on client/server method
 	 * so lets remember which method was selected */
+	sslsock->is_client = cparam->inputs.method & STREAM_CRYPTO_IS_CLIENT;
+	method_flags = ((cparam->inputs.method >> 1) << 1);
 
-	switch (cparam->inputs.method) {
-		case STREAM_CRYPTO_METHOD_SSLv23_CLIENT:
-			sslsock->is_client = 1;
-			method = SSLv23_client_method();
-			break;
-		case STREAM_CRYPTO_METHOD_SSLv2_CLIENT:
-#ifdef OPENSSL_NO_SSL2
-			php_error_docref(NULL TSRMLS_CC, E_WARNING, "SSLv2 support is not compiled into the OpenSSL library PHP is linked against");
-			return -1;
-#else
-			sslsock->is_client = 1;
-			method = SSLv2_client_method();
-			break;
-#endif
-		case STREAM_CRYPTO_METHOD_SSLv3_CLIENT:
-			sslsock->is_client = 1;
-			method = SSLv3_client_method();
-			break;
-		case STREAM_CRYPTO_METHOD_TLS_CLIENT:
-			sslsock->is_client = 1;
-			method = TLSv1_client_method();
-			break;
-		case STREAM_CRYPTO_METHOD_SSLv23_SERVER:
-			sslsock->is_client = 0;
-			method = SSLv23_server_method();
-			break;
-		case STREAM_CRYPTO_METHOD_SSLv3_SERVER:
-			sslsock->is_client = 0;
-			method = SSLv3_server_method();
-			break;
-		case STREAM_CRYPTO_METHOD_SSLv2_SERVER:
-#ifdef OPENSSL_NO_SSL2
-			php_error_docref(NULL TSRMLS_CC, E_WARNING, "SSLv2 support is not compiled into the OpenSSL library PHP is linked against");
-			return -1;
+	/* Should we use a specific crypto method or is generic SSLv23 okay? */
+	if ((method_flags & (method_flags-1)) == 0) {
+		ssl_ctx_options = SSL_OP_ALL;
+		method = php_select_crypto_method(method_flags, sslsock->is_client TSRMLS_CC);
+		if (method == NULL) {
+			return FAILURE;
+		}
+	} else {
+		method = sslsock->is_client ? SSLv23_client_method() : SSLv23_server_method();
+		ssl_ctx_options = php_get_crypto_method_ctx_flags(method_flags TSRMLS_CC);
+		if (ssl_ctx_options == -1) {
+			return FAILURE;
+		}
+	}
+
+#if OPENSSL_VERSION_NUMBER >= 0x10001001L
+	sslsock->ctx = SSL_CTX_new(method);
 #else
-			sslsock->is_client = 0;
-			method = SSLv2_server_method();
-			break;
+	/* Avoid const warning with old versions */
+	sslsock->ctx = SSL_CTX_new((SSL_METHOD*)method);
 #endif
-		case STREAM_CRYPTO_METHOD_TLS_SERVER:
-			sslsock->is_client = 0;
-			method = TLSv1_server_method();
-			break;
-		default:
-			return -1;
 
+	if (sslsock->ctx == NULL) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "SSL context creation failure");
+		return FAILURE;
 	}
 
-	sslsock->ctx = SSL_CTX_new(method);
-	if (sslsock->ctx == NULL) {
-		php_error_docref(NULL TSRMLS_CC, E_WARNING, "failed to create an SSL context");
-		return -1;
+#if OPENSSL_VERSION_NUMBER >= 0x0090806fL
+	if (GET_VER_OPT("no_ticket") && zend_is_true(*val)) {
+		ssl_ctx_options |= SSL_OP_NO_TICKET;
 	}
+#endif
 
-	SSL_CTX_set_options(sslsock->ctx, SSL_OP_ALL);
+#if OPENSSL_VERSION_NUMBER >= 0x0090605fL
+	ssl_ctx_options &= ~SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;
+#endif
 
-#if OPENSSL_VERSION_NUMBER >= 0x0090806fL
-	{
-		zval **val;
+#if OPENSSL_VERSION_NUMBER >= 0x10000000L
+	if (!GET_VER_OPT("disable_compression") || zend_is_true(*val)) {
+		ssl_ctx_options |= SSL_OP_NO_COMPRESSION;
+	}
+#endif
 
-		if (stream->context && SUCCESS == php_stream_context_get_option(
-					stream->context, "ssl", "no_ticket", &val) && 
-				zval_is_true(*val)) {
-			SSL_CTX_set_options(sslsock->ctx, SSL_OP_NO_TICKET);
-		}
+	if (GET_VER_OPT("verify_peer") && !zend_is_true(*val)) {
+		disable_peer_verification(sslsock->ctx, stream TSRMLS_CC);
+	} else if (FAILURE == enable_peer_verification(sslsock->ctx, stream TSRMLS_CC)) {
+		return FAILURE;
+	}
+
+	/* callback for the passphrase (for localcert) */
+	if (GET_VER_OPT("passphrase")) {
+		SSL_CTX_set_default_passwd_cb_userdata(sslsock->ctx, stream);
+		SSL_CTX_set_default_passwd_cb(sslsock->ctx, passwd_callback);
+	}
+
+	GET_VER_OPT_STRING("ciphers", cipherlist);
+#ifndef USE_OPENSSL_SYSTEM_CIPHERS
+	if (!cipherlist) {
+		cipherlist = OPENSSL_DEFAULT_STREAM_CIPHERS;
 	}
 #endif
+	if (cipherlist) {
+		if (SSL_CTX_set_cipher_list(sslsock->ctx, cipherlist) != 1) {
+			return FAILURE;
+		}
+	}
+	if (FAILURE == set_local_cert(sslsock->ctx, stream TSRMLS_CC)) {
+		return FAILURE;
+	}
 
-	sslsock->ssl_handle = php_SSL_new_from_context(sslsock->ctx, stream TSRMLS_CC);
+	SSL_CTX_set_options(sslsock->ctx, ssl_ctx_options);
+
+	if (sslsock->is_client == 0 &&
+		stream->context &&
+		FAILURE == set_server_specific_opts(stream, sslsock->ctx TSRMLS_CC)
+	) {
+		return FAILURE;
+	}
+
+	sslsock->ssl_handle = SSL_new(sslsock->ctx);
 	if (sslsock->ssl_handle == NULL) {
-		php_error_docref(NULL TSRMLS_CC, E_WARNING, "failed to create an SSL handle");
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "SSL handle creation failure");
 		SSL_CTX_free(sslsock->ctx);
 		sslsock->ctx = NULL;
-		return -1;
+		return FAILURE;
+	} else {
+		SSL_set_ex_data(sslsock->ssl_handle, php_openssl_get_ssl_stream_data_index(), stream);
 	}
 
 	if (!SSL_set_fd(sslsock->ssl_handle, sslsock->s.socket)) {
 		handle_ssl_error(stream, 0, 1 TSRMLS_CC);
 	}
 
+#ifdef HAVE_SNI
+	/* Enable server-side SNI */
+	if (sslsock->is_client == 0 && enable_server_sni(stream, sslsock TSRMLS_CC) == FAILURE) {
+		return FAILURE;
+	}
+#endif
+
+	/* Enable server-side handshake renegotiation rate-limiting */
+	if (sslsock->is_client == 0) {
+		init_server_reneg_limit(stream, sslsock);
+	}
+
+#ifdef SSL_MODE_RELEASE_BUFFERS
+	do {
+		long mode = SSL_get_mode(sslsock->ssl_handle);
+		SSL_set_mode(sslsock->ssl_handle, mode | SSL_MODE_RELEASE_BUFFERS);
+	} while (0);
+#endif
+
 	if (cparam->inputs.session) {
 		if (cparam->inputs.session->ops != &php_openssl_socket_ops) {
 			php_error_docref(NULL TSRMLS_CC, E_WARNING, "supplied session stream must be an SSL enabled stream");
- 		} else if (((php_openssl_netstream_data_t*)cparam->inputs.session->abstract)->ssl_handle == NULL) {
- 			php_error_docref(NULL TSRMLS_CC, E_WARNING, "supplied SSL session stream is not initialized");
+		} else if (((php_openssl_netstream_data_t*)cparam->inputs.session->abstract)->ssl_handle == NULL) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "supplied SSL session stream is not initialized");
 		} else {
 			SSL_copy_session_id(sslsock->ssl_handle, ((php_openssl_netstream_data_t*)cparam->inputs.session->abstract)->ssl_handle);
 		}
 	}
-	return 0;
+
+	return SUCCESS;
+}
+/* }}} */
+
+#define PHP_SSL_MAX_VERSION_LEN 32
+
+static char *php_ssl_cipher_get_version(const SSL_CIPHER *c, char *buffer, size_t max_len) /* {{{ */
+{
+	const char *version = SSL_CIPHER_get_version(c);
+	strncpy(buffer, version, max_len);
+	if (max_len <= strlen(version)) {
+		buffer[max_len - 1] = 0;
+	}
+	return buffer;
+}
+/* }}} */
+
+static zval *capture_session_meta(SSL *ssl_handle) /* {{{ */
+{
+	zval *meta_arr;
+	char *proto_str;
+	long proto = SSL_version(ssl_handle);
+	const SSL_CIPHER *cipher = SSL_get_current_cipher(ssl_handle);
+	char version_str[PHP_SSL_MAX_VERSION_LEN];
+
+	switch (proto) {
+#if OPENSSL_VERSION_NUMBER >= 0x10001001L
+		case TLS1_2_VERSION: proto_str = "TLSv1.2"; break;
+		case TLS1_1_VERSION: proto_str = "TLSv1.1"; break;
+#endif
+		case TLS1_VERSION: proto_str = "TLSv1"; break;
+		case SSL3_VERSION: proto_str = "SSLv3"; break;
+		case SSL2_VERSION: proto_str = "SSLv2"; break;
+		default: proto_str = "UNKNOWN";
+	}
+
+	MAKE_STD_ZVAL(meta_arr);
+	array_init(meta_arr);
+	add_assoc_string(meta_arr, "protocol", proto_str, 1);
+	add_assoc_string(meta_arr, "cipher_name", (char *) SSL_CIPHER_get_name(cipher), 1);
+	add_assoc_long(meta_arr, "cipher_bits", SSL_CIPHER_get_bits(cipher, NULL));
+	add_assoc_string(meta_arr, "cipher_version", php_ssl_cipher_get_version(cipher, version_str, PHP_SSL_MAX_VERSION_LEN), 1);
+
+	return meta_arr;
+}
+/* }}} */
+
+static int capture_peer_certs(php_stream *stream, php_openssl_netstream_data_t *sslsock, X509 *peer_cert TSRMLS_DC) /* {{{ */
+{
+	zval **val, *zcert;
+	int cert_captured = 0;
+
+	if (SUCCESS == php_stream_context_get_option(stream->context,
+			"ssl", "capture_peer_cert", &val) &&
+		zend_is_true(*val)
+	) {
+		MAKE_STD_ZVAL(zcert);
+		ZVAL_RESOURCE(zcert, zend_list_insert(peer_cert, php_openssl_get_x509_list_id() TSRMLS_CC));
+		php_stream_context_set_option(stream->context, "ssl", "peer_certificate", zcert);
+		cert_captured = 1;
+		FREE_ZVAL(zcert);
+	}
+
+	if (SUCCESS == php_stream_context_get_option(stream->context,
+			"ssl", "capture_peer_cert_chain", &val) &&
+		zend_is_true(*val)
+	) {
+		zval *arr;
+		STACK_OF(X509) *chain;
+
+		MAKE_STD_ZVAL(arr);
+		chain = SSL_get_peer_cert_chain(sslsock->ssl_handle);
+
+		if (chain && sk_X509_num(chain) > 0) {
+			int i;
+			array_init(arr);
+
+			for (i = 0; i < sk_X509_num(chain); i++) {
+				X509 *mycert = X509_dup(sk_X509_value(chain, i));
+				MAKE_STD_ZVAL(zcert);
+				ZVAL_RESOURCE(zcert, zend_list_insert(mycert, php_openssl_get_x509_list_id() TSRMLS_CC));
+				add_next_index_zval(arr, zcert);
+			}
+
+		} else {
+			ZVAL_NULL(arr);
+		}
+
+		php_stream_context_set_option(stream->context, "ssl", "peer_certificate_chain", arr);
+		zval_dtor(arr);
+		efree(arr);
+	}
+
+	return cert_captured;
 }
+/* }}} */
 
-static inline int php_openssl_enable_crypto(php_stream *stream,
+static int php_openssl_enable_crypto(php_stream *stream,
 		php_openssl_netstream_data_t *sslsock,
 		php_stream_xport_crypto_param *cparam
 		TSRMLS_DC)
 {
-	int n, retry = 1;
+	int n;
+	int retry = 1;
+	int cert_captured;
+	X509 *peer_cert;
 
 	if (cparam->inputs.activate && !sslsock->ssl_active) {
 		struct timeval	start_time,
@@ -428,9 +1697,9 @@
 		int				blocked		= sslsock->s.is_blocked,
 						has_timeout = 0;
 
-#if OPENSSL_VERSION_NUMBER >= 0x0090806fL && !defined(OPENSSL_NO_TLSEXT)
-		if (sslsock->is_client && sslsock->sni) {
-			SSL_set_tlsext_host_name(sslsock->ssl_handle, sslsock->sni);
+#ifdef HAVE_SNI
+		if (sslsock->is_client) {
+			enable_client_sni(stream, sslsock);
 		}
 #endif
 
@@ -442,7 +1711,7 @@
 			}
 			sslsock->state_set = 1;
 		}
-	
+
 		if (SUCCESS == php_set_sock_blocking(sslsock->s.socket, 0 TSRMLS_CC)) {
 			sslsock->s.is_blocked = 0;
 		}
@@ -456,7 +1725,7 @@
 		
 		do {
 			struct timeval	cur_time,
-							elapsed_time;
+							elapsed_time = {0};
 			
 			if (sslsock->is_client) {
 				n = SSL_connect(sslsock->ssl_handle);
@@ -466,17 +1735,10 @@
 
 			if (has_timeout) {
 				gettimeofday(&cur_time, NULL);
-				elapsed_time.tv_sec  = cur_time.tv_sec  - start_time.tv_sec;
-				elapsed_time.tv_usec = cur_time.tv_usec - start_time.tv_usec;
-				if (cur_time.tv_usec < start_time.tv_usec) {
-					elapsed_time.tv_sec  -= 1L;
-					elapsed_time.tv_usec += 1000000L;
-				}
+				elapsed_time = subtract_timeval( cur_time, start_time );
 			
-				if (elapsed_time.tv_sec > timeout->tv_sec ||
-						(elapsed_time.tv_sec == timeout->tv_sec &&
-						elapsed_time.tv_usec > timeout->tv_usec)) {
-					php_error_docref(NULL TSRMLS_CC, E_WARNING, "SSL: crypto enabling timeout");
+				if (compare_timeval( elapsed_time, *timeout) > 0) {
+					php_error_docref(NULL TSRMLS_CC, E_WARNING, "SSL: Handshake timed out");
 					return -1;
 				}
 			}
@@ -491,12 +1753,7 @@
 					struct timeval left_time;
 					
 					if (has_timeout) {
-						left_time.tv_sec  = timeout->tv_sec  - elapsed_time.tv_sec;
-						left_time.tv_usec =	timeout->tv_usec - elapsed_time.tv_usec;
-						if (timeout->tv_usec < elapsed_time.tv_usec) {
-							left_time.tv_sec  -= 1L;
-							left_time.tv_usec += 1000000L;
-						}
+						left_time = subtract_timeval( *timeout, elapsed_time );
 					}
 					php_pollfd_for(sslsock->s.socket, (err == SSL_ERROR_WANT_READ) ?
 						(POLLIN|POLLPRI) : POLLOUT, has_timeout ? &left_time : NULL);
@@ -511,78 +1768,43 @@
 		}
 
 		if (n == 1) {
-			X509 *peer_cert;
-
 			peer_cert = SSL_get_peer_certificate(sslsock->ssl_handle);
+			if (peer_cert && stream->context) {
+				cert_captured = capture_peer_certs(stream, sslsock, peer_cert TSRMLS_CC);
+			}
 
-			if (FAILURE == php_openssl_apply_verification_policy(sslsock->ssl_handle, peer_cert, stream TSRMLS_CC)) {
+			if (FAILURE == apply_peer_verification_policy(sslsock->ssl_handle, peer_cert, stream TSRMLS_CC)) {
 				SSL_shutdown(sslsock->ssl_handle);
 				n = -1;
 			} else {	
 				sslsock->ssl_active = 1;
 
-				/* allow the script to capture the peer cert
-				 * and/or the certificate chain */
 				if (stream->context) {
-					zval **val, *zcert;
-
-					if (SUCCESS == php_stream_context_get_option(
-								stream->context, "ssl",
-								"capture_peer_cert", &val) &&
-							zval_is_true(*val)) {
-						MAKE_STD_ZVAL(zcert);
-						ZVAL_RESOURCE(zcert, zend_list_insert(peer_cert, 
-									php_openssl_get_x509_list_id()));
-						php_stream_context_set_option(stream->context,
-								"ssl", "peer_certificate",
-								zcert);
-						peer_cert = NULL;
-						FREE_ZVAL(zcert);
-					}
-
-					if (SUCCESS == php_stream_context_get_option(
-								stream->context, "ssl",
-								"capture_peer_cert_chain", &val) &&
-							zval_is_true(*val)) {
-						zval *arr;
-						STACK_OF(X509) *chain;
-
-						MAKE_STD_ZVAL(arr);
-						chain = SSL_get_peer_cert_chain(
-									sslsock->ssl_handle);
-
-						if (chain && sk_X509_num(chain) > 0) {
-							int i;
-							array_init(arr);
-
-							for (i = 0; i < sk_X509_num(chain); i++) {
-								X509 *mycert = X509_dup(
-										sk_X509_value(chain, i));
-								MAKE_STD_ZVAL(zcert);
-								ZVAL_RESOURCE(zcert,
-										zend_list_insert(mycert,
-											php_openssl_get_x509_list_id()));
-								add_next_index_zval(arr, zcert);
-							}
+					zval **val;
 
-						} else {
-							ZVAL_NULL(arr);
-						}
-
-						php_stream_context_set_option(stream->context,
-								"ssl", "peer_certificate_chain",
-								arr);
-						zval_dtor(arr);
-						efree(arr);
+					if (SUCCESS == php_stream_context_get_option(stream->context,
+							"ssl", "capture_session_meta", &val) &&
+						zend_is_true(*val)
+					) {
+						zval *meta_arr = capture_session_meta(sslsock->ssl_handle);
+						php_stream_context_set_option(stream->context, "ssl", "session_meta", meta_arr);
+						zval_dtor(meta_arr);
+						efree(meta_arr);
 					}
 				}
 			}
-
-			if (peer_cert) {
-				X509_free(peer_cert);
+		} else if (errno == EAGAIN) {
+			n = 0;
+		} else {
+			n = -1;
+			peer_cert = SSL_get_peer_certificate(sslsock->ssl_handle);
+			if (peer_cert && stream->context) {
+				cert_captured = capture_peer_certs(stream, sslsock, peer_cert TSRMLS_CC);
 			}
-		} else  {
-			n = errno == EAGAIN ? 0 : -1;
+		}
+
+		if (n && peer_cert && cert_captured == 0) {
+			X509_free(peer_cert);
 		}
 
 		return n;
@@ -592,9 +1814,296 @@
 		SSL_shutdown(sslsock->ssl_handle);
 		sslsock->ssl_active = 0;
 	}
+
 	return -1;
 }
 
+static size_t php_openssl_sockop_read(php_stream *stream, char *buf, size_t count TSRMLS_DC)/* {{{ */
+{
+	return php_openssl_sockop_io(1, stream, buf, count TSRMLS_CC);
+}
+/* }}} */
+
+static size_t php_openssl_sockop_write(php_stream *stream, const char *buf, size_t count TSRMLS_DC) /* {{{ */
+{
+	return php_openssl_sockop_io(0, stream, (char*)buf, count TSRMLS_CC);
+}
+/* }}} */
+
+/**
+ * Factored out common functionality (blocking, timeout, loop management) for read and write.
+ * Perform IO (read or write) to an SSL socket. If we have a timeout, we switch to non-blocking mode
+ * for the duration of the operation, using select to do our waits. If we time out, or we have an error
+ * report that back to PHP
+ *
+ */
+static size_t php_openssl_sockop_io(int read, php_stream *stream, char *buf, size_t count TSRMLS_DC)
+{
+	php_openssl_netstream_data_t *sslsock = (php_openssl_netstream_data_t*)stream->abstract;
+	int nr_bytes = 0;
+
+	/* Only do this if SSL is active. */
+	if (sslsock->ssl_active) {
+		int retry = 1;
+		struct timeval start_time;
+		struct timeval *timeout = NULL;
+		int began_blocked = sslsock->s.is_blocked;
+		int has_timeout = 0;
+
+		/* never use a timeout with non-blocking sockets */
+		if (began_blocked && &sslsock->s.timeout) {
+			timeout = &sslsock->s.timeout;
+		}
+
+		if (timeout && php_set_sock_blocking(sslsock->s.socket, 0 TSRMLS_CC) == SUCCESS) {
+			sslsock->s.is_blocked = 0;
+		}
+
+		if (!sslsock->s.is_blocked && timeout && (timeout->tv_sec || timeout->tv_usec)) {
+			has_timeout = 1;
+			/* gettimeofday is not monotonic; using it here is not strictly correct */
+			gettimeofday(&start_time, NULL);
+		}
+
+		/* Main IO loop. */
+		do {
+			struct timeval cur_time, elapsed_time, left_time;
+	
+			/* If we have a timeout to check, figure out how much time has elapsed since we started. */
+			if (has_timeout) {
+				gettimeofday(&cur_time, NULL);
+
+				/* Determine how much time we've taken so far. */
+				elapsed_time = subtract_timeval(cur_time, start_time);
+
+				/* and return an error if we've taken too long. */
+				if (compare_timeval(elapsed_time, *timeout) > 0 ) {
+					/* If the socket was originally blocking, set it back. */
+					if (began_blocked) {
+						php_set_sock_blocking(sslsock->s.socket, 1 TSRMLS_CC);
+						sslsock->s.is_blocked = 1;
+					}
+					sslsock->s.timeout_event = 1;
+					return -1;
+				}
+			}
+
+			/* Now, do the IO operation. Don't block if we can't complete... */
+			if (read) {
+				nr_bytes = SSL_read(sslsock->ssl_handle, buf, count);
+
+				if (sslsock->reneg && sslsock->reneg->should_close) {
+					/* renegotiation rate limiting triggered */
+					php_stream_xport_shutdown(stream, (stream_shutdown_t)SHUT_RDWR TSRMLS_CC);
+					nr_bytes = 0;
+					stream->eof = 1;
+					break;
+				}
+			} else {
+				nr_bytes = SSL_write(sslsock->ssl_handle, buf, count);
+			}
+
+			/* Now, how much time until we time out? */
+			if (has_timeout) {
+				left_time = subtract_timeval( *timeout, elapsed_time );
+			}
+
+			/* If we didn't do anything on the last loop (or an error) check to see if we should retry or exit. */
+			if (nr_bytes <= 0) {
+
+				/* Get the error code from SSL, and check to see if it's an error or not. */
+				int err = SSL_get_error(sslsock->ssl_handle, nr_bytes );
+				retry = handle_ssl_error(stream, nr_bytes, 0 TSRMLS_CC);
+
+				/* If we get this (the above doesn't check) then we'll retry as well. */
+				if (errno == EAGAIN && err == SSL_ERROR_WANT_READ && read) {
+					retry = 1;
+				}
+				if (errno == EAGAIN && err == SSL_ERROR_WANT_WRITE && read == 0) {
+					retry = 1;
+				}
+
+				/* Also, on reads, we may get this condition on an EOF. We should check properly. */
+				if (read) {
+					stream->eof = (retry == 0 && errno != EAGAIN && !SSL_pending(sslsock->ssl_handle));
+				}
+
+				/* Don't loop indefinitely in non-blocking mode if no data is available */
+				if (began_blocked == 0) {
+					break;
+				}
+
+				/* Now, if we have to wait some time, and we're supposed to be blocking, wait for the socket to become
+				 * available. Now, php_pollfd_for uses select to wait up to our time_left value only...
+				 */
+				if (retry) {
+					if (read) {
+						php_pollfd_for(sslsock->s.socket, (err == SSL_ERROR_WANT_WRITE) ?
+							(POLLOUT|POLLPRI) : (POLLIN|POLLPRI), has_timeout ? &left_time : NULL);
+					} else {
+						php_pollfd_for(sslsock->s.socket, (err == SSL_ERROR_WANT_READ) ?
+							(POLLIN|POLLPRI) : (POLLOUT|POLLPRI), has_timeout ? &left_time : NULL);
+					}
+				}
+			} else {
+				/* Else, if we got bytes back, check for possible errors. */
+				int err = SSL_get_error(sslsock->ssl_handle, nr_bytes);
+
+				/* If we didn't get any error, then let's return it to PHP. */
+				if (err == SSL_ERROR_NONE)
+				break;
+
+				/* Otherwise, we need to wait again (up to time_left or we get an error) */
+				if (began_blocked) {
+					if (read) {
+						php_pollfd_for(sslsock->s.socket, (err == SSL_ERROR_WANT_WRITE) ?
+							(POLLOUT|POLLPRI) : (POLLIN|POLLPRI), has_timeout ? &left_time : NULL);
+					} else {
+						php_pollfd_for(sslsock->s.socket, (err == SSL_ERROR_WANT_READ) ?
+							(POLLIN|POLLPRI) : (POLLOUT|POLLPRI), has_timeout ? &left_time : NULL);
+					}
+				}
+			}
+		/* Finally, we keep going until we got data, and an SSL_ERROR_NONE, unless we had an error. */
+		} while (retry);
+
+		/* Tell PHP if we read / wrote bytes. */
+		if (nr_bytes > 0) {
+			php_stream_notify_progress_increment(stream->context, nr_bytes, 0);
+		}
+
+		/* And if we were originally supposed to be blocking, let's reset the socket to that. */
+		if (began_blocked && php_set_sock_blocking(sslsock->s.socket, 1 TSRMLS_CC) == SUCCESS) {
+			sslsock->s.is_blocked = 1;
+		}
+	} else {
+		/*
+		 * This block is if we had no timeout... We will just sit and wait forever on the IO operation.
+		 */
+		if (read) {
+			nr_bytes = php_stream_socket_ops.read(stream, buf, count TSRMLS_CC);
+		} else {
+			nr_bytes = php_stream_socket_ops.write(stream, buf, count TSRMLS_CC);
+		}
+	}
+
+	/* PHP doesn't expect a negative return. */
+	if (nr_bytes < 0) {
+		nr_bytes = 0;
+	}
+
+	return nr_bytes;
+}
+/* }}} */
+
+struct timeval subtract_timeval( struct timeval a, struct timeval b )
+{
+	struct timeval difference;
+
+	difference.tv_sec  = a.tv_sec  - b.tv_sec;
+	difference.tv_usec = a.tv_usec - b.tv_usec;
+
+	if (a.tv_usec < b.tv_usec) {
+	  	b.tv_sec  -= 1L;
+	   	b.tv_usec += 1000000L;
+	}
+
+	return difference;
+}
+
+int compare_timeval( struct timeval a, struct timeval b )
+{
+	if (a.tv_sec > b.tv_sec || (a.tv_sec == b.tv_sec && a.tv_usec > b.tv_usec) ) {
+		return 1;
+	} else if( a.tv_sec == b.tv_sec && a.tv_usec == b.tv_usec ) {
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+static int php_openssl_sockop_close(php_stream *stream, int close_handle TSRMLS_DC) /* {{{ */
+{
+	php_openssl_netstream_data_t *sslsock = (php_openssl_netstream_data_t*)stream->abstract;
+#ifdef PHP_WIN32
+	int n;
+#endif
+	unsigned i;
+
+	if (close_handle) {
+		if (sslsock->ssl_active) {
+			SSL_shutdown(sslsock->ssl_handle);
+			sslsock->ssl_active = 0;
+		}
+		if (sslsock->ssl_handle) {
+			SSL_free(sslsock->ssl_handle);
+			sslsock->ssl_handle = NULL;
+		}
+		if (sslsock->ctx) {
+			SSL_CTX_free(sslsock->ctx);
+			sslsock->ctx = NULL;
+		}
+#ifdef PHP_WIN32
+		if (sslsock->s.socket == -1)
+			sslsock->s.socket = SOCK_ERR;
+#endif
+		if (sslsock->s.socket != SOCK_ERR) {
+#ifdef PHP_WIN32
+			/* prevent more data from coming in */
+			shutdown(sslsock->s.socket, SHUT_RD);
+
+			/* try to make sure that the OS sends all data before we close the connection.
+			 * Essentially, we are waiting for the socket to become writeable, which means
+			 * that all pending data has been sent.
+			 * We use a small timeout which should encourage the OS to send the data,
+			 * but at the same time avoid hanging indefinitely.
+			 * */
+			do {
+				n = php_pollfd_for_ms(sslsock->s.socket, POLLOUT, 500);
+			} while (n == -1 && php_socket_errno() == EINTR);
+#endif
+			closesocket(sslsock->s.socket);
+			sslsock->s.socket = SOCK_ERR;
+		}
+	}
+
+	if (sslsock->sni_certs) {
+		for (i = 0; i < sslsock->sni_cert_count; i++) {
+			if (sslsock->sni_certs[i].ctx) {
+				SSL_CTX_free(sslsock->sni_certs[i].ctx);
+				pefree(sslsock->sni_certs[i].name, php_stream_is_persistent(stream));
+			}
+		}
+		pefree(sslsock->sni_certs, php_stream_is_persistent(stream));
+		sslsock->sni_certs = NULL;
+	}
+
+	if (sslsock->url_name) {
+		pefree(sslsock->url_name, php_stream_is_persistent(stream));
+	}
+
+	if (sslsock->reneg) {
+		pefree(sslsock->reneg, php_stream_is_persistent(stream));
+	}
+
+	pefree(sslsock, php_stream_is_persistent(stream));
+
+	return 0;
+}
+/* }}} */
+
+static int php_openssl_sockop_flush(php_stream *stream TSRMLS_DC) /* {{{ */
+{
+	return php_stream_socket_ops.flush(stream TSRMLS_CC);
+}
+/* }}} */
+
+static int php_openssl_sockop_stat(php_stream *stream, php_stream_statbuf *ssb TSRMLS_DC) /* {{{ */
+{
+	return php_stream_socket_ops.stat(stream, ssb TSRMLS_CC);
+}
+/* }}} */
+
 static inline int php_openssl_tcp_sockop_accept(php_stream *stream, php_openssl_netstream_data_t *sock,
 		php_stream_xport_param *xparam STREAMS_DC TSRMLS_DC)
 {
@@ -637,22 +2146,9 @@
 		}
 
 		if (xparam->outputs.client && sock->enable_on_connect) {
-			/* apply crypto */
-			switch (sock->method) {
-				case STREAM_CRYPTO_METHOD_SSLv23_CLIENT:
-					sock->method = STREAM_CRYPTO_METHOD_SSLv23_SERVER;
-					break;
-				case STREAM_CRYPTO_METHOD_SSLv2_CLIENT:
-					sock->method = STREAM_CRYPTO_METHOD_SSLv2_SERVER;
-					break;
-				case STREAM_CRYPTO_METHOD_SSLv3_CLIENT:
-					sock->method = STREAM_CRYPTO_METHOD_SSLv3_SERVER;
-					break;
-				case STREAM_CRYPTO_METHOD_TLS_CLIENT:
-					sock->method = STREAM_CRYPTO_METHOD_TLS_SERVER;
-					break;
-				default:
-					break;
+			/* remove the client bit */
+			if (sock->method & STREAM_CRYPTO_IS_CLIENT) {
+				sock->method = ((sock->method >> 1) << 1);
 			}
 
 			clisockdata->method = sock->method;
@@ -671,6 +2167,7 @@
 	
 	return xparam->outputs.client == NULL ? -1 : 0;
 }
+
 static int php_openssl_sockop_set_option(php_stream *stream, int option, int value, void *ptrparam TSRMLS_DC)
 {
 	php_openssl_netstream_data_t *sslsock = (php_openssl_netstream_data_t*)stream->abstract;
@@ -809,7 +2306,16 @@
 
 		case PHP_STREAM_AS_FD_FOR_SELECT:
 			if (ret) {
-				*(int *)ret = sslsock->s.socket;
+				size_t pending;
+				if (stream->writepos == stream->readpos
+					&& sslsock->ssl_active
+					&& (pending = (size_t)SSL_pending(sslsock->ssl_handle)) > 0) {
+						php_stream_fill_read_buffer(stream, pending < stream->chunk_size
+							? pending
+							: stream->chunk_size);
+				}
+
+				*(php_socket_t *)ret = sslsock->s.socket;
 			}
 			return SUCCESS;
 
@@ -819,7 +2325,7 @@
 				return FAILURE;
 			}
 			if (ret) {
-				*(int *)ret = sslsock->s.socket;
+				*(php_socket_t *)ret = sslsock->s.socket;
 			}
 			return SUCCESS;
 		default:
@@ -837,21 +2343,22 @@
 	php_openssl_sockop_set_option,
 };
 
-static char * get_sni(php_stream_context *ctx, char *resourcename, long resourcenamelen, int is_persistent TSRMLS_DC) {
+static long get_crypto_method(php_stream_context *ctx, long crypto_method)
+{
+	zval **val;
 
-	php_url *url;
+	if (ctx && php_stream_context_get_option(ctx, "ssl", "crypto_method", &val) == SUCCESS) {
+		convert_to_long_ex(val);
+		crypto_method = (long)Z_LVAL_PP(val);
+		crypto_method |= STREAM_CRYPTO_IS_CLIENT;
+	}
 
-	if (ctx) {
-		zval **val = NULL;
+	return crypto_method;
+}
 
-		if (php_stream_context_get_option(ctx, "ssl", "SNI_enabled", &val) == SUCCESS && !zend_is_true(*val)) {
-			return NULL;
-		}
-		if (php_stream_context_get_option(ctx, "ssl", "SNI_server_name", &val) == SUCCESS) {
-			convert_to_string_ex(val);
-			return pestrdup(Z_STRVAL_PP(val), is_persistent);
-		}
-	}
+static char *get_url_name(const char *resourcename, size_t resourcenamelen, int is_persistent TSRMLS_DC)
+{
+	php_url *url;
 
 	if (!resourcename) {
 		return NULL;
@@ -864,7 +2371,7 @@
 
 	if (url->host) {
 		const char * host = url->host;
-		char * sni = NULL;
+		char * url_name = NULL;
 		size_t len = strlen(host);
 
 		/* skip trailing dots */
@@ -873,11 +2380,11 @@
 		}
 
 		if (len) {
-			sni = pestrndup(host, len, is_persistent);
+			url_name = pestrndup(host, len, is_persistent);
 		}
 
 		php_url_free(url);
-		return sni;
+		return url_name;
 	}
 
 	php_url_free(url);
@@ -892,7 +2399,7 @@
 {
 	php_stream *stream = NULL;
 	php_openssl_netstream_data_t *sslsock = NULL;
-	
+
 	sslsock = pemalloc(sizeof(php_openssl_netstream_data_t), persistent_id ? 1 : 0);
 	memset(sslsock, 0, sizeof(*sslsock));
 
@@ -908,10 +2415,10 @@
 	/* we don't know the socket until we have determined if we are binding or
 	 * connecting */
 	sslsock->s.socket = -1;
-	
+
 	/* Initialize context as NULL */
 	sslsock->ctx = NULL;	
-	
+
 	stream = php_stream_alloc_rel(&php_openssl_socket_ops, sslsock, persistent_id, "r+");
 
 	if (stream == NULL)	{
@@ -919,11 +2426,9 @@
 		return NULL;
 	}
 
-	sslsock->sni = get_sni(context, resourcename, resourcenamelen, !!persistent_id TSRMLS_CC);
-	
 	if (strncmp(proto, "ssl", protolen) == 0) {
 		sslsock->enable_on_connect = 1;
-		sslsock->method = STREAM_CRYPTO_METHOD_SSLv23_CLIENT;
+		sslsock->method = get_crypto_method(context, STREAM_CRYPTO_METHOD_ANY_CLIENT);
 	} else if (strncmp(proto, "sslv2", protolen) == 0) {
 #ifdef OPENSSL_NO_SSL2
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, "SSLv2 support is not compiled into the OpenSSL library PHP is linked against");
@@ -933,13 +2438,39 @@
 		sslsock->method = STREAM_CRYPTO_METHOD_SSLv2_CLIENT;
 #endif
 	} else if (strncmp(proto, "sslv3", protolen) == 0) {
+#ifdef OPENSSL_NO_SSL3
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "SSLv3 support is not compiled into the OpenSSL library PHP is linked against");
+		return NULL;
+#else
 		sslsock->enable_on_connect = 1;
 		sslsock->method = STREAM_CRYPTO_METHOD_SSLv3_CLIENT;
+#endif
 	} else if (strncmp(proto, "tls", protolen) == 0) {
 		sslsock->enable_on_connect = 1;
-		sslsock->method = STREAM_CRYPTO_METHOD_TLS_CLIENT;
+		sslsock->method = get_crypto_method(context, STREAM_CRYPTO_METHOD_TLS_CLIENT);
+	} else if (strncmp(proto, "tlsv1.0", protolen) == 0) {
+		sslsock->enable_on_connect = 1;
+		sslsock->method = STREAM_CRYPTO_METHOD_TLSv1_0_CLIENT;
+	} else if (strncmp(proto, "tlsv1.1", protolen) == 0) {
+#if OPENSSL_VERSION_NUMBER >= 0x10001001L
+		sslsock->enable_on_connect = 1;
+		sslsock->method = STREAM_CRYPTO_METHOD_TLSv1_1_CLIENT;
+#else
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "TLSv1.1 support is not compiled into the OpenSSL library PHP is linked against");
+		return NULL;
+#endif
+	} else if (strncmp(proto, "tlsv1.2", protolen) == 0) {
+#if OPENSSL_VERSION_NUMBER >= 0x10001001L
+		sslsock->enable_on_connect = 1;
+		sslsock->method = STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT;
+#else
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "TLSv1.2 support is not compiled into the OpenSSL library PHP is linked against");
+		return NULL;
+#endif
 	}
 
+	sslsock->url_name = get_url_name(resourcename, resourcenamelen, !!persistent_id TSRMLS_CC);
+
 	return stream;
 }
 
diff -uNr php-5.3.29-ori/ext/phar/util.c php-5.3.29/ext/phar/util.c
--- php-5.3.29-ori/ext/phar/util.c	2019-01-25 02:38:50.044549893 +0800
+++ php-5.3.29/ext/phar/util.c	2019-01-26 11:29:19.967117841 +0800
@@ -1803,7 +1803,7 @@
 			BIO *in;
 			EVP_PKEY *key;
 			EVP_MD *mdtype = (EVP_MD *) EVP_sha1();
-			EVP_MD_CTX md_ctx;
+			EVP_MD_CTX *md_ctx;
 #else
 			int tempsig;
 #endif
@@ -1880,7 +1880,8 @@
 				return FAILURE;
 			}
 
-			EVP_VerifyInit(&md_ctx, mdtype);
+			md_ctx = EVP_MD_CTX_create();
+			EVP_VerifyInit(md_ctx, mdtype);
 			read_len = end_of_phar;
 
 			if (read_len > sizeof(buf)) {
@@ -1892,7 +1893,7 @@
 			php_stream_seek(fp, 0, SEEK_SET);
 
 			while (read_size && (len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
-				EVP_VerifyUpdate (&md_ctx, buf, len);
+				EVP_VerifyUpdate (md_ctx, buf, len);
 				read_len -= (off_t)len;
 
 				if (read_len < read_size) {
@@ -1900,9 +1901,9 @@
 				}
 			}
 
-			if (EVP_VerifyFinal(&md_ctx, (unsigned char *)sig, sig_len, key) != 1) {
+			if (EVP_VerifyFinal(md_ctx, (unsigned char *)sig, sig_len, key) != 1) {
 				/* 1: signature verified, 0: signature does not match, -1: failed signature operation */
-				EVP_MD_CTX_cleanup(&md_ctx);
+				EVP_MD_CTX_destroy(md_ctx);
 
 				if (error) {
 					spprintf(error, 0, "broken openssl signature");
@@ -1911,7 +1912,7 @@
 				return FAILURE;
 			}
 
-			EVP_MD_CTX_cleanup(&md_ctx);
+			EVP_MD_CTX_destroy(md_ctx);
 #endif
 
 			*signature_len = phar_hex_str((const char*)sig, sig_len, signature TSRMLS_CC);
diff -uNr php-5.3.29-ori/ext/phar/util.c.orig php-5.3.29/ext/phar/util.c.orig
--- php-5.3.29-ori/ext/phar/util.c.orig	1970-01-01 08:00:00.000000000 +0800
+++ php-5.3.29/ext/phar/util.c.orig	2019-01-26 11:28:32.008283539 +0800
@@ -0,0 +1,2394 @@
+/*
+  +----------------------------------------------------------------------+
+  | phar php single-file executable PHP extension                        |
+  | utility functions                                                    |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2005-2013 The PHP Group                                |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 3.01 of the PHP license,      |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.php.net/license/3_01.txt.                                 |
+  | If you did not receive a copy of the PHP license and are unable to   |
+  | obtain it through the world-wide-web, please send a note to          |
+  | license@php.net so we can mail you a copy immediately.               |
+  +----------------------------------------------------------------------+
+  | Authors: Gregory Beaver <cellog@php.net>                             |
+  |          Marcus Boerger <helly@php.net>                              |
+  +----------------------------------------------------------------------+
+*/
+
+/* $Id$ */
+
+#include "phar_internal.h"
+#ifdef PHAR_HASH_OK
+#include "ext/hash/php_hash_sha.h"
+#endif
+
+#ifdef PHAR_HAVE_OPENSSL
+/* OpenSSL includes */
+#include <openssl/evp.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <openssl/crypto.h>
+#include <openssl/pem.h>
+#include <openssl/err.h>
+#include <openssl/conf.h>
+#include <openssl/rand.h>
+#include <openssl/ssl.h>
+#include <openssl/pkcs12.h>
+#else
+static int phar_call_openssl_signverify(int is_sign, php_stream *fp, off_t end, char *key, int key_len, char **signature, int *signature_len TSRMLS_DC);
+#endif
+
+#if !defined(PHP_VERSION_ID) || PHP_VERSION_ID < 50300
+extern php_stream_wrapper php_stream_phar_wrapper;
+#endif
+
+/* for links to relative location, prepend cwd of the entry */
+static char *phar_get_link_location(phar_entry_info *entry TSRMLS_DC) /* {{{ */
+{
+	char *p, *ret = NULL;
+	if (!entry->link) {
+		return NULL;
+	}
+	if (entry->link[0] == '/') {
+		return estrdup(entry->link + 1);
+	}
+	p = strrchr(entry->filename, '/');
+	if (p) {
+		*p = '\0';
+		spprintf(&ret, 0, "%s/%s", entry->filename, entry->link);
+		return ret;
+	}
+	return entry->link;
+}
+/* }}} */
+
+phar_entry_info *phar_get_link_source(phar_entry_info *entry TSRMLS_DC) /* {{{ */
+{
+	phar_entry_info *link_entry;
+	char *link;
+
+	if (!entry->link) {
+		return entry;
+	}
+
+	link = phar_get_link_location(entry TSRMLS_CC);
+	if (SUCCESS == zend_hash_find(&(entry->phar->manifest), entry->link, strlen(entry->link), (void **)&link_entry) ||
+		SUCCESS == zend_hash_find(&(entry->phar->manifest), link, strlen(link), (void **)&link_entry)) {
+		if (link != entry->link) {
+			efree(link);
+		}
+		return phar_get_link_source(link_entry TSRMLS_CC);
+	} else {
+		if (link != entry->link) {
+			efree(link);
+		}
+		return NULL;
+	}
+}
+/* }}} */
+
+/* retrieve a phar_entry_info's current file pointer for reading contents */
+php_stream *phar_get_efp(phar_entry_info *entry, int follow_links TSRMLS_DC) /* {{{ */
+{
+	if (follow_links && entry->link) {
+		phar_entry_info *link_entry = phar_get_link_source(entry TSRMLS_CC);
+
+		if (link_entry && link_entry != entry) {
+			return phar_get_efp(link_entry, 1 TSRMLS_CC);
+		}
+	}
+
+	if (phar_get_fp_type(entry TSRMLS_CC) == PHAR_FP) {
+		if (!phar_get_entrypfp(entry TSRMLS_CC)) {
+			/* re-open just in time for cases where our refcount reached 0 on the phar archive */
+			phar_open_archive_fp(entry->phar TSRMLS_CC);
+		}
+		return phar_get_entrypfp(entry TSRMLS_CC);
+	} else if (phar_get_fp_type(entry TSRMLS_CC) == PHAR_UFP) {
+		return phar_get_entrypufp(entry TSRMLS_CC);
+	} else if (entry->fp_type == PHAR_MOD) {
+		return entry->fp;
+	} else {
+		/* temporary manifest entry */
+		if (!entry->fp) {
+			entry->fp = php_stream_open_wrapper(entry->tmp, "rb", STREAM_MUST_SEEK|0, NULL);
+		}
+		return entry->fp;
+	}
+}
+/* }}} */
+
+int phar_seek_efp(phar_entry_info *entry, off_t offset, int whence, off_t position, int follow_links TSRMLS_DC) /* {{{ */
+{
+	php_stream *fp = phar_get_efp(entry, follow_links TSRMLS_CC);
+	off_t temp, eoffset;
+
+	if (!fp) {
+		return -1;
+	}
+
+	if (follow_links) {
+		phar_entry_info *t;
+		t = phar_get_link_source(entry TSRMLS_CC);
+		if (t) {
+			entry = t;
+		}
+	}
+
+	if (entry->is_dir) {
+		return 0;
+	}
+
+	eoffset = phar_get_fp_offset(entry TSRMLS_CC);
+
+	switch (whence) {
+		case SEEK_END:
+			temp = eoffset + entry->uncompressed_filesize + offset;
+			break;
+		case SEEK_CUR:
+			temp = eoffset + position + offset;
+			break;
+		case SEEK_SET:
+			temp = eoffset + offset;
+			break;
+		default:
+			temp = 0;
+			break;
+	}
+
+	if (temp > eoffset + (off_t) entry->uncompressed_filesize) {
+		return -1;
+	}
+
+	if (temp < eoffset) {
+		return -1;
+	}
+
+	return php_stream_seek(fp, temp, SEEK_SET);
+}
+/* }}} */
+
+/* mount an absolute path or uri to a path internal to the phar archive */
+int phar_mount_entry(phar_archive_data *phar, char *filename, int filename_len, char *path, int path_len TSRMLS_DC) /* {{{ */
+{
+	phar_entry_info entry = {0};
+	php_stream_statbuf ssb;
+	int is_phar;
+	const char *err;
+
+	if (phar_path_check(&path, &path_len, &err) > pcr_is_ok) {
+		return FAILURE;
+	}
+
+	if (path_len >= sizeof(".phar")-1 && !memcmp(path, ".phar", sizeof(".phar")-1)) {
+		/* no creating magic phar files by mounting them */
+		return FAILURE;
+	}
+
+	is_phar = (filename_len > 7 && !memcmp(filename, "phar://", 7));
+
+	entry.phar = phar;
+	entry.filename = estrndup(path, path_len);
+#ifdef PHP_WIN32
+	phar_unixify_path_separators(entry.filename, path_len);
+#endif
+	entry.filename_len = path_len;
+	if (is_phar) {
+		entry.tmp = estrndup(filename, filename_len);
+	} else {
+		entry.tmp = expand_filepath(filename, NULL TSRMLS_CC);
+		if (!entry.tmp) {
+			entry.tmp = estrndup(filename, filename_len);
+		}
+	}
+#if PHP_API_VERSION < 20100412
+	if (PG(safe_mode) && !is_phar && (!php_checkuid(entry.tmp, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {
+		efree(entry.tmp);
+		efree(entry.filename);
+		return FAILURE;
+	}
+#endif
+	filename = entry.tmp;
+
+	/* only check openbasedir for files, not for phar streams */
+	if (!is_phar && php_check_open_basedir(filename TSRMLS_CC)) {
+		efree(entry.tmp);
+		efree(entry.filename);
+		return FAILURE;
+	}
+
+	entry.is_mounted = 1;
+	entry.is_crc_checked = 1;
+	entry.fp_type = PHAR_TMP;
+
+	if (SUCCESS != php_stream_stat_path(filename, &ssb)) {
+		efree(entry.tmp);
+		efree(entry.filename);
+		return FAILURE;
+	}
+
+	if (ssb.sb.st_mode & S_IFDIR) {
+		entry.is_dir = 1;
+		if (SUCCESS != zend_hash_add(&phar->mounted_dirs, entry.filename, path_len, (void *)&(entry.filename), sizeof(char *), NULL)) {
+			/* directory already mounted */
+			efree(entry.tmp);
+			efree(entry.filename);
+			return FAILURE;
+		}
+	} else {
+		entry.is_dir = 0;
+		entry.uncompressed_filesize = entry.compressed_filesize = ssb.sb.st_size;
+	}
+
+	entry.flags = ssb.sb.st_mode;
+
+	if (SUCCESS == zend_hash_add(&phar->manifest, entry.filename, path_len, (void*)&entry, sizeof(phar_entry_info), NULL)) {
+		return SUCCESS;
+	}
+
+	efree(entry.tmp);
+	efree(entry.filename);
+	return FAILURE;
+}
+/* }}} */
+
+char *phar_find_in_include_path(char *filename, int filename_len, phar_archive_data **pphar TSRMLS_DC) /* {{{ */
+{
+#if PHP_VERSION_ID >= 50300
+	char *path, *fname, *arch, *entry, *ret, *test;
+	int arch_len, entry_len, fname_len, ret_len;
+	phar_archive_data *phar;
+
+	if (pphar) {
+		*pphar = NULL;
+	} else {
+		pphar = &phar;
+	}
+
+	if (!zend_is_executing(TSRMLS_C) || !PHAR_G(cwd)) {
+		return phar_save_resolve_path(filename, filename_len TSRMLS_CC);
+	}
+
+	fname = zend_get_executed_filename(TSRMLS_C);
+	fname_len = strlen(fname);
+
+	if (PHAR_G(last_phar) && !memcmp(fname, "phar://", 7) && fname_len - 7 >= PHAR_G(last_phar_name_len) && !memcmp(fname + 7, PHAR_G(last_phar_name), PHAR_G(last_phar_name_len))) {
+		arch = estrndup(PHAR_G(last_phar_name), PHAR_G(last_phar_name_len));
+		arch_len = PHAR_G(last_phar_name_len);
+		phar = PHAR_G(last_phar);
+		goto splitted;
+	}
+
+	if (fname_len < 7 || memcmp(fname, "phar://", 7) || SUCCESS != phar_split_fname(fname, strlen(fname), &arch, &arch_len, &entry, &entry_len, 1, 0 TSRMLS_CC)) {
+		return phar_save_resolve_path(filename, filename_len TSRMLS_CC);
+	}
+
+	efree(entry);
+
+	if (*filename == '.') {
+		int try_len;
+
+		if (FAILURE == phar_get_archive(&phar, arch, arch_len, NULL, 0, NULL TSRMLS_CC)) {
+			efree(arch);
+			return phar_save_resolve_path(filename, filename_len TSRMLS_CC);
+		}
+splitted:
+		if (pphar) {
+			*pphar = phar;
+		}
+
+		try_len = filename_len;
+		test = phar_fix_filepath(estrndup(filename, filename_len), &try_len, 1 TSRMLS_CC);
+
+		if (*test == '/') {
+			if (zend_hash_exists(&(phar->manifest), test + 1, try_len - 1)) {
+				spprintf(&ret, 0, "phar://%s%s", arch, test);
+				efree(arch);
+				efree(test);
+				return ret;
+			}
+		} else {
+			if (zend_hash_exists(&(phar->manifest), test, try_len)) {
+				spprintf(&ret, 0, "phar://%s/%s", arch, test);
+				efree(arch);
+				efree(test);
+				return ret;
+			}
+		}
+		efree(test);
+	}
+
+	spprintf(&path, MAXPATHLEN, "phar://%s/%s%c%s", arch, PHAR_G(cwd), DEFAULT_DIR_SEPARATOR, PG(include_path));
+	efree(arch);
+	ret = php_resolve_path(filename, filename_len, path TSRMLS_CC);
+	efree(path);
+
+	if (ret && strlen(ret) > 8 && !strncmp(ret, "phar://", 7)) {
+		ret_len = strlen(ret);
+		/* found phar:// */
+
+		if (SUCCESS != phar_split_fname(ret, ret_len, &arch, &arch_len, &entry, &entry_len, 1, 0 TSRMLS_CC)) {
+			return ret;
+		}
+
+		zend_hash_find(&(PHAR_GLOBALS->phar_fname_map), arch, arch_len, (void **) &pphar);
+
+		if (!pphar && PHAR_G(manifest_cached)) {
+			zend_hash_find(&cached_phars, arch, arch_len, (void **) &pphar);
+		}
+
+		efree(arch);
+		efree(entry);
+	}
+
+	return ret;
+#else /* PHP 5.2 */
+	char resolved_path[MAXPATHLEN];
+	char trypath[MAXPATHLEN];
+	char *ptr, *end, *path = PG(include_path);
+	php_stream_wrapper *wrapper;
+	const char *p;
+	int n = 0;
+	char *fname, *arch, *entry, *ret, *test;
+	int arch_len, entry_len;
+	phar_archive_data *phar = NULL;
+
+	if (!filename) {
+		return NULL;
+	}
+
+	if (!zend_is_executing(TSRMLS_C) || !PHAR_G(cwd)) {
+		goto doit;
+	}
+
+	fname = zend_get_executed_filename(TSRMLS_C);
+
+	if (SUCCESS != phar_split_fname(fname, strlen(fname), &arch, &arch_len, &entry, &entry_len, 1, 0 TSRMLS_CC)) {
+		goto doit;
+	}
+
+	efree(entry);
+
+	if (*filename == '.') {
+		int try_len;
+
+		if (FAILURE == phar_get_archive(&phar, arch, arch_len, NULL, 0, NULL TSRMLS_CC)) {
+			efree(arch);
+			goto doit;
+		}
+
+		try_len = filename_len;
+		test = phar_fix_filepath(estrndup(filename, filename_len), &try_len, 1 TSRMLS_CC);
+
+		if (*test == '/') {
+			if (zend_hash_exists(&(phar->manifest), test + 1, try_len - 1)) {
+				spprintf(&ret, 0, "phar://%s%s", arch, test);
+				efree(arch);
+				efree(test);
+				return ret;
+			}
+		} else {
+			if (zend_hash_exists(&(phar->manifest), test, try_len)) {
+				spprintf(&ret, 0, "phar://%s/%s", arch, test);
+				efree(arch);
+				efree(test);
+				return ret;
+			}
+		}
+
+		efree(test);
+	}
+
+	efree(arch);
+doit:
+	if (*filename == '.' || IS_ABSOLUTE_PATH(filename, filename_len) || !path || !*path) {
+		if (tsrm_realpath(filename, resolved_path TSRMLS_CC)) {
+			return estrdup(resolved_path);
+		} else {
+			return NULL;
+		}
+	}
+
+	/* test for stream wrappers and return */
+	for (p = filename; p - filename < filename_len && (isalnum((int)*p) || *p == '+' || *p == '-' || *p == '.'); ++p, ++n);
+
+	if (n < filename_len - 3 && (*p == ':') && (!strncmp("//", p+1, 2) || ( filename_len > 4 && !memcmp("data", filename, 4)))) {
+		/* found stream wrapper, this is an absolute path until stream wrappers implement realpath */
+		return estrndup(filename, filename_len);
+	}
+
+	ptr = (char *) path;
+	while (ptr && *ptr) {
+		int len, is_stream_wrapper = 0, maybe_stream = 1;
+
+		end = strchr(ptr, DEFAULT_DIR_SEPARATOR);
+#ifndef PHP_WIN32
+		/* search for stream wrapper */
+		if (end - ptr  <= 1) {
+			maybe_stream = 0;
+			goto not_stream;
+		}
+
+		for (p = ptr, n = 0; p < end && (isalnum((int)*p) || *p == '+' || *p == '-' || *p == '.'); ++p, ++n);
+
+		if (n == end - ptr && *p && !strncmp("//", p+1, 2)) {
+			is_stream_wrapper = 1;
+			/* seek to real end of include_path portion */
+			end = strchr(end + 1, DEFAULT_DIR_SEPARATOR);
+		} else {
+			maybe_stream = 0;
+		}
+not_stream:
+#endif
+		if (end) {
+			if ((end-ptr) + 1 + filename_len + 1 >= MAXPATHLEN) {
+				ptr = end + 1;
+				continue;
+			}
+
+			memcpy(trypath, ptr, end-ptr);
+			len = end-ptr;
+			trypath[end-ptr] = '/';
+			memcpy(trypath+(end-ptr)+1, filename, filename_len+1);
+			ptr = end+1;
+		} else {
+			len = strlen(ptr);
+
+			if (len + 1 + filename_len + 1 >= MAXPATHLEN) {
+				break;
+			}
+
+			memcpy(trypath, ptr, len);
+			trypath[len] = '/';
+			memcpy(trypath+len+1, filename, filename_len+1);
+			ptr = NULL;
+		}
+
+		if (!is_stream_wrapper && maybe_stream) {
+			/* search for stream wrapper */
+			for (p = trypath, n = 0; isalnum((int)*p) || *p == '+' || *p == '-' || *p == '.'; ++p, ++n);
+		}
+
+		if (is_stream_wrapper || (n < len - 3 && (*p == ':') && (n > 1) && (!strncmp("//", p+1, 2) || !memcmp("data", trypath, 4)))) {
+			char *actual;
+
+			wrapper = php_stream_locate_url_wrapper(trypath, &actual, STREAM_OPEN_FOR_INCLUDE TSRMLS_CC);
+			if (wrapper == &php_plain_files_wrapper) {
+				strlcpy(trypath, actual, sizeof(trypath));
+			} else if (!wrapper) {
+				/* if wrapper is NULL, there was a mal-formed include_path stream wrapper, so skip this ptr */
+				continue;
+			} else {
+				if (wrapper->wops->url_stat) {
+					php_stream_statbuf ssb;
+
+					if (SUCCESS == wrapper->wops->url_stat(wrapper, trypath, 0, &ssb, NULL TSRMLS_CC)) {
+						if (wrapper == &php_stream_phar_wrapper) {
+							char *arch, *entry;
+							int arch_len, entry_len, ret_len;
+
+							ret_len = strlen(trypath);
+							/* found phar:// */
+
+							if (SUCCESS != phar_split_fname(trypath, ret_len, &arch, &arch_len, &entry, &entry_len, 1, 0 TSRMLS_CC)) {
+								return estrndup(trypath, ret_len);
+							}
+
+							zend_hash_find(&(PHAR_GLOBALS->phar_fname_map), arch, arch_len, (void **) &pphar);
+
+							if (!pphar && PHAR_G(manifest_cached)) {
+								zend_hash_find(&cached_phars, arch, arch_len, (void **) &pphar);
+							}
+
+							efree(arch);
+							efree(entry);
+
+							return estrndup(trypath, ret_len);
+						}
+						return estrdup(trypath);
+					}
+				}
+				continue;
+			}
+		}
+
+		if (tsrm_realpath(trypath, resolved_path TSRMLS_CC)) {
+			return estrdup(resolved_path);
+		}
+	} /* end provided path */
+
+	/* check in calling scripts' current working directory as a fall back case */
+	if (zend_is_executing(TSRMLS_C)) {
+		char *exec_fname = zend_get_executed_filename(TSRMLS_C);
+		int exec_fname_length = strlen(exec_fname);
+		const char *p;
+		int n = 0;
+
+		while ((--exec_fname_length >= 0) && !IS_SLASH(exec_fname[exec_fname_length]));
+		if (exec_fname && exec_fname[0] != '[' && 
+			exec_fname_length > 0 && 
+			exec_fname_length + 1 + filename_len + 1 < MAXPATHLEN) {
+			memcpy(trypath, exec_fname, exec_fname_length + 1);
+			memcpy(trypath+exec_fname_length + 1, filename, filename_len+1);
+
+			/* search for stream wrapper */
+			for (p = trypath; isalnum((int)*p) || *p == '+' || *p == '-' || *p == '.'; ++p, ++n);
+
+			if (n < exec_fname_length - 3 && (*p == ':') && (n > 1) && (!strncmp("//", p+1, 2) || !memcmp("data", trypath, 4))) {
+				char *actual;
+
+				wrapper = php_stream_locate_url_wrapper(trypath, &actual, STREAM_OPEN_FOR_INCLUDE TSRMLS_CC);
+
+				if (wrapper == &php_plain_files_wrapper) {
+					/* this should never technically happen, but we'll leave it here for completeness */
+					strlcpy(trypath, actual, sizeof(trypath));
+				} else if (!wrapper) {
+					/* if wrapper is NULL, there was a malformed include_path stream wrapper
+					   this also should be impossible */
+					return NULL;
+				} else {
+					return estrdup(trypath);
+				}
+			}
+
+			if (tsrm_realpath(trypath, resolved_path TSRMLS_CC)) {
+				return estrdup(resolved_path);
+			}
+		}
+	}
+
+	return NULL;
+#endif /* PHP 5.2 */
+}
+/* }}} */
+
+/**
+ * Retrieve a copy of the file information on a single file within a phar, or null.
+ * This also transfers the open file pointer, if any, to the entry.
+ *
+ * If the file does not already exist, this will fail.  Pre-existing files can be
+ * appended, truncated, or read.  For read, if the entry is marked unmodified, it is
+ * assumed that the file pointer, if present, is opened for reading
+ */
+int phar_get_entry_data(phar_entry_data **ret, char *fname, int fname_len, char *path, int path_len, char *mode, char allow_dir, char **error, int security TSRMLS_DC) /* {{{ */
+{
+	phar_archive_data *phar;
+	phar_entry_info *entry;
+	int for_write  = mode[0] != 'r' || mode[1] == '+';
+	int for_append = mode[0] == 'a';
+	int for_create = mode[0] != 'r';
+	int for_trunc  = mode[0] == 'w';
+
+	if (!ret) {
+		return FAILURE;
+	}
+
+	*ret = NULL;
+
+	if (error) {
+		*error = NULL;
+	}
+
+	if (FAILURE == phar_get_archive(&phar, fname, fname_len, NULL, 0, error TSRMLS_CC)) {
+		return FAILURE;
+	}
+
+	if (for_write && PHAR_G(readonly) && !phar->is_data) {
+		if (error) {
+			spprintf(error, 4096, "phar error: file \"%s\" in phar \"%s\" cannot be opened for writing, disabled by ini setting", path, fname);
+		}
+		return FAILURE;
+	}
+
+	if (!path_len) {
+		if (error) {
+			spprintf(error, 4096, "phar error: file \"\" in phar \"%s\" cannot be empty", fname);
+		}
+		return FAILURE;
+	}
+really_get_entry:
+	if (allow_dir) {
+		if ((entry = phar_get_entry_info_dir(phar, path, path_len, allow_dir, for_create && !PHAR_G(readonly) && !phar->is_data ? NULL : error, security TSRMLS_CC)) == NULL) {
+			if (for_create && (!PHAR_G(readonly) || phar->is_data)) {
+				return SUCCESS;
+			}
+			return FAILURE;
+		}
+	} else {
+		if ((entry = phar_get_entry_info(phar, path, path_len, for_create && !PHAR_G(readonly) && !phar->is_data ? NULL : error, security TSRMLS_CC)) == NULL) {
+			if (for_create && (!PHAR_G(readonly) || phar->is_data)) {
+				return SUCCESS;
+			}
+			return FAILURE;
+		}
+	}
+
+	if (for_write && phar->is_persistent) {
+		if (FAILURE == phar_copy_on_write(&phar TSRMLS_CC)) {
+			if (error) {
+				spprintf(error, 4096, "phar error: file \"%s\" in phar \"%s\" cannot be opened for writing, could not make cached phar writeable", path, fname);
+			}
+			return FAILURE;
+		} else {
+			goto really_get_entry;
+		}
+	}
+
+	if (entry->is_modified && !for_write) {
+		if (error) {
+			spprintf(error, 4096, "phar error: file \"%s\" in phar \"%s\" cannot be opened for reading, writable file pointers are open", path, fname);
+		}
+		return FAILURE;
+	}
+
+	if (entry->fp_refcount && for_write) {
+		if (error) {
+			spprintf(error, 4096, "phar error: file \"%s\" in phar \"%s\" cannot be opened for writing, readable file pointers are open", path, fname);
+		}
+		return FAILURE;
+	}
+
+	if (entry->is_deleted) {
+		if (!for_create) {
+			return FAILURE;
+		}
+		entry->is_deleted = 0;
+	}
+
+	if (entry->is_dir) {
+		*ret = (phar_entry_data *) emalloc(sizeof(phar_entry_data));
+		(*ret)->position = 0;
+		(*ret)->fp = NULL;
+		(*ret)->phar = phar;
+		(*ret)->for_write = for_write;
+		(*ret)->internal_file = entry;
+		(*ret)->is_zip = entry->is_zip;
+		(*ret)->is_tar = entry->is_tar;
+
+		if (!phar->is_persistent) {
+			++(entry->phar->refcount);
+			++(entry->fp_refcount);
+		}
+
+		return SUCCESS;
+	}
+
+	if (entry->fp_type == PHAR_MOD) {
+		if (for_trunc) {
+			if (FAILURE == phar_create_writeable_entry(phar, entry, error TSRMLS_CC)) {
+				return FAILURE;
+			}
+		} else if (for_append) {
+			phar_seek_efp(entry, 0, SEEK_END, 0, 0 TSRMLS_CC);
+		}
+	} else {
+		if (for_write) {
+			if (entry->link) {
+				efree(entry->link);
+				entry->link = NULL;
+				entry->tar_type = (entry->is_tar ? TAR_FILE : '\0');
+			}
+
+			if (for_trunc) {
+				if (FAILURE == phar_create_writeable_entry(phar, entry, error TSRMLS_CC)) {
+					return FAILURE;
+				}
+			} else {
+				if (FAILURE == phar_separate_entry_fp(entry, error TSRMLS_CC)) {
+					return FAILURE;
+				}
+			}
+		} else {
+			if (FAILURE == phar_open_entry_fp(entry, error, 1 TSRMLS_CC)) {
+				return FAILURE;
+			}
+		}
+	}
+
+	*ret = (phar_entry_data *) emalloc(sizeof(phar_entry_data));
+	(*ret)->position = 0;
+	(*ret)->phar = phar;
+	(*ret)->for_write = for_write;
+	(*ret)->internal_file = entry;
+	(*ret)->is_zip = entry->is_zip;
+	(*ret)->is_tar = entry->is_tar;
+	(*ret)->fp = phar_get_efp(entry, 1 TSRMLS_CC);
+	if (entry->link) {
+		(*ret)->zero = phar_get_fp_offset(phar_get_link_source(entry TSRMLS_CC) TSRMLS_CC);
+	} else {
+		(*ret)->zero = phar_get_fp_offset(entry TSRMLS_CC);
+	}
+
+	if (!phar->is_persistent) {
+		++(entry->fp_refcount);
+		++(entry->phar->refcount);
+	}
+
+	return SUCCESS;
+}
+/* }}} */
+
+/**
+ * Create a new dummy file slot within a writeable phar for a newly created file
+ */
+phar_entry_data *phar_get_or_create_entry_data(char *fname, int fname_len, char *path, int path_len, char *mode, char allow_dir, char **error, int security TSRMLS_DC) /* {{{ */
+{
+	phar_archive_data *phar;
+	phar_entry_info *entry, etemp;
+	phar_entry_data *ret;
+	const char *pcr_error;
+	char is_dir;
+
+#ifdef PHP_WIN32
+	phar_unixify_path_separators(path, path_len);
+#endif
+
+	is_dir = (path_len && path[path_len - 1] == '/') ? 1 : 0;
+
+	if (FAILURE == phar_get_archive(&phar, fname, fname_len, NULL, 0, error TSRMLS_CC)) {
+		return NULL;
+	}
+
+	if (FAILURE == phar_get_entry_data(&ret, fname, fname_len, path, path_len, mode, allow_dir, error, security TSRMLS_CC)) {
+		return NULL;
+	} else if (ret) {
+		return ret;
+	}
+
+	if (phar_path_check(&path, &path_len, &pcr_error) > pcr_is_ok) {
+		if (error) {
+			spprintf(error, 0, "phar error: invalid path \"%s\" contains %s", path, pcr_error);
+		}
+		return NULL;
+	}
+
+	if (phar->is_persistent && FAILURE == phar_copy_on_write(&phar TSRMLS_CC)) {
+		if (error) {
+			spprintf(error, 4096, "phar error: file \"%s\" in phar \"%s\" cannot be created, could not make cached phar writeable", path, fname);
+		}
+		return NULL;
+	}
+
+	/* create a new phar data holder */
+	ret = (phar_entry_data *) emalloc(sizeof(phar_entry_data));
+
+	/* create an entry, this is a new file */
+	memset(&etemp, 0, sizeof(phar_entry_info));
+	etemp.filename_len = path_len;
+	etemp.fp_type = PHAR_MOD;
+	etemp.fp = php_stream_fopen_tmpfile();
+
+	if (!etemp.fp) {
+		if (error) {
+			spprintf(error, 0, "phar error: unable to create temporary file");
+		}
+		efree(ret);
+		return NULL;
+	}
+
+	etemp.fp_refcount = 1;
+
+	if (allow_dir == 2) {
+		etemp.is_dir = 1;
+		etemp.flags = etemp.old_flags = PHAR_ENT_PERM_DEF_DIR;
+	} else {
+		etemp.flags = etemp.old_flags = PHAR_ENT_PERM_DEF_FILE;
+	}
+	if (is_dir) {
+		etemp.filename_len--; /* strip trailing / */
+		path_len--;
+	}
+
+	phar_add_virtual_dirs(phar, path, path_len TSRMLS_CC);
+	etemp.is_modified = 1;
+	etemp.timestamp = time(0);
+	etemp.is_crc_checked = 1;
+	etemp.phar = phar;
+	etemp.filename = estrndup(path, path_len);
+	etemp.is_zip = phar->is_zip;
+
+	if (phar->is_tar) {
+		etemp.is_tar = phar->is_tar;
+		etemp.tar_type = etemp.is_dir ? TAR_DIR : TAR_FILE;
+	}
+
+	if (FAILURE == zend_hash_add(&phar->manifest, etemp.filename, path_len, (void*)&etemp, sizeof(phar_entry_info), (void **) &entry)) {
+		php_stream_close(etemp.fp);
+		if (error) {
+			spprintf(error, 0, "phar error: unable to add new entry \"%s\" to phar \"%s\"", etemp.filename, phar->fname);
+		}
+		efree(ret);
+		efree(etemp.filename);
+		return NULL;
+	}
+
+	if (!entry) {
+		php_stream_close(etemp.fp);
+		efree(etemp.filename);
+		efree(ret);
+		return NULL;
+	}
+
+	++(phar->refcount);
+	ret->phar = phar;
+	ret->fp = entry->fp;
+	ret->position = ret->zero = 0;
+	ret->for_write = 1;
+	ret->is_zip = entry->is_zip;
+	ret->is_tar = entry->is_tar;
+	ret->internal_file = entry;
+
+	return ret;
+}
+/* }}} */
+
+/* initialize a phar_archive_data's read-only fp for existing phar data */
+int phar_open_archive_fp(phar_archive_data *phar TSRMLS_DC) /* {{{ */
+{
+	if (phar_get_pharfp(phar TSRMLS_CC)) {
+		return SUCCESS;
+	}
+#if PHP_API_VERSION < 20100412
+	if (PG(safe_mode) && (!php_checkuid(phar->fname, NULL, CHECKUID_ALLOW_ONLY_FILE))) {
+		return FAILURE;
+	}
+#endif
+
+	if (php_check_open_basedir(phar->fname TSRMLS_CC)) {
+		return FAILURE;
+	}
+
+	phar_set_pharfp(phar, php_stream_open_wrapper(phar->fname, "rb", IGNORE_URL|STREAM_MUST_SEEK|0, NULL) TSRMLS_CC);
+
+	if (!phar_get_pharfp(phar TSRMLS_CC)) {
+		return FAILURE;
+	}
+
+	return SUCCESS;
+}
+/* }}} */
+
+/* copy file data from an existing to a new phar_entry_info that is not in the manifest */
+int phar_copy_entry_fp(phar_entry_info *source, phar_entry_info *dest, char **error TSRMLS_DC) /* {{{ */
+{
+	phar_entry_info *link;
+
+	if (FAILURE == phar_open_entry_fp(source, error, 1 TSRMLS_CC)) {
+		return FAILURE;
+	}
+
+	if (dest->link) {
+		efree(dest->link);
+		dest->link = NULL;
+		dest->tar_type = (dest->is_tar ? TAR_FILE : '\0');
+	}
+
+	dest->fp_type = PHAR_MOD;
+	dest->offset = 0;
+	dest->is_modified = 1;
+	dest->fp = php_stream_fopen_tmpfile();
+	if (dest->fp == NULL) {
+		spprintf(error, 0, "phar error: unable to create temporary file");
+		return EOF;
+	}
+	phar_seek_efp(source, 0, SEEK_SET, 0, 1 TSRMLS_CC);
+	link = phar_get_link_source(source TSRMLS_CC);
+
+	if (!link) {
+		link = source;
+	}
+
+	if (SUCCESS != phar_stream_copy_to_stream(phar_get_efp(link, 0 TSRMLS_CC), dest->fp, link->uncompressed_filesize, NULL)) {
+		php_stream_close(dest->fp);
+		dest->fp_type = PHAR_FP;
+		if (error) {
+			spprintf(error, 4096, "phar error: unable to copy contents of file \"%s\" to \"%s\" in phar archive \"%s\"", source->filename, dest->filename, source->phar->fname);
+		}
+		return FAILURE;
+	}
+
+	return SUCCESS;
+}
+/* }}} */
+
+/* open and decompress a compressed phar entry
+ */
+int phar_open_entry_fp(phar_entry_info *entry, char **error, int follow_links TSRMLS_DC) /* {{{ */
+{
+	php_stream_filter *filter;
+	phar_archive_data *phar = entry->phar;
+	char *filtername;
+	off_t loc;
+	php_stream *ufp;
+	phar_entry_data dummy;
+
+	if (follow_links && entry->link) {
+		phar_entry_info *link_entry = phar_get_link_source(entry TSRMLS_CC);
+		if (link_entry && link_entry != entry) {
+			return phar_open_entry_fp(link_entry, error, 1 TSRMLS_CC);
+		}
+	}
+
+	if (entry->is_modified) {
+		return SUCCESS;
+	}
+
+	if (entry->fp_type == PHAR_TMP) {
+		if (!entry->fp) {
+			entry->fp = php_stream_open_wrapper(entry->tmp, "rb", STREAM_MUST_SEEK|0, NULL);
+		}
+		return SUCCESS;
+	}
+
+	if (entry->fp_type != PHAR_FP) {
+		/* either newly created or already modified */
+		return SUCCESS;
+	}
+
+	if (!phar_get_pharfp(phar TSRMLS_CC)) {
+		if (FAILURE == phar_open_archive_fp(phar TSRMLS_CC)) {
+			spprintf(error, 4096, "phar error: Cannot open phar archive \"%s\" for reading", phar->fname);
+			return FAILURE;
+		}
+	}
+
+	if ((entry->old_flags && !(entry->old_flags & PHAR_ENT_COMPRESSION_MASK)) || !(entry->flags & PHAR_ENT_COMPRESSION_MASK)) {
+		dummy.internal_file = entry;
+		dummy.phar = phar;
+		dummy.zero = entry->offset;
+		dummy.fp = phar_get_pharfp(phar TSRMLS_CC);
+		if (FAILURE == phar_postprocess_file(&dummy, entry->crc32, error, 1 TSRMLS_CC)) {
+			return FAILURE;
+		}
+		return SUCCESS;
+	}
+
+	if (!phar_get_entrypufp(entry TSRMLS_CC)) {
+		phar_set_entrypufp(entry, php_stream_fopen_tmpfile() TSRMLS_CC);
+		if (!phar_get_entrypufp(entry TSRMLS_CC)) {
+			spprintf(error, 4096, "phar error: Cannot open temporary file for decompressing phar archive \"%s\" file \"%s\"", phar->fname, entry->filename);
+			return FAILURE;
+		}
+	}
+
+	dummy.internal_file = entry;
+	dummy.phar = phar;
+	dummy.zero = entry->offset;
+	dummy.fp = phar_get_pharfp(phar TSRMLS_CC);
+	if (FAILURE == phar_postprocess_file(&dummy, entry->crc32, error, 1 TSRMLS_CC)) {
+		return FAILURE;
+	}
+
+	ufp = phar_get_entrypufp(entry TSRMLS_CC);
+
+	if ((filtername = phar_decompress_filter(entry, 0)) != NULL) {
+		filter = php_stream_filter_create(filtername, NULL, 0 TSRMLS_CC);
+	} else {
+		filter = NULL;
+	}
+
+	if (!filter) {
+		spprintf(error, 4096, "phar error: unable to read phar \"%s\" (cannot create %s filter while decompressing file \"%s\")", phar->fname, phar_decompress_filter(entry, 1), entry->filename);
+		return FAILURE;
+	}
+
+	/* now we can safely use proper decompression */
+	/* save the new offset location within ufp */
+	php_stream_seek(ufp, 0, SEEK_END);
+	loc = php_stream_tell(ufp);
+	php_stream_filter_append(&ufp->writefilters, filter);
+	php_stream_seek(phar_get_entrypfp(entry TSRMLS_CC), phar_get_fp_offset(entry TSRMLS_CC), SEEK_SET);
+
+	if (entry->uncompressed_filesize) {
+		if (SUCCESS != phar_stream_copy_to_stream(phar_get_entrypfp(entry TSRMLS_CC), ufp, entry->compressed_filesize, NULL)) {
+			spprintf(error, 4096, "phar error: internal corruption of phar \"%s\" (actual filesize mismatch on file \"%s\")", phar->fname, entry->filename);
+			php_stream_filter_remove(filter, 1 TSRMLS_CC);
+			return FAILURE;
+		}
+	}
+
+	php_stream_filter_flush(filter, 1);
+	php_stream_flush(ufp);
+	php_stream_filter_remove(filter, 1 TSRMLS_CC);
+
+	if (php_stream_tell(ufp) - loc != (off_t) entry->uncompressed_filesize) {
+		spprintf(error, 4096, "phar error: internal corruption of phar \"%s\" (actual filesize mismatch on file \"%s\")", phar->fname, entry->filename);
+		return FAILURE;
+	}
+
+	entry->old_flags = entry->flags;
+
+	/* this is now the new location of the file contents within this fp */
+	phar_set_fp_type(entry, PHAR_UFP, loc TSRMLS_CC);
+	dummy.zero = entry->offset;
+	dummy.fp = ufp;
+	if (FAILURE == phar_postprocess_file(&dummy, entry->crc32, error, 0 TSRMLS_CC)) {
+		return FAILURE;
+	}
+	return SUCCESS;
+}
+/* }}} */
+
+#if defined(PHP_VERSION_ID) && PHP_VERSION_ID < 50202
+typedef struct {
+	char        *data;
+	size_t      fpos;
+	size_t      fsize;
+	size_t      smax;
+	int         mode;
+	php_stream  **owner_ptr;
+} php_stream_memory_data;
+#endif
+
+int phar_create_writeable_entry(phar_archive_data *phar, phar_entry_info *entry, char **error TSRMLS_DC) /* {{{ */
+{
+	if (entry->fp_type == PHAR_MOD) {
+		/* already newly created, truncate */
+#if PHP_VERSION_ID >= 50202
+		php_stream_truncate_set_size(entry->fp, 0);
+#else
+		if (php_stream_is(entry->fp, PHP_STREAM_IS_TEMP)) {
+			if (php_stream_is(*(php_stream**)entry->fp->abstract, PHP_STREAM_IS_MEMORY)) {
+				php_stream *inner = *(php_stream**)entry->fp->abstract;
+				php_stream_memory_data *memfp = (php_stream_memory_data*)inner->abstract;
+				memfp->fpos = 0;
+				memfp->fsize = 0;
+			} else if (php_stream_is(*(php_stream**)entry->fp->abstract, PHP_STREAM_IS_STDIO)) {
+				php_stream_truncate_set_size(*(php_stream**)entry->fp->abstract, 0);
+			} else {
+				if (error) {
+					spprintf(error, 0, "phar error: file \"%s\" cannot be opened for writing, no truncate support", phar->fname);
+				}
+				return FAILURE;
+			}
+		} else if (php_stream_is(entry->fp, PHP_STREAM_IS_STDIO)) {
+			php_stream_truncate_set_size(entry->fp, 0);
+		} else {
+			if (error) {
+				spprintf(error, 0, "phar error: file \"%s\" cannot be opened for writing, no truncate support", phar->fname);
+			}
+			return FAILURE;
+		}
+#endif
+		entry->old_flags = entry->flags;
+		entry->is_modified = 1;
+		phar->is_modified = 1;
+		/* reset file size */
+		entry->uncompressed_filesize = 0;
+		entry->compressed_filesize = 0;
+		entry->crc32 = 0;
+		entry->flags = PHAR_ENT_PERM_DEF_FILE;
+		entry->fp_type = PHAR_MOD;
+		entry->offset = 0;
+		return SUCCESS;
+	}
+
+	if (error) {
+		*error = NULL;
+	}
+
+	/* open a new temp file for writing */
+	if (entry->link) {
+		efree(entry->link);
+		entry->link = NULL;
+		entry->tar_type = (entry->is_tar ? TAR_FILE : '\0');
+	}
+
+	entry->fp = php_stream_fopen_tmpfile();
+
+	if (!entry->fp) {
+		if (error) {
+			spprintf(error, 0, "phar error: unable to create temporary file");
+		}
+		return FAILURE;
+	}
+
+	entry->old_flags = entry->flags;
+	entry->is_modified = 1;
+	phar->is_modified = 1;
+	/* reset file size */
+	entry->uncompressed_filesize = 0;
+	entry->compressed_filesize = 0;
+	entry->crc32 = 0;
+	entry->flags = PHAR_ENT_PERM_DEF_FILE;
+	entry->fp_type = PHAR_MOD;
+	entry->offset = 0;
+	return SUCCESS;
+}
+/* }}} */
+
+int phar_separate_entry_fp(phar_entry_info *entry, char **error TSRMLS_DC) /* {{{ */
+{
+	php_stream *fp;
+	phar_entry_info *link;
+
+	if (FAILURE == phar_open_entry_fp(entry, error, 1 TSRMLS_CC)) {
+		return FAILURE;
+	}
+
+	if (entry->fp_type == PHAR_MOD) {
+		return SUCCESS;
+	}
+
+	fp = php_stream_fopen_tmpfile();
+	if (fp == NULL) {
+		spprintf(error, 0, "phar error: unable to create temporary file");
+		return FAILURE;
+	}
+	phar_seek_efp(entry, 0, SEEK_SET, 0, 1 TSRMLS_CC);
+	link = phar_get_link_source(entry TSRMLS_CC);
+
+	if (!link) {
+		link = entry;
+	}
+
+	if (SUCCESS != phar_stream_copy_to_stream(phar_get_efp(link, 0 TSRMLS_CC), fp, link->uncompressed_filesize, NULL)) {
+		if (error) {
+			spprintf(error, 4096, "phar error: cannot separate entry file \"%s\" contents in phar archive \"%s\" for write access", entry->filename, entry->phar->fname);
+		}
+		return FAILURE;
+	}
+
+	if (entry->link) {
+		efree(entry->link);
+		entry->link = NULL;
+		entry->tar_type = (entry->is_tar ? TAR_FILE : '\0');
+	}
+
+	entry->offset = 0;
+	entry->fp = fp;
+	entry->fp_type = PHAR_MOD;
+	entry->is_modified = 1;
+	return SUCCESS;
+}
+/* }}} */
+
+/**
+ * helper function to open an internal file's fp just-in-time
+ */
+phar_entry_info * phar_open_jit(phar_archive_data *phar, phar_entry_info *entry, char **error TSRMLS_DC) /* {{{ */
+{
+	if (error) {
+		*error = NULL;
+	}
+	/* seek to start of internal file and read it */
+	if (FAILURE == phar_open_entry_fp(entry, error, 1 TSRMLS_CC)) {
+		return NULL;
+	}
+	if (-1 == phar_seek_efp(entry, 0, SEEK_SET, 0, 1 TSRMLS_CC)) {
+		spprintf(error, 4096, "phar error: cannot seek to start of file \"%s\" in phar \"%s\"", entry->filename, phar->fname);
+		return NULL;
+	}
+	return entry;
+}
+/* }}} */
+
+int phar_free_alias(phar_archive_data *phar, char *alias, int alias_len TSRMLS_DC) /* {{{ */
+{
+	if (phar->refcount || phar->is_persistent) {
+		return FAILURE;
+	}
+
+	/* this archive has no open references, so emit an E_STRICT and remove it */
+	if (zend_hash_del(&(PHAR_GLOBALS->phar_fname_map), phar->fname, phar->fname_len) != SUCCESS) {
+		return FAILURE;
+	}
+
+	/* invalidate phar cache */
+	PHAR_G(last_phar) = NULL;
+	PHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;
+
+	return SUCCESS;
+}
+/* }}} */
+
+/**
+ * Looks up a phar archive in the filename map, connecting it to the alias
+ * (if any) or returns null
+ */
+int phar_get_archive(phar_archive_data **archive, char *fname, int fname_len, char *alias, int alias_len, char **error TSRMLS_DC) /* {{{ */
+{
+	phar_archive_data *fd, **fd_ptr;
+	char *my_realpath, *save;
+	int save_len;
+	ulong fhash, ahash = 0;
+
+	phar_request_initialize(TSRMLS_C);
+
+	if (error) {
+		*error = NULL;
+	}
+
+	*archive = NULL;
+
+	if (PHAR_G(last_phar) && fname_len == PHAR_G(last_phar_name_len) && !memcmp(fname, PHAR_G(last_phar_name), fname_len)) {
+		*archive = PHAR_G(last_phar);
+		if (alias && alias_len) {
+
+			if (!PHAR_G(last_phar)->is_temporary_alias && (alias_len != PHAR_G(last_phar)->alias_len || memcmp(PHAR_G(last_phar)->alias, alias, alias_len))) {
+				if (error) {
+					spprintf(error, 0, "alias \"%s\" is already used for archive \"%s\" cannot be overloaded with \"%s\"", alias, PHAR_G(last_phar)->fname, fname);
+				}
+				*archive = NULL;
+				return FAILURE;
+			}
+
+			if (PHAR_G(last_phar)->alias_len && SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), PHAR_G(last_phar)->alias, PHAR_G(last_phar)->alias_len, (void**)&fd_ptr)) {
+				zend_hash_del(&(PHAR_GLOBALS->phar_alias_map), PHAR_G(last_phar)->alias, PHAR_G(last_phar)->alias_len);
+			}
+
+			zend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&(*archive), sizeof(phar_archive_data*), NULL);
+			PHAR_G(last_alias) = alias;
+			PHAR_G(last_alias_len) = alias_len;
+		}
+
+		return SUCCESS;
+	}
+
+	if (alias && alias_len && PHAR_G(last_phar) && alias_len == PHAR_G(last_alias_len) && !memcmp(alias, PHAR_G(last_alias), alias_len)) {
+		fd = PHAR_G(last_phar);
+		fd_ptr = &fd;
+		goto alias_success;
+	}
+
+	if (alias && alias_len) {
+		ahash = zend_inline_hash_func(alias, alias_len);
+		if (SUCCESS == zend_hash_quick_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, ahash, (void**)&fd_ptr)) {
+alias_success:
+			if (fname && (fname_len != (*fd_ptr)->fname_len || strncmp(fname, (*fd_ptr)->fname, fname_len))) {
+				if (error) {
+					spprintf(error, 0, "alias \"%s\" is already used for archive \"%s\" cannot be overloaded with \"%s\"", alias, (*fd_ptr)->fname, fname);
+				}
+				if (SUCCESS == phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {
+					efree(*error);
+					*error = NULL;
+				}
+				return FAILURE;
+			}
+
+			*archive = *fd_ptr;
+			fd = *fd_ptr;
+			PHAR_G(last_phar) = fd;
+			PHAR_G(last_phar_name) = fd->fname;
+			PHAR_G(last_phar_name_len) = fd->fname_len;
+			PHAR_G(last_alias) = alias;
+			PHAR_G(last_alias_len) = alias_len;
+
+			return SUCCESS;
+		}
+
+		if (PHAR_G(manifest_cached) && SUCCESS == zend_hash_quick_find(&cached_alias, alias, alias_len, ahash, (void **)&fd_ptr)) {
+			goto alias_success;
+		}
+	}
+
+	fhash = zend_inline_hash_func(fname, fname_len);
+	my_realpath = NULL;
+	save = fname;
+	save_len = fname_len;
+
+	if (fname && fname_len) {
+		if (SUCCESS == zend_hash_quick_find(&(PHAR_GLOBALS->phar_fname_map), fname, fname_len, fhash, (void**)&fd_ptr)) {
+			*archive = *fd_ptr;
+			fd = *fd_ptr;
+
+			if (alias && alias_len) {
+				if (!fd->is_temporary_alias && (alias_len != fd->alias_len || memcmp(fd->alias, alias, alias_len))) {
+					if (error) {
+						spprintf(error, 0, "alias \"%s\" is already used for archive \"%s\" cannot be overloaded with \"%s\"", alias, (*fd_ptr)->fname, fname);
+					}
+					return FAILURE;
+				}
+
+				if (fd->alias_len && SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), fd->alias, fd->alias_len, (void**)&fd_ptr)) {
+					zend_hash_del(&(PHAR_GLOBALS->phar_alias_map), fd->alias, fd->alias_len);
+				}
+
+				zend_hash_quick_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, ahash, (void*)&fd, sizeof(phar_archive_data*), NULL);
+			}
+
+			PHAR_G(last_phar) = fd;
+			PHAR_G(last_phar_name) = fd->fname;
+			PHAR_G(last_phar_name_len) = fd->fname_len;
+			PHAR_G(last_alias) = fd->alias;
+			PHAR_G(last_alias_len) = fd->alias_len;
+
+			return SUCCESS;
+		}
+
+		if (PHAR_G(manifest_cached) && SUCCESS == zend_hash_quick_find(&cached_phars, fname, fname_len, fhash, (void**)&fd_ptr)) {
+			*archive = *fd_ptr;
+			fd = *fd_ptr;
+
+			/* this could be problematic - alias should never be different from manifest alias
+			   for cached phars */
+			if (!fd->is_temporary_alias && alias && alias_len) {
+				if (alias_len != fd->alias_len || memcmp(fd->alias, alias, alias_len)) {
+					if (error) {
+						spprintf(error, 0, "alias \"%s\" is already used for archive \"%s\" cannot be overloaded with \"%s\"", alias, (*fd_ptr)->fname, fname);
+					}
+					return FAILURE;
+				}
+			}
+
+			PHAR_G(last_phar) = fd;
+			PHAR_G(last_phar_name) = fd->fname;
+			PHAR_G(last_phar_name_len) = fd->fname_len;
+			PHAR_G(last_alias) = fd->alias;
+			PHAR_G(last_alias_len) = fd->alias_len;
+
+			return SUCCESS;
+		}
+
+		if (SUCCESS == zend_hash_quick_find(&(PHAR_GLOBALS->phar_alias_map), save, save_len, fhash, (void**)&fd_ptr)) {
+			fd = *archive = *fd_ptr;
+
+			PHAR_G(last_phar) = fd;
+			PHAR_G(last_phar_name) = fd->fname;
+			PHAR_G(last_phar_name_len) = fd->fname_len;
+			PHAR_G(last_alias) = fd->alias;
+			PHAR_G(last_alias_len) = fd->alias_len;
+
+			return SUCCESS;
+		}
+
+		if (PHAR_G(manifest_cached) && SUCCESS == zend_hash_quick_find(&cached_alias, save, save_len, fhash, (void**)&fd_ptr)) {
+			fd = *archive = *fd_ptr;
+
+			PHAR_G(last_phar) = fd;
+			PHAR_G(last_phar_name) = fd->fname;
+			PHAR_G(last_phar_name_len) = fd->fname_len;
+			PHAR_G(last_alias) = fd->alias;
+			PHAR_G(last_alias_len) = fd->alias_len;
+
+			return SUCCESS;
+		}
+
+		/* not found, try converting \ to / */
+		my_realpath = expand_filepath(fname, my_realpath TSRMLS_CC);
+
+		if (my_realpath) {
+			fname_len = strlen(my_realpath);
+			fname = my_realpath;
+		} else {
+			return FAILURE;
+		}
+#ifdef PHP_WIN32
+		phar_unixify_path_separators(fname, fname_len);
+#endif
+		fhash = zend_inline_hash_func(fname, fname_len);
+
+		if (SUCCESS == zend_hash_quick_find(&(PHAR_GLOBALS->phar_fname_map), fname, fname_len, fhash, (void**)&fd_ptr)) {
+realpath_success:
+			*archive = *fd_ptr;
+			fd = *fd_ptr;
+
+			if (alias && alias_len) {
+				zend_hash_quick_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, ahash, (void*)&fd, sizeof(phar_archive_data*), NULL);
+			}
+
+			efree(my_realpath);
+
+			PHAR_G(last_phar) = fd;
+			PHAR_G(last_phar_name) = fd->fname;
+			PHAR_G(last_phar_name_len) = fd->fname_len;
+			PHAR_G(last_alias) = fd->alias;
+			PHAR_G(last_alias_len) = fd->alias_len;
+
+			return SUCCESS;
+		}
+
+		if (PHAR_G(manifest_cached) && SUCCESS == zend_hash_quick_find(&cached_phars, fname, fname_len, fhash, (void**)&fd_ptr)) {
+			goto realpath_success;
+		}
+
+		efree(my_realpath);
+	}
+
+	return FAILURE;
+}
+/* }}} */
+
+/**
+ * Determine which stream compression filter (if any) we need to read this file
+ */
+char * phar_compress_filter(phar_entry_info * entry, int return_unknown) /* {{{ */
+{
+	switch (entry->flags & PHAR_ENT_COMPRESSION_MASK) {
+	case PHAR_ENT_COMPRESSED_GZ:
+		return "zlib.deflate";
+	case PHAR_ENT_COMPRESSED_BZ2:
+		return "bzip2.compress";
+	default:
+		return return_unknown ? "unknown" : NULL;
+	}
+}
+/* }}} */
+
+/**
+ * Determine which stream decompression filter (if any) we need to read this file
+ */
+char * phar_decompress_filter(phar_entry_info * entry, int return_unknown) /* {{{ */
+{
+	php_uint32 flags;
+
+	if (entry->is_modified) {
+		flags = entry->old_flags;
+	} else {
+		flags = entry->flags;
+	}
+
+	switch (flags & PHAR_ENT_COMPRESSION_MASK) {
+		case PHAR_ENT_COMPRESSED_GZ:
+			return "zlib.inflate";
+		case PHAR_ENT_COMPRESSED_BZ2:
+			return "bzip2.decompress";
+		default:
+			return return_unknown ? "unknown" : NULL;
+	}
+}
+/* }}} */
+
+/**
+ * retrieve information on a file contained within a phar, or null if it ain't there
+ */
+phar_entry_info *phar_get_entry_info(phar_archive_data *phar, char *path, int path_len, char **error, int security TSRMLS_DC) /* {{{ */
+{
+	return phar_get_entry_info_dir(phar, path, path_len, 0, error, security TSRMLS_CC);
+}
+/* }}} */
+/**
+ * retrieve information on a file or directory contained within a phar, or null if none found
+ * allow_dir is 0 for none, 1 for both empty directories in the phar and temp directories, and 2 for only
+ * valid pre-existing empty directory entries
+ */
+phar_entry_info *phar_get_entry_info_dir(phar_archive_data *phar, char *path, int path_len, char dir, char **error, int security TSRMLS_DC) /* {{{ */
+{
+	const char *pcr_error;
+	phar_entry_info *entry;
+	int is_dir;
+
+#ifdef PHP_WIN32
+	phar_unixify_path_separators(path, path_len);
+#endif
+
+	is_dir = (path_len && (path[path_len - 1] == '/')) ? 1 : 0;
+
+	if (error) {
+		*error = NULL;
+	}
+
+	if (security && path_len >= sizeof(".phar")-1 && !memcmp(path, ".phar", sizeof(".phar")-1)) {
+		if (error) {
+			spprintf(error, 4096, "phar error: cannot directly access magic \".phar\" directory or files within it");
+		}
+		return NULL;
+	}
+
+	if (!path_len && !dir) {
+		if (error) {
+			spprintf(error, 4096, "phar error: invalid path \"%s\" must not be empty", path);
+		}
+		return NULL;
+	}
+
+	if (phar_path_check(&path, &path_len, &pcr_error) > pcr_is_ok) {
+		if (error) {
+			spprintf(error, 4096, "phar error: invalid path \"%s\" contains %s", path, pcr_error);
+		}
+		return NULL;
+	}
+
+	if (!phar->manifest.arBuckets) {
+		return NULL;
+	}
+
+	if (is_dir) {
+		if (!path_len || path_len == 1) {
+			return NULL;
+		}
+		path_len--;
+	}
+
+	if (SUCCESS == zend_hash_find(&phar->manifest, path, path_len, (void**)&entry)) {
+		if (entry->is_deleted) {
+			/* entry is deleted, but has not been flushed to disk yet */
+			return NULL;
+		}
+		if (entry->is_dir && !dir) {
+			if (error) {
+				spprintf(error, 4096, "phar error: path \"%s\" is a directory", path);
+			}
+			return NULL;
+		}
+		if (!entry->is_dir && dir == 2) {
+			/* user requested a directory, we must return one */
+			if (error) {
+				spprintf(error, 4096, "phar error: path \"%s\" exists and is a not a directory", path);
+			}
+			return NULL;
+		}
+		return entry;
+	}
+
+	if (dir) {
+		if (zend_hash_exists(&phar->virtual_dirs, path, path_len)) {
+			/* a file or directory exists in a sub-directory of this path */
+			entry = (phar_entry_info *) ecalloc(1, sizeof(phar_entry_info));
+			/* this next line tells PharFileInfo->__destruct() to efree the filename */
+			entry->is_temp_dir = entry->is_dir = 1;
+			entry->filename = (char *) estrndup(path, path_len + 1);
+			entry->filename_len = path_len;
+			entry->phar = phar;
+			return entry;
+		}
+	}
+
+	if (phar->mounted_dirs.arBuckets && zend_hash_num_elements(&phar->mounted_dirs)) {
+		phar_zstr key;
+		char *str_key;
+		ulong unused;
+		uint keylen;
+
+		zend_hash_internal_pointer_reset(&phar->mounted_dirs);
+		while (FAILURE != zend_hash_has_more_elements(&phar->mounted_dirs)) {
+			if (HASH_KEY_NON_EXISTANT == zend_hash_get_current_key_ex(&phar->mounted_dirs, &key, &keylen, &unused, 0, NULL)) {
+				break;
+			}
+
+			PHAR_STR(key, str_key);
+
+			if ((int)keylen >= path_len || strncmp(str_key, path, keylen)) {
+				PHAR_STR_FREE(str_key);
+				continue;
+			} else {
+				char *test;
+				int test_len;
+				php_stream_statbuf ssb;
+
+				if (SUCCESS != zend_hash_find(&phar->manifest, str_key, keylen, (void **) &entry)) {
+					if (error) {
+						spprintf(error, 4096, "phar internal error: mounted path \"%s\" could not be retrieved from manifest", str_key);
+					}
+					PHAR_STR_FREE(str_key);
+					return NULL;
+				}
+
+				if (!entry->tmp || !entry->is_mounted) {
+					if (error) {
+						spprintf(error, 4096, "phar internal error: mounted path \"%s\" is not properly initialized as a mounted path", str_key);
+					}
+					PHAR_STR_FREE(str_key);
+					return NULL;
+				}
+				PHAR_STR_FREE(str_key);
+
+				test_len = spprintf(&test, MAXPATHLEN, "%s%s", entry->tmp, path + keylen);
+
+				if (SUCCESS != php_stream_stat_path(test, &ssb)) {
+					efree(test);
+					return NULL;
+				}
+
+				if (ssb.sb.st_mode & S_IFDIR && !dir) {
+					efree(test);
+					if (error) {
+						spprintf(error, 4096, "phar error: path \"%s\" is a directory", path);
+					}
+					return NULL;
+				}
+
+				if ((ssb.sb.st_mode & S_IFDIR) == 0 && dir) {
+					efree(test);
+					/* user requested a directory, we must return one */
+					if (error) {
+						spprintf(error, 4096, "phar error: path \"%s\" exists and is a not a directory", path);
+					}
+					return NULL;
+				}
+
+				/* mount the file just in time */
+				if (SUCCESS != phar_mount_entry(phar, test, test_len, path, path_len TSRMLS_CC)) {
+					efree(test);
+					if (error) {
+						spprintf(error, 4096, "phar error: path \"%s\" exists as file \"%s\" and could not be mounted", path, test);
+					}
+					return NULL;
+				}
+
+				efree(test);
+
+				if (SUCCESS != zend_hash_find(&phar->manifest, path, path_len, (void**)&entry)) {
+					if (error) {
+						spprintf(error, 4096, "phar error: path \"%s\" exists as file \"%s\" and could not be retrieved after being mounted", path, test);
+					}
+					return NULL;
+				}
+				return entry;
+			}
+		}
+	}
+
+	return NULL;
+}
+/* }}} */
+
+static const char hexChars[] = "0123456789ABCDEF";
+
+static int phar_hex_str(const char *digest, size_t digest_len, char **signature TSRMLS_DC) /* {{{ */
+{
+	int pos = -1;
+	size_t len = 0;
+
+	*signature = (char*)safe_pemalloc(digest_len, 2, 1, PHAR_G(persist));
+
+	for (; len < digest_len; ++len) {
+		(*signature)[++pos] = hexChars[((const unsigned char *)digest)[len] >> 4];
+		(*signature)[++pos] = hexChars[((const unsigned char *)digest)[len] & 0x0F];
+	}
+	(*signature)[++pos] = '\0';
+	return pos;
+}
+/* }}} */
+
+#ifndef PHAR_HAVE_OPENSSL
+static int phar_call_openssl_signverify(int is_sign, php_stream *fp, off_t end, char *key, int key_len, char **signature, int *signature_len TSRMLS_DC) /* {{{ */
+{
+	zend_fcall_info fci;
+	zend_fcall_info_cache fcc;
+	zval *zdata, *zsig, *zkey, *retval_ptr, **zp[3], *openssl;
+
+	MAKE_STD_ZVAL(zdata);
+	MAKE_STD_ZVAL(openssl);
+	ZVAL_STRINGL(openssl, is_sign ? "openssl_sign" : "openssl_verify", is_sign ? sizeof("openssl_sign")-1 : sizeof("openssl_verify")-1, 1);
+	MAKE_STD_ZVAL(zsig);
+	ZVAL_STRINGL(zsig, *signature, *signature_len, 1);
+	MAKE_STD_ZVAL(zkey);
+	ZVAL_STRINGL(zkey, key, key_len, 1);
+	zp[0] = &zdata;
+	zp[1] = &zsig;
+	zp[2] = &zkey;
+
+	php_stream_rewind(fp);
+	Z_TYPE_P(zdata) = IS_STRING;
+	Z_STRLEN_P(zdata) = end;
+
+#if PHP_MAJOR_VERSION > 5
+	if (end != (off_t) php_stream_copy_to_mem(fp, (void **) &(Z_STRVAL_P(zdata)), (size_t) end, 0)) {
+#else
+	if (end != (off_t) php_stream_copy_to_mem(fp, &(Z_STRVAL_P(zdata)), (size_t) end, 0)) {
+#endif
+		zval_dtor(zdata);
+		zval_dtor(zsig);
+		zval_dtor(zkey);
+		zval_dtor(openssl);
+		efree(openssl);
+		efree(zdata);
+		efree(zkey);
+		efree(zsig);
+		return FAILURE;
+	}
+
+#if PHP_VERSION_ID < 50300
+	if (FAILURE == zend_fcall_info_init(openssl, &fci, &fcc TSRMLS_CC)) {
+#else
+	if (FAILURE == zend_fcall_info_init(openssl, 0, &fci, &fcc, NULL, NULL TSRMLS_CC)) {
+#endif
+		zval_dtor(zdata);
+		zval_dtor(zsig);
+		zval_dtor(zkey);
+		zval_dtor(openssl);
+		efree(openssl);
+		efree(zdata);
+		efree(zkey);
+		efree(zsig);
+		return FAILURE;
+	}
+
+	fci.param_count = 3;
+	fci.params = zp;
+#if PHP_VERSION_ID < 50300
+	++(zdata->refcount);
+	if (!is_sign) {
+		++(zsig->refcount);
+	}
+	++(zkey->refcount);
+#else
+	Z_ADDREF_P(zdata);
+	if (is_sign) {
+		Z_SET_ISREF_P(zsig);
+	} else {
+		Z_ADDREF_P(zsig);
+	}
+	Z_ADDREF_P(zkey);
+#endif
+	fci.retval_ptr_ptr = &retval_ptr;
+
+	if (FAILURE == zend_call_function(&fci, &fcc TSRMLS_CC)) {
+		zval_dtor(zdata);
+		zval_dtor(zsig);
+		zval_dtor(zkey);
+		zval_dtor(openssl);
+		efree(openssl);
+		efree(zdata);
+		efree(zkey);
+		efree(zsig);
+		return FAILURE;
+	}
+
+	zval_dtor(openssl);
+	efree(openssl);
+#if PHP_VERSION_ID < 50300
+	--(zdata->refcount);
+	if (!is_sign) {
+		--(zsig->refcount);
+	}
+	--(zkey->refcount);
+#else
+	Z_DELREF_P(zdata);
+	if (is_sign) {
+		Z_UNSET_ISREF_P(zsig);
+	} else {
+		Z_DELREF_P(zsig);
+	}
+	Z_DELREF_P(zkey);
+#endif
+	zval_dtor(zdata);
+	efree(zdata);
+	zval_dtor(zkey);
+	efree(zkey);
+
+	switch (Z_TYPE_P(retval_ptr)) {
+		default:
+		case IS_LONG:
+			zval_dtor(zsig);
+			efree(zsig);
+			if (1 == Z_LVAL_P(retval_ptr)) {
+				efree(retval_ptr);
+				return SUCCESS;
+			}
+			efree(retval_ptr);
+			return FAILURE;
+		case IS_BOOL:
+			efree(retval_ptr);
+			if (Z_BVAL_P(retval_ptr)) {
+				*signature = estrndup(Z_STRVAL_P(zsig), Z_STRLEN_P(zsig));
+				*signature_len = Z_STRLEN_P(zsig);
+				zval_dtor(zsig);
+				efree(zsig);
+				return SUCCESS;
+			}
+			zval_dtor(zsig);
+			efree(zsig);
+			return FAILURE;
+	}
+}
+/* }}} */
+#endif /* #ifndef PHAR_HAVE_OPENSSL */
+
+int phar_verify_signature(php_stream *fp, size_t end_of_phar, php_uint32 sig_type, char *sig, int sig_len, char *fname, char **signature, int *signature_len, char **error TSRMLS_DC) /* {{{ */
+{
+	int read_size, len;
+	off_t read_len;
+	unsigned char buf[1024];
+
+	php_stream_rewind(fp);
+
+	switch (sig_type) {
+		case PHAR_SIG_OPENSSL: {
+#ifdef PHAR_HAVE_OPENSSL
+			BIO *in;
+			EVP_PKEY *key;
+			EVP_MD *mdtype = (EVP_MD *) EVP_sha1();
+			EVP_MD_CTX md_ctx;
+#else
+			int tempsig;
+#endif
+			php_uint32 pubkey_len;
+			char *pubkey = NULL, *pfile;
+			php_stream *pfp;
+#ifndef PHAR_HAVE_OPENSSL
+			if (!zend_hash_exists(&module_registry, "openssl", sizeof("openssl"))) {
+				if (error) {
+					spprintf(error, 0, "openssl not loaded");
+				}
+				return FAILURE;
+			}
+#endif
+			/* use __FILE__ . '.pubkey' for public key file */
+			spprintf(&pfile, 0, "%s.pubkey", fname);
+			pfp = php_stream_open_wrapper(pfile, "rb", 0, NULL);
+			efree(pfile);
+
+#if PHP_MAJOR_VERSION > 5
+			if (!pfp || !(pubkey_len = php_stream_copy_to_mem(pfp, (void **) &pubkey, PHP_STREAM_COPY_ALL, 0)) || !pubkey) {
+#else
+			if (!pfp || !(pubkey_len = php_stream_copy_to_mem(pfp, &pubkey, PHP_STREAM_COPY_ALL, 0)) || !pubkey) {
+#endif
+				if (pfp) {
+					php_stream_close(pfp);
+				}
+				if (error) {
+					spprintf(error, 0, "openssl public key could not be read");
+				}
+				return FAILURE;
+			}
+
+			php_stream_close(pfp);
+#ifndef PHAR_HAVE_OPENSSL
+			tempsig = sig_len;
+
+			if (FAILURE == phar_call_openssl_signverify(0, fp, end_of_phar, pubkey, pubkey_len, &sig, &tempsig TSRMLS_CC)) {
+				if (pubkey) {
+					efree(pubkey);
+				}
+
+				if (error) {
+					spprintf(error, 0, "openssl signature could not be verified");
+				}
+
+				return FAILURE;
+			}
+
+			if (pubkey) {
+				efree(pubkey);
+			}
+
+			sig_len = tempsig;
+#else
+			in = BIO_new_mem_buf(pubkey, pubkey_len);
+
+			if (NULL == in) {
+				efree(pubkey);
+				if (error) {
+					spprintf(error, 0, "openssl signature could not be processed");
+				}
+				return FAILURE;
+			}
+
+			key = PEM_read_bio_PUBKEY(in, NULL,NULL, NULL);
+			BIO_free(in);
+			efree(pubkey);
+
+			if (NULL == key) {
+				if (error) {
+					spprintf(error, 0, "openssl signature could not be processed");
+				}
+				return FAILURE;
+			}
+
+			EVP_VerifyInit(&md_ctx, mdtype);
+			read_len = end_of_phar;
+
+			if (read_len > sizeof(buf)) {
+				read_size = sizeof(buf);
+			} else {
+				read_size = (int)read_len;
+			}
+
+			php_stream_seek(fp, 0, SEEK_SET);
+
+			while (read_size && (len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
+				EVP_VerifyUpdate (&md_ctx, buf, len);
+				read_len -= (off_t)len;
+
+				if (read_len < read_size) {
+					read_size = (int)read_len;
+				}
+			}
+
+			if (EVP_VerifyFinal(&md_ctx, (unsigned char *)sig, sig_len, key) != 1) {
+				/* 1: signature verified, 0: signature does not match, -1: failed signature operation */
+				EVP_MD_CTX_cleanup(&md_ctx);
+
+				if (error) {
+					spprintf(error, 0, "broken openssl signature");
+				}
+
+				return FAILURE;
+			}
+
+			EVP_MD_CTX_cleanup(&md_ctx);
+#endif
+
+			*signature_len = phar_hex_str((const char*)sig, sig_len, signature TSRMLS_CC);
+		}
+		break;
+#ifdef PHAR_HASH_OK
+		case PHAR_SIG_SHA512: {
+			unsigned char digest[64];
+			PHP_SHA512_CTX context;
+
+			PHP_SHA512Init(&context);
+			read_len = end_of_phar;
+
+			if (read_len > sizeof(buf)) {
+				read_size = sizeof(buf);
+			} else {
+				read_size = (int)read_len;
+			}
+
+			while ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
+				PHP_SHA512Update(&context, buf, len);
+				read_len -= (off_t)len;
+				if (read_len < read_size) {
+					read_size = (int)read_len;
+				}
+			}
+
+			PHP_SHA512Final(digest, &context);
+
+			if (memcmp(digest, sig, sizeof(digest))) {
+				if (error) {
+					spprintf(error, 0, "broken signature");
+				}
+				return FAILURE;
+			}
+
+			*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature TSRMLS_CC);
+			break;
+		}
+		case PHAR_SIG_SHA256: {
+			unsigned char digest[32];
+			PHP_SHA256_CTX context;
+
+			PHP_SHA256Init(&context);
+			read_len = end_of_phar;
+
+			if (read_len > sizeof(buf)) {
+				read_size = sizeof(buf);
+			} else {
+				read_size = (int)read_len;
+			}
+
+			while ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
+				PHP_SHA256Update(&context, buf, len);
+				read_len -= (off_t)len;
+				if (read_len < read_size) {
+					read_size = (int)read_len;
+				}
+			}
+
+			PHP_SHA256Final(digest, &context);
+
+			if (memcmp(digest, sig, sizeof(digest))) {
+				if (error) {
+					spprintf(error, 0, "broken signature");
+				}
+				return FAILURE;
+			}
+
+			*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature TSRMLS_CC);
+			break;
+		}
+#else
+		case PHAR_SIG_SHA512:
+		case PHAR_SIG_SHA256:
+			if (error) {
+				spprintf(error, 0, "unsupported signature");
+			}
+			return FAILURE;
+#endif
+		case PHAR_SIG_SHA1: {
+			unsigned char digest[20];
+			PHP_SHA1_CTX  context;
+
+			PHP_SHA1Init(&context);
+			read_len = end_of_phar;
+
+			if (read_len > sizeof(buf)) {
+				read_size = sizeof(buf);
+			} else {
+				read_size = (int)read_len;
+			}
+
+			while ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
+				PHP_SHA1Update(&context, buf, len);
+				read_len -= (off_t)len;
+				if (read_len < read_size) {
+					read_size = (int)read_len;
+				}
+			}
+
+			PHP_SHA1Final(digest, &context);
+
+			if (memcmp(digest, sig, sizeof(digest))) {
+				if (error) {
+					spprintf(error, 0, "broken signature");
+				}
+				return FAILURE;
+			}
+
+			*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature TSRMLS_CC);
+			break;
+		}
+		case PHAR_SIG_MD5: {
+			unsigned char digest[16];
+			PHP_MD5_CTX   context;
+
+			PHP_MD5Init(&context);
+			read_len = end_of_phar;
+
+			if (read_len > sizeof(buf)) {
+				read_size = sizeof(buf);
+			} else {
+				read_size = (int)read_len;
+			}
+
+			while ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {
+				PHP_MD5Update(&context, buf, len);
+				read_len -= (off_t)len;
+				if (read_len < read_size) {
+					read_size = (int)read_len;
+				}
+			}
+
+			PHP_MD5Final(digest, &context);
+
+			if (memcmp(digest, sig, sizeof(digest))) {
+				if (error) {
+					spprintf(error, 0, "broken signature");
+				}
+				return FAILURE;
+			}
+
+			*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature TSRMLS_CC);
+			break;
+		}
+		default:
+			if (error) {
+				spprintf(error, 0, "broken or unsupported signature");
+			}
+			return FAILURE;
+	}
+	return SUCCESS;
+}
+/* }}} */
+
+int phar_create_signature(phar_archive_data *phar, php_stream *fp, char **signature, int *signature_length, char **error TSRMLS_DC) /* {{{ */
+{
+	unsigned char buf[1024];
+	int sig_len;
+
+	php_stream_rewind(fp);
+
+	if (phar->signature) {
+		efree(phar->signature);
+		phar->signature = NULL;
+	}
+
+	switch(phar->sig_flags) {
+#ifdef PHAR_HASH_OK
+		case PHAR_SIG_SHA512: {
+			unsigned char digest[64];
+			PHP_SHA512_CTX context;
+
+			PHP_SHA512Init(&context);
+
+			while ((sig_len = php_stream_read(fp, (char*)buf, sizeof(buf))) > 0) {
+				PHP_SHA512Update(&context, buf, sig_len);
+			}
+
+			PHP_SHA512Final(digest, &context);
+			*signature = estrndup((char *) digest, 64);
+			*signature_length = 64;
+			break;
+		}
+		case PHAR_SIG_SHA256: {
+			unsigned char digest[32];
+			PHP_SHA256_CTX  context;
+
+			PHP_SHA256Init(&context);
+
+			while ((sig_len = php_stream_read(fp, (char*)buf, sizeof(buf))) > 0) {
+				PHP_SHA256Update(&context, buf, sig_len);
+			}
+
+			PHP_SHA256Final(digest, &context);
+			*signature = estrndup((char *) digest, 32);
+			*signature_length = 32;
+			break;
+		}
+#else
+		case PHAR_SIG_SHA512:
+		case PHAR_SIG_SHA256:
+			if (error) {
+				spprintf(error, 0, "unable to write to phar \"%s\" with requested hash type", phar->fname);
+			}
+
+			return FAILURE;
+#endif
+		case PHAR_SIG_OPENSSL: {
+			int siglen;
+			unsigned char *sigbuf;
+#ifdef PHAR_HAVE_OPENSSL
+			BIO *in;
+			EVP_PKEY *key;
+			EVP_MD_CTX *md_ctx;
+
+			in = BIO_new_mem_buf(PHAR_G(openssl_privatekey), PHAR_G(openssl_privatekey_len));
+
+			if (in == NULL) {
+				if (error) {
+					spprintf(error, 0, "unable to write to phar \"%s\" with requested openssl signature", phar->fname);
+				}
+				return FAILURE;
+			}
+
+			key = PEM_read_bio_PrivateKey(in, NULL,NULL, "");
+			BIO_free(in);
+
+			if (!key) {
+				if (error) {
+					spprintf(error, 0, "unable to process private key");
+				}
+				return FAILURE;
+			}
+
+			md_ctx = EVP_MD_CTX_create();
+
+			siglen = EVP_PKEY_size(key);
+			sigbuf = emalloc(siglen + 1);
+
+			if (!EVP_SignInit(md_ctx, EVP_sha1())) {
+				efree(sigbuf);
+				if (error) {
+					spprintf(error, 0, "unable to initialize openssl signature for phar \"%s\"", phar->fname);
+				}
+				return FAILURE;
+			}
+
+			while ((sig_len = php_stream_read(fp, (char*)buf, sizeof(buf))) > 0) {
+				if (!EVP_SignUpdate(md_ctx, buf, sig_len)) {
+					efree(sigbuf);
+					if (error) {
+						spprintf(error, 0, "unable to update the openssl signature for phar \"%s\"", phar->fname);
+					}
+					return FAILURE;
+				}
+			}
+
+			if (!EVP_SignFinal (md_ctx, sigbuf,(unsigned int *)&siglen, key)) {
+				efree(sigbuf);
+				if (error) {
+					spprintf(error, 0, "unable to write phar \"%s\" with requested openssl signature", phar->fname);
+				}
+				return FAILURE;
+			}
+
+			sigbuf[siglen] = '\0';
+			EVP_MD_CTX_destroy(md_ctx);
+#else
+			sigbuf = NULL;
+			siglen = 0;
+			php_stream_seek(fp, 0, SEEK_END);
+
+			if (FAILURE == phar_call_openssl_signverify(1, fp, php_stream_tell(fp), PHAR_G(openssl_privatekey), PHAR_G(openssl_privatekey_len), (char **)&sigbuf, &siglen TSRMLS_CC)) {
+				if (error) {
+					spprintf(error, 0, "unable to write phar \"%s\" with requested openssl signature", phar->fname);
+				}
+				return FAILURE;
+			}
+#endif
+			*signature = (char *) sigbuf;
+			*signature_length = siglen;
+		}
+		break;
+		default:
+			phar->sig_flags = PHAR_SIG_SHA1;
+		case PHAR_SIG_SHA1: {
+			unsigned char digest[20];
+			PHP_SHA1_CTX  context;
+
+			PHP_SHA1Init(&context);
+
+			while ((sig_len = php_stream_read(fp, (char*)buf, sizeof(buf))) > 0) {
+				PHP_SHA1Update(&context, buf, sig_len);
+			}
+
+			PHP_SHA1Final(digest, &context);
+			*signature = estrndup((char *) digest, 20);
+			*signature_length = 20;
+			break;
+		}
+		case PHAR_SIG_MD5: {
+			unsigned char digest[16];
+			PHP_MD5_CTX   context;
+
+			PHP_MD5Init(&context);
+
+			while ((sig_len = php_stream_read(fp, (char*)buf, sizeof(buf))) > 0) {
+				PHP_MD5Update(&context, buf, sig_len);
+			}
+
+			PHP_MD5Final(digest, &context);
+			*signature = estrndup((char *) digest, 16);
+			*signature_length = 16;
+			break;
+		}
+	}
+
+	phar->sig_len = phar_hex_str((const char *)*signature, *signature_length, &phar->signature TSRMLS_CC);
+	return SUCCESS;
+}
+/* }}} */
+
+void phar_add_virtual_dirs(phar_archive_data *phar, char *filename, int filename_len TSRMLS_DC) /* {{{ */
+{
+	char *s;
+
+	while ((s = zend_memrchr(filename, '/', filename_len))) {
+		filename_len = s - filename;
+		if (FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) {
+			break;
+		}
+	}
+}
+/* }}} */
+
+static int phar_update_cached_entry(void *data, void *argument) /* {{{ */
+{
+	phar_entry_info *entry = (phar_entry_info *)data;
+	TSRMLS_FETCH();
+
+	entry->phar = (phar_archive_data *)argument;
+
+	if (entry->link) {
+		entry->link = estrdup(entry->link);
+	}
+
+	if (entry->tmp) {
+		entry->tmp = estrdup(entry->tmp);
+	}
+
+	entry->metadata_str.c = 0;
+	entry->filename = estrndup(entry->filename, entry->filename_len);
+	entry->is_persistent = 0;
+
+	if (entry->metadata) {
+		if (entry->metadata_len) {
+			char *buf = estrndup((char *) entry->metadata, entry->metadata_len);
+			/* assume success, we would have failed before */
+			phar_parse_metadata((char **) &buf, &entry->metadata, entry->metadata_len TSRMLS_CC);
+			efree(buf);
+		} else {
+			zval *t;
+
+			t = entry->metadata;
+			ALLOC_ZVAL(entry->metadata);
+			*entry->metadata = *t;
+			zval_copy_ctor(entry->metadata);
+#if PHP_VERSION_ID < 50300
+			entry->metadata->refcount = 1;
+#else
+			Z_SET_REFCOUNT_P(entry->metadata, 1);
+#endif
+			entry->metadata_str.c = NULL;
+			entry->metadata_str.len = 0;
+		}
+	}
+	return ZEND_HASH_APPLY_KEEP;
+}
+/* }}} */
+
+static void phar_copy_cached_phar(phar_archive_data **pphar TSRMLS_DC) /* {{{ */
+{
+	phar_archive_data *phar;
+	HashTable newmanifest;
+	char *fname;
+	phar_archive_object **objphar;
+
+	phar = (phar_archive_data *) emalloc(sizeof(phar_archive_data));
+	*phar = **pphar;
+	phar->is_persistent = 0;
+	fname = phar->fname;
+	phar->fname = estrndup(phar->fname, phar->fname_len);
+	phar->ext = phar->fname + (phar->ext - fname);
+
+	if (phar->alias) {
+		phar->alias = estrndup(phar->alias, phar->alias_len);
+	}
+
+	if (phar->signature) {
+		phar->signature = estrdup(phar->signature);
+	}
+
+	if (phar->metadata) {
+		/* assume success, we would have failed before */
+		if (phar->metadata_len) {
+			char *buf = estrndup((char *) phar->metadata, phar->metadata_len);
+			phar_parse_metadata(&buf, &phar->metadata, phar->metadata_len TSRMLS_CC);
+			efree(buf);
+		} else {
+			zval *t;
+
+			t = phar->metadata;
+			ALLOC_ZVAL(phar->metadata);
+			*phar->metadata = *t;
+			zval_copy_ctor(phar->metadata);
+#if PHP_VERSION_ID < 50300
+			phar->metadata->refcount = 1;
+#else
+			Z_SET_REFCOUNT_P(phar->metadata, 1);
+#endif
+		}
+	}
+
+	zend_hash_init(&newmanifest, sizeof(phar_entry_info),
+		zend_get_hash_value, destroy_phar_manifest_entry, 0);
+	zend_hash_copy(&newmanifest, &(*pphar)->manifest, NULL, NULL, sizeof(phar_entry_info));
+	zend_hash_apply_with_argument(&newmanifest, (apply_func_arg_t) phar_update_cached_entry, (void *)phar TSRMLS_CC);
+	phar->manifest = newmanifest;
+	zend_hash_init(&phar->mounted_dirs, sizeof(char *),
+		zend_get_hash_value, NULL, 0);
+	zend_hash_init(&phar->virtual_dirs, sizeof(char *),
+		zend_get_hash_value, NULL, 0);
+	zend_hash_copy(&phar->virtual_dirs, &(*pphar)->virtual_dirs, NULL, NULL, sizeof(void *));
+	*pphar = phar;
+
+	/* now, scan the list of persistent Phar objects referencing this phar and update the pointers */
+	for (zend_hash_internal_pointer_reset(&PHAR_GLOBALS->phar_persist_map);
+	SUCCESS == zend_hash_get_current_data(&PHAR_GLOBALS->phar_persist_map, (void **) &objphar);
+	zend_hash_move_forward(&PHAR_GLOBALS->phar_persist_map)) {
+		if (objphar[0]->arc.archive->fname_len == phar->fname_len && !memcmp(objphar[0]->arc.archive->fname, phar->fname, phar->fname_len)) {
+			objphar[0]->arc.archive = phar;
+		}
+	}
+}
+/* }}} */
+
+int phar_copy_on_write(phar_archive_data **pphar TSRMLS_DC) /* {{{ */
+{
+	phar_archive_data **newpphar, *newphar = NULL;
+
+	if (SUCCESS != zend_hash_add(&(PHAR_GLOBALS->phar_fname_map), (*pphar)->fname, (*pphar)->fname_len, (void *)&newphar, sizeof(phar_archive_data *), (void **)&newpphar)) {
+		return FAILURE;
+	}
+
+	*newpphar = *pphar;
+	phar_copy_cached_phar(newpphar TSRMLS_CC);
+	/* invalidate phar cache */
+	PHAR_G(last_phar) = NULL;
+	PHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;
+
+	if (newpphar[0]->alias_len && FAILURE == zend_hash_add(&(PHAR_GLOBALS->phar_alias_map), newpphar[0]->alias, newpphar[0]->alias_len, (void*)newpphar, sizeof(phar_archive_data*), NULL)) {
+		zend_hash_del(&(PHAR_GLOBALS->phar_fname_map), (*pphar)->fname, (*pphar)->fname_len);
+		return FAILURE;
+	}
+
+	*pphar = *newpphar;
+	return SUCCESS;
+}
+/* }}} */
+
+/*
+ * Local variables:
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ * vim600: noet sw=4 ts=4 fdm=marker
+ * vim<600: noet sw=4 ts=4
+ */
diff -uNr php-5.3.29-ori/main/php_streams.h php-5.3.29/main/php_streams.h
--- php-5.3.29-ori/main/php_streams.h	2019-01-25 02:38:50.548562215 +0800
+++ php-5.3.29/main/php_streams.h	2019-01-26 13:38:59.870164530 +0800
@@ -292,6 +292,9 @@
 #define php_stream_write_string(stream, str)	_php_stream_write(stream, str, strlen(str) TSRMLS_CC)
 #define php_stream_write(stream, buf, count)	_php_stream_write(stream, (buf), (count) TSRMLS_CC)
 
+PHPAPI void _php_stream_fill_read_buffer(php_stream *stream, size_t size TSRMLS_DC);
+#define php_stream_fill_read_buffer(stream, size)	_php_stream_fill_read_buffer((stream), (size) TSRMLS_CC)
+
 #ifdef ZTS
 PHPAPI size_t _php_stream_printf(php_stream *stream TSRMLS_DC, const char *fmt, ...) PHP_ATTRIBUTE_FORMAT(printf, 3, 4);
 #else
diff -uNr php-5.3.29-ori/main/streams/php_stream_transport.h php-5.3.29/main/streams/php_stream_transport.h
--- php-5.3.29-ori/main/streams/php_stream_transport.h	2019-01-25 02:38:50.548562215 +0800
+++ php-5.3.29/main/streams/php_stream_transport.h	2019-01-26 11:30:29.587468979 +0800
@@ -166,14 +166,28 @@
 
 /* These functions provide crypto support on the underlying transport */
 typedef enum {
-	STREAM_CRYPTO_METHOD_SSLv2_CLIENT,
-	STREAM_CRYPTO_METHOD_SSLv3_CLIENT,
-	STREAM_CRYPTO_METHOD_SSLv23_CLIENT,
-	STREAM_CRYPTO_METHOD_TLS_CLIENT,
-	STREAM_CRYPTO_METHOD_SSLv2_SERVER,
-	STREAM_CRYPTO_METHOD_SSLv3_SERVER,
-	STREAM_CRYPTO_METHOD_SSLv23_SERVER,
-	STREAM_CRYPTO_METHOD_TLS_SERVER
+	STREAM_CRYPTO_METHOD_SSLv2_CLIENT = (1 << 1 | 1),
+	STREAM_CRYPTO_METHOD_SSLv3_CLIENT = (1 << 2 | 1),
+	/* v23 no longer negotiates SSL2 or SSL3 */
+	STREAM_CRYPTO_METHOD_SSLv23_CLIENT = ((1 << 3) | (1 << 4) | (1 << 5) | 1),
+	STREAM_CRYPTO_METHOD_TLSv1_0_CLIENT = (1 << 3 | 1),
+	STREAM_CRYPTO_METHOD_TLSv1_1_CLIENT = (1 << 4 | 1),
+	STREAM_CRYPTO_METHOD_TLSv1_2_CLIENT = (1 << 5 | 1),
+	/* tls now equates only to the specific TLSv1 method for BC with pre-5.6 */
+	STREAM_CRYPTO_METHOD_TLS_CLIENT = (1 << 3 | 1),
+	STREAM_CRYPTO_METHOD_TLS_ANY_CLIENT = ((1 << 3) | (1 << 4) | (1 << 5) | 1),
+	STREAM_CRYPTO_METHOD_ANY_CLIENT = ((1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5) | 1),
+	STREAM_CRYPTO_METHOD_SSLv2_SERVER = (1 << 1),
+	STREAM_CRYPTO_METHOD_SSLv3_SERVER = (1 << 2),
+	/* v23 no longer negotiates SSL2 or SSL3 */
+	STREAM_CRYPTO_METHOD_SSLv23_SERVER = ((1 << 3) | (1 << 4) | (1 << 5)),
+	STREAM_CRYPTO_METHOD_TLSv1_0_SERVER = (1 << 3),
+	STREAM_CRYPTO_METHOD_TLSv1_1_SERVER = (1 << 4),
+	STREAM_CRYPTO_METHOD_TLSv1_2_SERVER = (1 << 5),
+	/* tls equates only to the specific TLSv1 method for BC with pre-5.6 */
+	STREAM_CRYPTO_METHOD_TLS_SERVER = (1 << 3),
+	STREAM_CRYPTO_METHOD_TLS_ANY_SERVER = ((1 << 3) | (1 << 4) | (1 << 5)),
+	STREAM_CRYPTO_METHOD_ANY_SERVER = ((1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5))
 } php_stream_xport_crypt_method_t;
 
 BEGIN_EXTERN_C()
diff -uNr php-5.3.29-ori/main/streams/streams.c php-5.3.29/main/streams/streams.c
--- php-5.3.29-ori/main/streams/streams.c	2019-01-25 02:38:50.548562215 +0800
+++ php-5.3.29/main/streams/streams.c	2019-01-26 14:04:33.140640693 +0800
@@ -502,7 +502,7 @@
 
 /* {{{ generic stream operations */
 
-static void php_stream_fill_read_buffer(php_stream *stream, size_t size TSRMLS_DC)
+PHPAPI void _php_stream_fill_read_buffer(php_stream *stream, size_t size TSRMLS_DC)
 {
 	/* allocate/fill the buffer */
 
