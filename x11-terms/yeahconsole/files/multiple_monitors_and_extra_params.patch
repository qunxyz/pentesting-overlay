diff -uNr yeahconsole-0.3.4-ori/yeahconsole.c yeahconsole-0.3.4/yeahconsole.c
--- yeahconsole-0.3.4-ori/yeahconsole.c	2020-04-13 06:43:52.071867736 +0800
+++ yeahconsole-0.3.4/yeahconsole.c	2020-04-13 06:40:23.276998000 +0800
@@ -29,28 +29,46 @@
 #include <X11/keysym.h>
 #include <X11/Xutil.h>
 #include <X11/cursorfont.h>
+#include <X11/extensions/XInput2.h>
+#include <X11/extensions/Xinerama.h>
+#include <pthread.h>
 #include <unistd.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
-
+#define DEBUG False
 #define UP 0
-#define DOWN -height -opt_bw
-#define transparency_hack() XResizeWindow(dpy, termwin, opt_width, height -1);\
-		            XResizeWindow(dpy, termwin, opt_width, height )
+#define DOWN -height - opt_bw
+// #define transparency_hack()                           \
+// 	XResizeWindow(dpy, termwin, opt_width, height - 1); \
+// 	XResizeWindow(dpy, termwin, opt_width, height)
+#define transparency_hack()                           \
+	XResizeWindow(dpy, termwin, opt_width, height)
+
+struct ScreenInfo 
+{ 
+   int index; 
+	 int width;
+	 int height;
+	 Bool show;
+};  
 
+struct ScreenInfo screens[64]; 
 Display *dpy;
 Window root;
 Window win;
 Window termwin;
-char *progname, command[256];
+pthread_t check_mouse_screen_thread, check_working_window_events_thread;
+int current_screen_index = 0;
+char *progname, command[512];
 int revert_to;
 int screen;
 int opt_x, opt_width, opt_height, opt_delay, opt_bw, opt_step,
-    height, opt_restart;
+		height, opt_restart, opt_restart_hidden;
 char *opt_color;
 char *opt_term;
+char *opt_term_extra_params;
 KeySym opt_key;
 KeySym opt_key_smaller;
 KeySym opt_key_bigger;
@@ -64,366 +82,609 @@
 void init_xterm(int move);
 void init_command(int argc, char *argv[]);
 void resize(void);
-int handle_xerror(Display * display, XErrorEvent * e);
+int handle_xerror(Display *display, XErrorEvent *e);
 
-int main(int argc, char *argv[])
+/* Return 1 if XI2 is available, 0 otherwise */
+static int has_xi2(Display *dpy)
 {
-    KeySym key;
-    XEvent event;
-    int hidden = 1;
-    int fullscreen = 0;
-    int i, old_height;
-    Window last_focused, current_focused;
-	
-    /* strip the path from argv[0] if there is one */
-    progname = strrchr(argv[0], '/');
-    if (!progname)
-	progname = argv[0];
-    else
-	progname++;
-
-    for (i = 1; i < argc; i++) {
-	if (!strcmp(argv[i], "-h") )
-	{
-	    printf("%s:\n"
-		   "-e: program to execute\n"
-		   "you can configure me via xresources:\n"
-		   "%s*foo:value\n"
-		   "foo can be any standard xterm/urxvt xresource or:\n"
-		   "resource               default value\n\n"
-		   "term:                  xterm\n"
-		   "restart:               0\n"
-		   "xOffset:               0\n"
-		   "screenWidth:           Display width\n"
-		   "consoleHeight:         10\n"
-		   "aniDelay:              40\n"
-		   "stepSize;              1\n"
-		   "toggleKey:             ControlAlt+y\n"
-		   "keySmaller:            Control+KP_Subtract\n"
-		   "keyBigger:             Control+KP_Add\n"
-		   "keyFull:               Alt+F11\n", progname, progname);
-	    exit(0);
-	}
-    }
-
-    if (!(dpy = XOpenDisplay(NULL))) {
-	fprintf(stderr, " can not open dpy %s", XDisplayName(NULL));
-    }
-    screen = DefaultScreen(dpy);
-    root = RootWindow(dpy, screen);
-    XSetErrorHandler(handle_xerror);
-    cursor = XCreateFontCursor(dpy, XC_double_arrow);
-    get_defaults();
-    init_win();
-    init_command(argc, argv);
-    init_xterm(1);
-    while (1) {
-	XNextEvent(dpy, &event);
-	switch (event.type) {
-	case EnterNotify:
-	    XSetInputFocus(dpy, termwin, RevertToPointerRoot, CurrentTime);
-	    break;
-	case LeaveNotify:
-	    if (last_focused && event.xcrossing.detail != NotifyInferior)
-		XSetInputFocus(dpy, last_focused, RevertToPointerRoot,
-			       CurrentTime);
-	    break;
-	case KeyPress:
-	    key = XKeycodeToKeysym(dpy, event.xkey.keycode, 0);
-	    if (key == opt_key) {
-		if (!hidden) {
-		    XGetInputFocus(dpy, &current_focused, &revert_to);
-		    if (last_focused && current_focused == termwin)
-			XSetInputFocus(dpy, last_focused,
-				       RevertToPointerRoot, CurrentTime);
-		    /* else
-		       XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime); */
-		    if (opt_step && !fullscreen)
-			roll(UP);
-		    XMoveWindow(dpy, win, opt_x, -height - opt_bw);
-		    hidden = 1;
-		    XSync(dpy, False);
-		} else {
-		    XRaiseWindow(dpy, win);
-		    XGetInputFocus(dpy, &last_focused, &revert_to);
-		    XSetInputFocus(dpy, termwin, RevertToPointerRoot,
-				   CurrentTime);
-
-		    if (opt_step && !fullscreen) {
-			XGrabServer(dpy);
-			roll(DOWN);
-			XUngrabServer(dpy);
-		    }
-		    XMoveWindow(dpy, win, opt_x, 0);
+	int major, minor;
+	int rc;
+
+	/* We support XI 2.2 */
+	major = 2;
+	minor = 2;
+
+	rc = XIQueryVersion(dpy, &major, &minor);
+	if (rc == BadRequest)
+	{
+		printf("No XI2 support. Server supports version %d.%d only.\n", major, minor);
+		return 0;
+	}
+	else if (rc != Success)
+	{
+		fprintf(stderr, "Internal Error! This is a bug in Xlib.\n");
+	}
+
+	printf("XI2 supported. Server provides version %d.%d.\n", major, minor);
 
-		    transparency_hack();
-		    hidden = 0;
+	return 1;
+}
+
+void init_screens()
+{
+	Display *d = XOpenDisplay(NULL);
+	if (d)
+	{
+		int dummy1, dummy2;
+		if (XineramaQueryExtension(d, &dummy1, &dummy2))
+		{
+			if (XineramaIsActive(d))
+			{
+				int heads = 0;
+				XineramaScreenInfo *p = XineramaQueryScreens(d, &heads);
+				if (heads > 0)
+				{
+					for (int x = 0; x < heads; ++x)
+					{
+						screens[x].index = x;
+						screens[x].width = p[x].width;
+						screens[x].height = p[x].height;
+						screens[x].show = False;
+						if (DEBUG)
+						{
+							printf("Head %d of %d\n", x + 1, heads);
+							printf("width: %d height: %d\n", p[x].width, p[x].height);
+						}
+					}
+				}
+				else
+					printf("XineramaQueryScreens says there aren't any");
+				XFree(p);
+			}
+			else
+				printf("Xinerama not active");
 		}
-		break;
-	    }
-	    if (!hidden) {
-		if (key == opt_key_full) {
-		    if (!fullscreen) {
-			old_height = height;
-			height = DisplayHeight(dpy, screen);
-			fullscreen = 1;
-		    } else {
-			height = old_height;
-			fullscreen = 0;
-		    }
+		else
+			printf("No Xinerama extension");
+		XCloseDisplay(d);
+	}
+	else
+		printf("Can't open display");
+}
+
+static void select_events(Display *dpy, Window win)
+{
+	XIEventMask evmasks[1];
+	unsigned char mask1[(XI_LASTEVENT + 7) / 8];
+
+	memset(mask1, 0, sizeof(mask1));
+
+	/* select for button and key events from all master devices */
+	XISetMask(mask1, XI_RawMotion);
+
+	evmasks[0].deviceid = XIAllMasterDevices;
+	evmasks[0].mask_len = sizeof(mask1);
+	evmasks[0].mask = mask1;
+
+	XISelectEvents(dpy, win, evmasks, 1);
+	XFlush(dpy);
+}
+
+void check_mouse_screen()
+{
+	Display *dpy;
+	int xi_opcode, event, error;
+	XEvent ev;
+
+	dpy = XOpenDisplay(NULL);
+
+	if (!dpy)
+	{
+		fprintf(stderr, "Failed to open display.\n");
+		return;
+	}
+
+	if (!XQueryExtension(dpy, "XInputExtension", &xi_opcode, &event, &error))
+	{
+		printf("X Input extension not available.\n");
+		return;
+	}
+
+	if (!has_xi2(dpy))
+		return;
+
+	/* select for XI2 events */
+	select_events(dpy, DefaultRootWindow(dpy));
+
+	while (1)
+	{
+		XGenericEventCookie *cookie = &ev.xcookie;
+		XIRawEvent *re;
+		Window root_ret, child_ret;
+		int root_x, root_y;
+		int win_x, win_y;
+		unsigned int mask;
+
+		XNextEvent(dpy, &ev);
+
+		if (cookie->type != GenericEvent ||
+				cookie->extension != xi_opcode ||
+				!XGetEventData(dpy, cookie))
+			continue;
+
+		switch (cookie->evtype)
+		{
+		case XI_RawMotion:
+			re = (XIRawEvent *)cookie->data;
+			XQueryPointer(dpy, DefaultRootWindow(dpy),
+										&root_ret, &child_ret, &root_x, &root_y, &win_x, &win_y, &mask);
+			if (DEBUG)
+				printf("raw %g,%g root %d,%d\n",
+							re->raw_values[0], re->raw_values[1],
+							root_x, root_y);
+
+			int i = 0;
+			struct ScreenInfo* screenPtr = screens;
+			while (screenPtr + i != NULL)
+			{
+				int mouse_offset = root_x;
+				for (int j = 0; j < i + 1; j++)
+					mouse_offset -= (*(screenPtr + j)).width;
+				if (DEBUG)
+					printf("mouse current offset: %d\n", mouse_offset);
+				if (mouse_offset < 0)
+				{
+					current_screen_index = i;
+					if (DEBUG)
+						printf("mouse current position: %d\n", current_screen_index);
+					break;
+				}
+				i++;
+			}
+			break;
+		}
+		XFreeEventData(dpy, cookie);
+	}
+}
+
+void check_working_window_events()
+{
+	int fullscreen = 0;
+	KeySym key;
+	XEvent event;
+	int hidden = 1;
+	Window last_focused, current_focused;
+	int old_height = 0;
+
+	while (1)
+	{
+		XNextEvent(dpy, &event);
+		switch (event.type)
+		{
+		case EnterNotify:
+			XSetInputFocus(dpy, termwin, RevertToPointerRoot, CurrentTime);
+			break;
+		case LeaveNotify:
+			if (last_focused && event.xcrossing.detail != NotifyInferior)
+				XSetInputFocus(dpy, last_focused, RevertToPointerRoot,
+											 CurrentTime);
+			break;
+		case KeyPress:
+			key = XKeycodeToKeysym(dpy, event.xkey.keycode, 0);
+			if (key == opt_key)
+			{
+				int offset = 0;
+				for (int i = 0; i < current_screen_index + 1; i++)
+				{
+					offset += screens[i].width * i;
+				}
+				if (DEBUG)
+					printf("offset: %d\n", offset);
+				// XResizeWindow(dpy, termwin, screens[current_screen_index].width * 0.8, height);
+				// XResizeWindow(dpy, win, screens[current_screen_index].width * 0.8, height + opt_bw);
+				offset += screens[current_screen_index].width * 0.1;
+				// XMoveWindow(dpy, win, offset, 0);
+				opt_x = offset;
+				if (!hidden)
+				{
+
+					XGetInputFocus(dpy, &current_focused, &revert_to);
+					if (last_focused && current_focused == termwin)
+						XSetInputFocus(dpy, last_focused,
+													 RevertToPointerRoot, CurrentTime);
+					/* else
+		       XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime); */
+					if (opt_step && !fullscreen)
+						roll(UP);
+					XMoveWindow(dpy, win, opt_x, -height - opt_bw);
+					hidden = 1;
+					XSync(dpy, False);
+				}
+				else
+				{
+					XRaiseWindow(dpy, win);
+					XGetInputFocus(dpy, &last_focused, &revert_to);
+					XSetInputFocus(dpy, termwin, RevertToPointerRoot,
+												 CurrentTime);
+
+					if (opt_step && !fullscreen)
+					{
+						XGrabServer(dpy);
+						roll(DOWN);
+						XUngrabServer(dpy);
+					}
+					XMoveWindow(dpy, win, opt_x, 0);
+
+					transparency_hack();
+					hidden = 0;
+				}
+				break;
+			}
+			if (!hidden)
+			{
+				if (key == opt_key_full)
+				{
+					if (!fullscreen)
+					{
+						old_height = height;
+						height = DisplayHeight(dpy, screen);
+						fullscreen = 1;
+					}
+					else
+					{
+						height = old_height;
+						fullscreen = 0;
+					}
+				}
+
+				if (key == opt_key_bigger)
+					height += resize_inc;
+				if (key == opt_key_smaller)
+					height -= resize_inc;
+				if (height < resize_inc)
+					height = resize_inc;
+				// XResizeWindow(dpy, termwin, opt_width, height);
+				// XResizeWindow(dpy, win, opt_width, height + opt_bw);
+				/* XSetInputFocus(dpy, termwin, RevertToPointerRoot, CurrentTime); */
+			}
+			break;
+		case ButtonPress:
+			resize();
+			break;
+		case UnmapNotify:
+			if (event.xunmap.window == termwin)
+			{
+				if (opt_restart)
+				{
+					if (opt_restart_hidden)
+					{
+						roll(UP);
+						hidden = 1;
+					}
+					init_xterm(0);
+					XSync(dpy, False);
+					if (opt_restart_hidden && last_focused)
+						XSetInputFocus(dpy, last_focused,
+													 RevertToPointerRoot, CurrentTime);
+					else
+						XSetInputFocus(dpy, termwin, RevertToPointerRoot,
+													 CurrentTime);
+				}
+				else
+				{
+					if (last_focused)
+						XSetInputFocus(dpy, last_focused,
+													 RevertToPointerRoot, CurrentTime);
+					XSync(dpy, False);
+					exit(0);
+				}
+			}
+			break;
 		}
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	int i;
+
+	/* strip the path from argv[0] if there is one */
+	progname = strrchr(argv[0], '/');
+	if (!progname)
+		progname = argv[0];
+	else
+		progname++;
 
-		if (key == opt_key_bigger)
-		    height += resize_inc;
-		if (key == opt_key_smaller)
-		    height -= resize_inc;
-		if (height < resize_inc)
-		    height = resize_inc;
-		XResizeWindow(dpy, termwin, opt_width, height);
-		XResizeWindow(dpy, win, opt_width, height + opt_bw);
-		/* XSetInputFocus(dpy, termwin, RevertToPointerRoot, CurrentTime); */
-	    }
-	    break;
-	case ButtonPress:
-	    resize();
-	    break;
-	case UnmapNotify:
-	    if (event.xunmap.window == termwin) {
-		if (opt_restart) {
-		    init_xterm(0);
-		    XSync(dpy, False);
-		    XSetInputFocus(dpy, termwin, RevertToPointerRoot,
-				   CurrentTime);
-		} else {
-		    if (last_focused)
-			XSetInputFocus(dpy, last_focused,
-				       RevertToPointerRoot, CurrentTime);
-		    XSync(dpy, False);
-		    exit(0);
+	printf("progname: %s\n", argv[0]);
+	for (i = 1; i < argc; i++)
+	{
+		if (!strcmp(argv[i], "-h"))
+		{
+			printf("%s:\n"
+						 "-e: program to execute\n"
+						 "you can configure me via xresources:\n"
+						 "%s*foo:value\n"
+						 "foo can be any standard xterm/urxvt xresource or:\n"
+						 "resource               default value\n\n"
+						 "term:                  xterm\n"
+						 "restart:               0\n"
+						 "xOffset:               0\n"
+						 "screenWidth:           Display width\n"
+						 "consoleHeight:         10\n"
+						 "aniDelay:              40\n"
+						 "stepSize;              1\n"
+						 "toggleKey:             ControlAlt+y\n"
+						 "keySmaller:            Control+KP_Subtract\n"
+						 "keyBigger:             Control+KP_Add\n"
+						 "keyFull:               Alt+F11\n",
+						 progname, progname);
+			exit(0);
 		}
-	    }
-	    break;
 	}
-    }
-    return 0;
+
+	if (!(dpy = XOpenDisplay(NULL)))
+	{
+		fprintf(stderr, " can not open dpy %s", XDisplayName(NULL));
+	}
+	screen = DefaultScreen(dpy);
+	root = RootWindow(dpy, screen);
+	XSetErrorHandler(handle_xerror);
+	cursor = XCreateFontCursor(dpy, XC_double_arrow);
+
+	init_screens();
+	printf("width: %f\n", screens[0].width * 0.8);
+	// init_mouse();
+	get_defaults();
+	init_win();
+	init_command(argc, argv);
+	init_xterm(1);
+
+	pthread_create(&check_mouse_screen_thread, NULL, check_mouse_screen, NULL);
+	pthread_create(&check_working_window_events_thread, NULL, check_working_window_events, NULL);
+	pthread_join(check_mouse_screen_thread, NULL);
+	pthread_join(check_working_window_events_thread, NULL);
+
+
+	return 0;
 }
 
 void roll(int i)
 {
-    int x = height / 100 + 1 + opt_step;
+	int x = height / 100 + 1 + opt_step;
 
-    if (i == 0)
-	x = -x;
-
-    while (1) {
-	i += x;
-	XMoveWindow(dpy, win, opt_x, i);
-	XSync(dpy, False);
-	usleep(opt_delay * 100);
-	if (i / x == 0 || i < -(height + opt_bw))
-	    break;
-    }
+	if (i == 0)
+		x = -x;
 
+	while (1)
+	{
+		i += x;
+		XMoveWindow(dpy, win, opt_x, i);
+		XSync(dpy, False);
+		usleep(opt_delay * 100);
+		if (i / x == 0 || i < -(height + opt_bw))
+			break;
+	}
 }
 
 void get_defaults()
 {
-    char *opt;
-    XModifierKeymap *modmap;
-    unsigned int numlockmask = 0;
-    int i, j;
-    char def_key[] = "ControlAlt+y";
-    char def_key_bigger[] = "Control+KP_Add";
-    char def_key_smaller[] = "Control+KP_Subtract";
-    char def_key_full[] = "Alt+F11";
-
-    /* modifier stuff taken from evilwm */
-    modmap = XGetModifierMapping(dpy);
-    for (i = 0; i < 8; i++) {
-	for (j = 0; j < modmap->max_keypermod; j++) {
-	    if (modmap->modifiermap[i * modmap->max_keypermod + j] ==
-		XKeysymToKeycode(dpy, XK_Num_Lock)) {
-		numlockmask = (1 << i);
-	    }
-	}
-    }
-    XFreeModifiermap(modmap);
-    opt = XGetDefault(dpy, progname, "screenWidth");
-    opt_width = opt ? atoi(opt) : DisplayWidth(dpy, screen);
-    opt = XGetDefault(dpy, progname, "handleColor");
-    opt_color = opt ? opt : "grey70";
-    opt = XGetDefault(dpy, progname, "handleWidth");
-    opt_bw = opt ? atoi(opt) : 3;
-    opt = XGetDefault(dpy, progname, "consoleHeight");
-    opt_height = opt ? atoi(opt) : 10;
-    opt = XGetDefault(dpy, progname, "xOffset");
-    opt_x = opt ? atoi(opt) : 0;
-    opt = XGetDefault(dpy, progname, "aniDelay");
-    opt_delay = opt ? atoi(opt) : 40;
-    opt = XGetDefault(dpy, progname, "stepSize");
-    opt_step = opt ? atoi(opt) : 1;
-    opt = XGetDefault(dpy, progname, "restart");
-    opt_restart = opt ? atoi(opt) : 0;
-    opt = XGetDefault(dpy, progname, "term");
-    opt_term = opt ? opt : "xterm";
-    opt = XGetDefault(dpy, progname, "toggleKey");
-    opt_key =
-	opt ? grab_that_key(opt, numlockmask) : grab_that_key(def_key,
-							      numlockmask);
-    opt = XGetDefault(dpy, progname, "keySmaller");
-    opt_key_smaller =
-	opt ? grab_that_key(opt,
-			    numlockmask) : grab_that_key(def_key_smaller,
-							 numlockmask);
-    opt = XGetDefault(dpy, progname, "keyBigger");
-    opt_key_bigger =
-	opt ? grab_that_key(opt,
-			    numlockmask) : grab_that_key(def_key_bigger,
-							 numlockmask);
-    opt = XGetDefault(dpy, progname, "keyFull");
-    opt_key_full =
-	opt ? grab_that_key(opt, numlockmask) : grab_that_key(def_key_full,
-							      numlockmask);
+	char *opt;
+	XModifierKeymap *modmap;
+	unsigned int numlockmask = 0;
+	int i, j;
+	char def_key[] = "ControlAlt+y";
+	char def_key_bigger[] = "Control+KP_Add";
+	char def_key_smaller[] = "Control+KP_Subtract";
+	char def_key_full[] = "Alt+F11";
+
+	/* modifier stuff taken from evilwm */
+	modmap = XGetModifierMapping(dpy);
+	for (i = 0; i < 8; i++)
+	{
+		for (j = 0; j < modmap->max_keypermod; j++)
+		{
+			if (modmap->modifiermap[i * modmap->max_keypermod + j] ==
+					XKeysymToKeycode(dpy, XK_Num_Lock))
+			{
+				numlockmask = (1 << i);
+			}
+		}
+	}
+	
+	XFreeModifiermap(modmap);
+	opt = XGetDefault(dpy, progname, "screenWidth");
+	opt_width = opt ? atoi(opt) : DisplayWidth(dpy, screen);
+	opt_width = screens[0].width * 0.8;
+	opt = XGetDefault(dpy, progname, "handleColor");
+	opt_color = opt ? opt : "grey70";
+	opt = XGetDefault(dpy, progname, "handleWidth");
+	opt_bw = opt ? atoi(opt) : 3;
+	opt = XGetDefault(dpy, progname, "consoleHeight");
+	opt_height = opt ? atoi(opt) : 10;
+	opt = XGetDefault(dpy, progname, "xOffset");
+	opt_x = opt ? atoi(opt) : 0;
+	opt = XGetDefault(dpy, progname, "aniDelay");
+	opt_delay = opt ? atoi(opt) : 40;
+	opt = XGetDefault(dpy, progname, "stepSize");
+	opt_step = opt ? atoi(opt) : 1;
+	opt = XGetDefault(dpy, progname, "restart");
+	opt_restart = opt ? atoi(opt) : 0;
+	opt = XGetDefault(dpy, progname, "restartHidden");
+	opt_restart_hidden = opt ? atoi(opt) : 0;
+	opt = XGetDefault(dpy, progname, "term");
+	opt_term = opt ? opt : "xterm";
+	opt = XGetDefault(dpy, progname, "termExtraParams");
+	opt_term_extra_params = opt ? opt : "";
+	// printf("progname: %s opt_term: %s opt_step: %d\n", progname, opt_term, opt_step);
+	opt = XGetDefault(dpy, progname, "toggleKey");
+	opt_key =
+			opt ? grab_that_key(opt, numlockmask) : grab_that_key(def_key, numlockmask);
+	opt = XGetDefault(dpy, progname, "keySmaller");
+	opt_key_smaller =
+			opt ? grab_that_key(opt,
+													numlockmask)
+					: grab_that_key(def_key_smaller,
+													numlockmask);
+	opt = XGetDefault(dpy, progname, "keyBigger");
+	opt_key_bigger =
+			opt ? grab_that_key(opt,
+													numlockmask)
+					: grab_that_key(def_key_bigger,
+													numlockmask);
+	opt = XGetDefault(dpy, progname, "keyFull");
+	opt_key_full =
+			opt ? grab_that_key(opt, numlockmask) : grab_that_key(def_key_full, numlockmask);
 }
 
 KeySym grab_that_key(char *opt, unsigned int numlockmask)
 {
-    unsigned int modmask = 0;
-    KeySym keysym;
-	
-    if (strstr(opt, "Control"))
-	modmask = modmask | ControlMask;
-    if (strstr(opt, "Alt"))
-	modmask = modmask | Mod1Mask;
-    if (strstr(opt, "Win"))
-	modmask = modmask | Mod4Mask;
-    if (strstr(opt, "None"))
-	modmask = 0;
-
-    opt = strrchr(opt, '+');
-    keysym = XStringToKeysym(++opt);
-	
-    XGrabKey(dpy, XKeysymToKeycode(dpy, keysym), modmask, root, True,
-	     GrabModeAsync, GrabModeAsync);
-    XGrabKey(dpy, XKeysymToKeycode(dpy, keysym), LockMask | modmask, root,
-	     True, GrabModeAsync, GrabModeAsync);
-    if (numlockmask) {
-	XGrabKey(dpy, XKeysymToKeycode(dpy, keysym), numlockmask | modmask,
-		 root, True, GrabModeAsync, GrabModeAsync);
-	XGrabKey(dpy, XKeysymToKeycode(dpy, keysym),
-		 numlockmask | LockMask | modmask, root, True,
-		 GrabModeAsync, GrabModeAsync);
+	unsigned int modmask = 0;
+	KeySym keysym;
 
-    }
-    return keysym;
+	if (strstr(opt, "Control"))
+		modmask = modmask | ControlMask;
+	if (strstr(opt, "Alt"))
+		modmask = modmask | Mod1Mask;
+	if (strstr(opt, "Win"))
+		modmask = modmask | Mod4Mask;
+	if (strstr(opt, "None"))
+		modmask = 0;
+
+	opt = strrchr(opt, '+');
+	keysym = XStringToKeysym(++opt);
+
+	XGrabKey(dpy, XKeysymToKeycode(dpy, keysym), modmask, root, True,
+					 GrabModeAsync, GrabModeAsync);
+	XGrabKey(dpy, XKeysymToKeycode(dpy, keysym), LockMask | modmask, root,
+					 True, GrabModeAsync, GrabModeAsync);
+	if (numlockmask)
+	{
+		XGrabKey(dpy, XKeysymToKeycode(dpy, keysym), numlockmask | modmask,
+						 root, True, GrabModeAsync, GrabModeAsync);
+		XGrabKey(dpy, XKeysymToKeycode(dpy, keysym),
+						 numlockmask | LockMask | modmask, root, True,
+						 GrabModeAsync, GrabModeAsync);
+	}
+	return keysym;
 }
 
 void init_win()
 {
-    XSetWindowAttributes attrib;
-    XColor color;
-    XColor dummy_color;
-
-    attrib.override_redirect = True;
-    attrib.background_pixel = BlackPixel(dpy, screen);
-    win = XCreateWindow(dpy, root,
-			opt_x, -200, opt_width, 200,
-			0, CopyFromParent, InputOutput, CopyFromParent,
-			CWOverrideRedirect | CWBackPixel, &attrib);
-    XSelectInput(dpy, win,
-		 SubstructureNotifyMask | EnterWindowMask | LeaveWindowMask
-		 | KeyPressMask | ButtonPressMask | ButtonReleaseMask);
-    XAllocNamedColor(dpy, DefaultColormap(dpy, screen), opt_color, &color,
-		     &dummy_color);
-    XSetWindowBackground(dpy, win, color.pixel);
-    XDefineCursor(dpy, win, cursor);
-    XMapWindow(dpy, win);
+	XSetWindowAttributes attrib;
+	XColor color;
+	XColor dummy_color;
+
+	attrib.override_redirect = True;
+	attrib.background_pixel = BlackPixel(dpy, screen);
+	win = XCreateWindow(dpy, root,
+											opt_x, -200, opt_width, 200,
+											0, CopyFromParent, InputOutput, CopyFromParent,
+											CWOverrideRedirect | CWBackPixel, &attrib);
+	XSelectInput(dpy, win,
+							 SubstructureNotifyMask | EnterWindowMask | LeaveWindowMask | KeyPressMask | ButtonPressMask | ButtonReleaseMask);
+	XAllocNamedColor(dpy, DefaultColormap(dpy, screen), opt_color, &color,
+									 &dummy_color);
+	XSetWindowBackground(dpy, win, color.pixel);
+	XDefineCursor(dpy, win, cursor);
+	XMapWindow(dpy, win);
 }
 
+
 void init_xterm(move)
 {
-    XEvent ev;
-    long dummy;
-    XSizeHints *size;
-
-    system(command);
-    while (1) {
-	XMaskEvent(dpy, SubstructureNotifyMask, &ev);
-	if (ev.type == CreateNotify || ev.type == MapNotify) {
-	    termwin = ev.xcreatewindow.window;
-	    break;
-	}
-    }
-
-    XSetWindowBorderWidth(dpy, termwin, 0);
-    size = XAllocSizeHints();
-    XGetWMNormalHints(dpy, termwin, size, &dummy);
-    resize_inc = size->height_inc;
-    if (move)
-	height = resize_inc * opt_height;
-    XFree(size);
-    XResizeWindow(dpy, termwin, opt_width, height);
-    XResizeWindow(dpy, win, opt_width, height + opt_bw);
-    if (move)
-	XMoveWindow(dpy, win, opt_x, -(height + opt_bw));
+	XEvent ev;
+	long dummy;
+	XSizeHints *size;
+
+	printf("command: %s\n", command);
+	int test_flag = system(command);
+	printf("test_flag: %d\n", test_flag);
+
+	while (1)
+	{
+		XMaskEvent(dpy, SubstructureNotifyMask, &ev);
+		if (ev.type == CreateNotify || ev.type == MapNotify)
+		{
+			termwin = ev.xcreatewindow.window;
+			break;
+		}
+	}
+
+	XSetWindowBorderWidth(dpy, termwin, 0);
+	XSetWindowBorderWidth(dpy, win, 0);
+	size = XAllocSizeHints();
+	XGetWMNormalHints(dpy, termwin, size, &dummy);
+	resize_inc = size->height_inc;
+	if (move)
+		height = resize_inc * opt_height;
+	XFree(size);
+	XResizeWindow(dpy, termwin, opt_width, height);
+	XResizeWindow(dpy, win, opt_width, height + opt_bw);
+	// printf("opt_width: %d\n", opt_width);
+	if (move)
+		XMoveWindow(dpy, win, opt_x, -(height + opt_bw));
 }
 
 void init_command(int argc, char *argv[])
 {
 
-    int i;
-    char *pos;
-    pos = command;
-    if (strstr(opt_term, "urxvt"))
-	pos +=
-	    sprintf(pos, "%s -b 0 -embed %d -name %s ", opt_term, (int) win,
-		    progname);
-    else
-	pos +=
-	    sprintf(pos, "%s -b 0 -into %d -name %s ", opt_term, (int) win,
-		    progname);
-    for (i = 1; i < argc; i++) {
-	pos += sprintf(pos, "%s ", argv[i]);
-
-    }
-    sprintf(pos, "&");
+	int i;
+	char *pos;
+	pos = command;
+	// if (strstr(opt_term, "urxvt"))
+	// 	pos +=
+	// 			sprintf(pos, "%s -b 0 -embed %d -name %s ", opt_term, (int)win,
+	// 							progname);
+	// else
+		pos +=
+				sprintf(pos, "%s %d", opt_term, (int)win);
+		// pos +=
+		// 		sprintf(pos, "%s -b 0 -into %d -name %s ", opt_term, (int)win,
+		// 						progname);
+	for (i = 1; i < argc; i++)
+	{
+		pos += sprintf(pos, "%s ", argv[i]);
+	}
+	pos += sprintf(pos, " %s &", opt_term_extra_params);
 }
 
 void resize()
 {
-    XEvent ev;
-    if (!XGrabPointer
-	(dpy, root, False,
-	 ButtonPressMask | ButtonReleaseMask | PointerMotionMask,
-	 GrabModeAsync, GrabModeAsync, None, cursor,
-	 CurrentTime) == GrabSuccess)
-	return;
-    for (;;) {
-	XMaskEvent(dpy,
-		   ButtonPressMask | ButtonReleaseMask |
-		   PointerMotionHintMask, &ev);
-	switch (ev.type) {
-	case MotionNotify:
-	    if (ev.xmotion.y >= resize_inc) {
-		height = ev.xmotion.y - ev.xmotion.y % resize_inc;
-		XResizeWindow(dpy, termwin, opt_width, height);
-		XResizeWindow(dpy, win, opt_width, height + opt_bw);
-		XSync(dpy, False);
-		break;
-	case ButtonRelease:
-		XUngrabPointer(dpy, CurrentTime);
+	XEvent ev;
+	if (!XGrabPointer(dpy, root, False,
+										ButtonPressMask | ButtonReleaseMask | PointerMotionMask,
+										GrabModeAsync, GrabModeAsync, None, cursor,
+										CurrentTime) == GrabSuccess)
 		return;
-
-	    }
+	for (;;)
+	{
+		XMaskEvent(dpy,
+							 ButtonPressMask | ButtonReleaseMask |
+									 PointerMotionHintMask,
+							 &ev);
+		switch (ev.type)
+		{
+		case MotionNotify:
+			if (ev.xmotion.y >= resize_inc)
+			{
+				height = ev.xmotion.y - ev.xmotion.y % resize_inc;
+				XResizeWindow(dpy, termwin, opt_width, height);
+				XResizeWindow(dpy, win, opt_width, height + opt_bw);
+				XSync(dpy, False);
+				break;
+			case ButtonRelease:
+				XUngrabPointer(dpy, CurrentTime);
+				return;
+			}
+		}
 	}
-    }
 }
 
-int handle_xerror(Display * display, XErrorEvent * e)
+int handle_xerror(Display *display, XErrorEvent *e)
 {
-    /* this function does nothing, we receive xerrors
+	/* this function does nothing, we receive xerrors
        when the last_focused window gets lost.. */
-    /* fprintf(stderr, "XError caught\n"); */
-    fprintf(stderr, "%d  XError caught\n", e->error_code);
-    return 0;
+	/* fprintf(stderr, "XError caught\n"); */
+	fprintf(stderr, "XError caught: error_code: %d request_code: %d\n", e->error_code, e->request_code);
+	return 0;
 }
